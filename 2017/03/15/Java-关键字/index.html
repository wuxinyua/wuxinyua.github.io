<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX参考链接：http://www.cnblogs.com/paddix/p/5405678.html

volatile含义：volatile修饰变量 保证对变量的读取是对该变量最后一次的写入 即不会读取该变量的缓存
首先了解一下线程安全的概念：
当多个线程访问同一个类的时候，不用考">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 关键字">
<meta property="og:url" content="http://wuxinyua.github.io/2017/03/15/Java-关键字/index.html">
<meta property="og:site_name" content="Heaven">
<meta property="og:description" content="同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX参考链接：http://www.cnblogs.com/paddix/p/5405678.html

volatile含义：volatile修饰变量 保证对变量的读取是对该变量最后一次的写入 即不会读取该变量的缓存
首先了解一下线程安全的概念：
当多个线程访问同一个类的时候，不用考">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202200007-1111796802.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202224241-2101542210.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202245210-345198166.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202333460-377269897.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202355694-2106931487.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160316084831378">
<meta property="og:image" content="http://img.blog.csdn.net/20160316085031092">
<meta property="og:image" content="http://img.blog.csdn.net/20160316085142734">
<meta property="og:image" content="http://img.blog.csdn.net/20160316085319130">
<meta property="og:image" content="http://img.blog.csdn.net/20160316085415800">
<meta property="og:image" content="http://img.blog.csdn.net/20160316085627162">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337910956_9817.jpg">
<meta property="og:image" content="http://wuxinyua.github.io/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/1337910956_9817.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337910963_6079.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337910967_8133.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337910978_9542.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337910993_8515.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337911478_8471.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337911485_7934.jpg">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/25/1337911008_5159.jpg">
<meta property="og:image" content="http://images.cnitblog.com/blog/73542/201411/160024418595945.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/73542/201411/160024432651715.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/73542/201411/160024451258114.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/73542/201411/160024471405297.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/73542/201411/160024492181696.png">
<meta property="og:image" content="http://img.blog.csdn.net/20161205181623207">
<meta property="og:image" content="http://img.blog.csdn.net/20161206085522582">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910374.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910375.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910376.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910377.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910378.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/201609240910379.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/2016092409103710.png">
<meta property="og:image" content="http://files.jb51.net/file_images/article/201609/2016092409103711.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160805132326366">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="http://common.cnblogs.com/images/copycode.gif">
<meta property="og:updated_time" content="2017-03-29T01:50:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 关键字">
<meta name="twitter:description" content="同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX参考链接：http://www.cnblogs.com/paddix/p/5405678.html

volatile含义：volatile修饰变量 保证对变量的读取是对该变量最后一次的写入 即不会读取该变量的缓存
首先了解一下线程安全的概念：
当多个线程访问同一个类的时候，不用考">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202200007-1111796802.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wuxinyua.github.io/2017/03/15/Java-关键字/"/>





  <title> Java 关键字 | Heaven </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heaven</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wuxinyua.github.io/2017/03/15/Java-关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wuxinyua">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heaven">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java 关键字
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-15T22:44:27+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="同步-1-synchronized-2-volatile-3-lock-4-AtomicXX"><a href="#同步-1-synchronized-2-volatile-3-lock-4-AtomicXX" class="headerlink" title="同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX"></a><strong>同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX</strong></h4><p>参考链接：<a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5405678.html</a></p>
<hr>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>含义：volatile修饰变量 保证对变量的读取是对该变量最后一次的写入 即不会读取该变量的缓存</p>
<p>首先了解一下线程安全的概念：</p>
<p>当多个线程访问同一个类的时候，不用考虑线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方法不必作其他的协调，类的行为仍然是正确的，则类是线程安全的</p>
<p>原子性:一个操作要么执行完成，要么没有执行</p>
<p>可见性: 对一个变量的读，总是能看到（任意线程）对这个变量最后的写入</p>
<p><strong>volatile修饰的变量具有可见性</strong></p>
<p>如何保证该特性的实现：</p>
<p>在操作该变量的指令前后插入四种类型的内存屏障来禁止指令的重排序  保证<strong>happens-before原则</strong></p>
<p><em><u>使用条件</u></em>保证线程安全：</p>
<p>1.对变量的写操作不依赖于当前值</p>
<p>2.变量不在具有其他变量的不变式当中</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>1.作为简单的状态标志  </p>
<hr>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>可以修饰代码块或者方法</p>
<p>如何实现：</p>
<p>对象具有监视器锁(monitor) 只有获取该对象的锁之后才能访问对应的代码块或者方法</p>
<p>通过锁定和释放对象关联的监视器锁实现</p>
<p>synchronized修饰<u>代码块</u>的时候对应于虚拟机中的指令为：monitorenter 和 monitorexit</p>
<p>synchronized修饰<u>方法</u>的时候方法对应的ACC_SYNCHRONIZED标志被设定</p>
<h4 id="Deeper…"><a href="#Deeper…" class="headerlink" title="Deeper…"></a>Deeper…</h4><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的</p>
<p>操作系统实现线程之间的切换这就需要从用户态转换到核心态</p>
<p>锁包含偏向锁、轻量级锁和重量级锁，随着锁的竞争程度进行升级</p>
<h5 id="volatile和synchronized的区别："><a href="#volatile和synchronized的区别：" class="headerlink" title="volatile和synchronized的区别："></a><strong><em><u>volatile和synchronized的区别：</u></em></strong></h5><p>1.volatile修饰变量，synchronized修饰代码块或者方法</p>
<p>2.volatile保证变量的可见性，synchronized保证一组操作的原子性和变量的可见性</p>
<hr>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="锁的两种特性："><a href="#锁的两种特性：" class="headerlink" title="锁的两种特性："></a>锁的两种特性：</h4><p>1.<strong>互斥</strong>            一次只允许一个线程持有某个特定的锁，保证共享数据在同一时刻只有一个线程可以访问</p>
<p>2.<strong>可见性</strong>      确定锁释放之前对共享数据的修改对于随后获取该锁的另一个线程可见</p>
<h5 id="正确的使用方式："><a href="#正确的使用方式：" class="headerlink" title="正确的使用方式："></a>正确的使用方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock();</div><div class="line">...</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line">  .....</div><div class="line">&#125;finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="基本锁的获取过程"><a href="#基本锁的获取过程" class="headerlink" title="基本锁的获取过程"></a>基本锁的获取过程</h5><p>1.读取表示锁状态的变量</p>
<p>2.如果锁的状态为0，则通过CAS操作置为1 多个线程竞争时，只有一个线程成功</p>
<p>​    2.1获取锁成功</p>
<p>​        2.1.1如果线程位于等待锁的队列中 出列</p>
<p>​    2.2获取失败，进入队列，同时处于阻塞状态</p>
<p>3.如果锁状态为1，进入队列，处于阻塞状态</p>
<h5 id="释放锁过程"><a href="#释放锁过程" class="headerlink" title="释放锁过程"></a>释放锁过程</h5><p>1.锁的状态置为1，同时唤醒等待锁队列中的队首节点</p>
<p>2.被唤醒的线程(处于就绪状态)和未进入队列且准备获取锁的线程进行竞争，当处于队列中的线程竞争到锁之后才移出队列</p>
<p>可重入锁的类型： 公平锁和非公平锁</p>
<p>简单说一下区别：如果当前的锁为公平锁，则线程需要判断监视器锁的队列中是否有线程，如果有的话要先入队列</p>
<p>​            如果是非公平锁，则不需要判断队列是否为空，可以直接竞争锁</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><h5 id="ReentrantReadWriteLock-当主要操作为读访问时，可以使用提供性能"><a href="#ReentrantReadWriteLock-当主要操作为读访问时，可以使用提供性能" class="headerlink" title="ReentrantReadWriteLock  当主要操作为读访问时，可以使用提供性能"></a>ReentrantReadWriteLock  当主要操作为读访问时，可以使用提供性能</h5><p>读写锁：可以同时被多个读进程访问，或者被一个写进程访问</p>
<h4 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h4><p>1.提供和Object对象中类似的    <u>wait()</u>    和    <u>notify()</u>    和    <u>notifyAll()</u>    接口</p>
<p>​                            await()    和    signal()   和    signalAll()</p>
<p>condition内部维护一个队列，队列中包含由于自身调用await()方法阻塞的线程</p>
<h5 id="await-过程："><a href="#await-过程：" class="headerlink" title="await()过程："></a>await()过程：</h5><p>1.进入condition维护的队列</p>
<p>2.释放监视器锁</p>
<p>3.阻塞自身线程</p>
<p>(线程A调用 signalAll() 后)线程B被唤醒后：</p>
<p>1.此时线程已经从condition的队列中转移到监视器锁的队列中，尝试获取锁</p>
<p>​    1.1.成功则从await()方法中返回</p>
<p>​    1.2 否则继续阻塞在await()方法中</p>
<p><strong><u>Attention</u></strong>：wait/notify等方法依赖于monitor对象，所以只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</p>
<h5 id="正确的使用方式：-1"><a href="#正确的使用方式：-1" class="headerlink" title="正确的使用方式："></a>正确的使用方式：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">  <span class="keyword">while</span>(!conditionPredicate())</div><div class="line">      lock.wait(); <span class="comment">//condition.await();</span></div><div class="line">  <span class="comment">//开始执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong><em>lock和synchronized的区别</em></strong>：</u></p>
<p>1.lock加锁和解锁通过java代码调用<strong>native的CAS</strong>方法实现(基于类库)，synchronized通过<strong>JVM实现加锁和解锁</strong></p>
<p>2.synchronzied的使用方法比较单一，多个线程竞争锁的时候，竞争失败的锁处于阻塞状态，不能中断正在等待获取锁的线程</p>
<p>   lock锁提供多个特性的方法，包括超时机制，可中断机制，可轮询机制等</p>
<p>​    2.1可轮询：需要获取多个锁的情况  在只能获取到部分锁的时候释放已获取到的锁</p>
<p>​    2.2可定时：具有时间限制的情况</p>
<p>​    2.3可中断：活动可取消的场景</p>
<p>​    2.4公平队列 竞争机制</p>
<p>3.不同于条件队列()和内部锁，lock内部可以包含多个Condition对象  <!--啥意思--></p>
<p>4.可重入读写锁可以提供锁的共享模式(读锁)</p>
<p>当内部锁收到局限时，lock提供可选择的高级特性</p>
<hr>
<h3 id="JAVA中线程的状态"><a href="#JAVA中线程的状态" class="headerlink" title="JAVA中线程的状态"></a>JAVA中线程的状态</h3><p>public enum State{    //线程在虚拟机的状态，跟操作系统的线程状态不同</p>
<p>​    new        未启动的线程 即为调用thread.start()方法</p>
<p>​    runnable    处于可运行状态的线程，处于就绪状态，可能正在等待操作系统分配CPU或者其他资源</p>
<p>​    blocked        正在等待获取监视器锁的线程 可能正要进入同步代码块或者方法，也可能从Object.wait()方法返回再次竞争进入同步区</p>
<p>​    waiting        当线程自身调用Object.wait(),Thread.join(),LockSupport.park()方法进入等待状态 同时不带有超时参数</p>
<p>​    time_waiting  当线程自身调用与上述类似的方法且带有超时参数时，处于时等状态</p>
<p>​    terminated    线程结束执行后，处于结束状态</p>
<p>​    <!--实际上应该还有running状态：线程获取到cpu之后开始执行--></p>
<p>}</p>
<p>三种非同步的方法改变线程的状态：</p>
<p>1.sleep(time) 使得线程进入睡眠状态 此时拥有锁的线程不释放锁</p>
<p>2.join()        使得线程等待子线程执行结束后再执行</p>
<p>3.yield()         当前线程让出cpu，同时状态变为runnable状态</p>
<hr>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><hr>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><hr>
<h3 id="并发的数据结构"><a href="#并发的数据结构" class="headerlink" title="并发的数据结构"></a>并发的数据结构</h3><hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。</p>
<p>　　如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：</p>
<h2 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h2><p>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h2 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h2><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h2 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h2><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
<h2 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h2><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<p>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h2 id="1，脏读"><a href="#1，脏读" class="headerlink" title="1，脏读"></a>1，脏读</h2><p>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update account set money=money+100 where name=’B’;  (此时A通知B)</div><div class="line"></div><div class="line">update account set money=money - 100 where name=’A’;</div></pre></td></tr></table></figure>
<p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h2 id="2，不可重复读"><a href="#2，不可重复读" class="headerlink" title="2，不可重复读"></a>2，不可重复读</h2><p>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p>
<h2 id="3，虚读-幻读"><a href="#3，虚读-幻读" class="headerlink" title="3，虚读(幻读)"></a>3，虚读(幻读)</h2><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<p>　　现在来看看MySQL数据库为我们提供的四种隔离级别：</p>
<p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
<p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
<p>　　③ Read committed (读已提交)：可避免脏读的发生。</p>
<p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<p>　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>
<p>　　在MySQL数据库中查看当前事务的隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select @@tx_isolation;</div></pre></td></tr></table></figure>
<p>　　在MySQL数据库中设置事务的隔离 级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set  [glogal | session]  transaction isolation level 隔离级别名称;</div><div class="line"></div><div class="line">set tx_isolation=’隔离级别名称;’</div></pre></td></tr></table></figure>
<p>例1：查看当前事务的隔离级别：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202200007-1111796802.png" alt="img"></p>
<p>例2：将事务的隔离级别设置为Read uncommitted级别：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202224241-2101542210.png" alt="img"></p>
<p>或：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202245210-345198166.png" alt="img"></p>
<p>记住：设置数据库的隔离级别一定要是在开启事务之前！</p>
<p>　　如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202333460-377269897.png" alt="img"></p>
<p>在JDBC中设置隔离级别的部分代码：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202355694-2106931487.png" alt="img"></p>
<p>　　后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关</p>
<p>java.lang.OutOfMemoryError: PermGen space</p>
<p>发现很多人把问题归因于： spring,hibernate,tomcat，因为他们动态产生类,导致JVM中的permanent heap溢出 。然后解决方法众说纷纭，有人说升级 tomcat版本到最新甚至干脆不用tomcat。还有人怀疑spring的问题，在spring论坛上讨论很激烈，因为spring在AOP时使用CBLIB会动态产生很多类。<br>但问题是为什么这些王牌的开源会出现同一个问题呢，那么是不是更基础的原因呢？tomcat在Q&amp;A很隐晦的回答了这一点，我们知道这个问题，但这个问题是由一个更基础的问题产生。<br>于是有人对更基础的JVM做了检查，发现了问题的关键。原来SUN 的JVM把内存分了不同的区，其中一个就是permenter区用来存放用得非常多的类和类描述。本来SUN设计的时候认为这个区域在JVM启动的时候就 固定了，但他没有想到现在动态会用得这么广泛。而且这个区域有特殊的垃圾收回机制，现在的问题是动态加载类到这个区域后，gc根本没办法回收！</p>
<p>1、首先是：java.lang.OutOfMemoryError: Java heap space</p>
<p>解释：</p>
<p>Heap size 设置</p>
<p>JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。<br>提示：在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。<br>提示：Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。</p>
<p>解决方法：</p>
<p>手动设置Heap size<br>修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行： </p>
<p>复制代码 代码如下:</p>
<p>set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m </p>
<p>或修改catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行： </p>
<p>复制代码 代码如下:</p>
<p>JAVA_OPTS=”$JAVA_OPTS -server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>[html]2、其次是：java.lang.OutOfMemoryError: PermGen space原因：PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误，这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。解决方法：1. 手动设置MaxPermSize大小<br>修改TOMCAT_HOME/bin/catalina.bat（Linux下为catalina.sh），在<br>[code]<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m </p>
<p>catalina.sh下为： </p>
<p>复制代码 代码如下:</p>
<p>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”</p>
<p>以上是云栖社区小编为您精心准备的的内容，在云栖社区的博客、问答、公众号、人物、课程等栏目也有的相关内容，欢迎继续使用右上角搜索按钮进行搜索jvm内存溢出 jvm内存溢出解决方案、java内存溢出怎么解决、java内存溢出解决方法、如何解决java内存溢出、java 内存溢出 解决，以便于您获取更多的相关知识</p>
<p>Tomcat本身不能直接在计算机上运行，需要依赖于硬件基础之上的<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>和一个<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>虚拟机。Tomcat的内存溢出本质就是JVM内存溢出，所以在本文开始时，应该先对<a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java </a>JVM有关内存方面的知识进行详细介绍。</p>
<p><strong>一、Java JVM内存介绍</strong></p>
<p>JVM管理两种类型的内存，堆和非堆。按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。</p>
<p><strong>(1). 堆内存分配</strong><br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于 40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行堆内存设置，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值，建议堆的最大值设置为可用内存的最大值的80%。</p>
<p>初始化堆的大小是JVM在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果JVM启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，JVM就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时JVM就会提示内存溢出，并且导致应用服务崩溃。所以，如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。</p>
<p><strong>(2). 非堆内存分配</strong><br>也叫永久保存的区域，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。</p>
<p><strong>(3). JVM内存限制(最大值) </strong>首先JVM内存限制于实际的最大物理内存（废话！，呵呵），假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，<a href="http://lib.csdn.net/base/linux" target="_blank" rel="external">Linux</a>系统 下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<p><strong>二、三种内存溢出异常介绍</strong></p>
<p><strong>1. OutOfMemoryError： Java heap space  堆溢出</strong></p>
<p>内存溢出主要存在问题就是出现在这个情况中。当在JVM中如果98％的时间是用于GC且可用的 Heap size 不足2％的时候将抛出此异常信息。</p>
<p> <strong>2. OutOfMemoryError： PermGen space   非堆溢出（永久保存区域溢出）</strong></p>
<p>这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。如果web app用了大量的第三方jar或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。</p>
<p><strong>3. OutOfMemoryError： unable to create new native thread.   无法创建新的线程</strong></p>
<p>这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。</p>
<hr>
<p><strong>三、Java JVM内存配置</strong></p>
<p><strong>1. JVM内存分配设置的参数有四个</strong></p>
<p>-Xmx    Java Heap最大值，默认值为物理内存的1/4；</p>
<p>-Xms    Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>机JVM可以保留默认值；</p>
<p>-Xmn    Java Heap Young区大小，不熟悉最好保留默认值；</p>
<p>-Xss      每个线程的Stack大小，不熟悉最好保留默认值；</p>
<p>-XX:MaxPermSize：设定最大内存的永久保存区域；</p>
<p>-XX:PermSize：设定内存的永久保存区域；</p>
<p>-XX:NewSize：设置JVM堆的‘新生代’的默认大小；</p>
<p>-XX:MaxNewSize：设置JVM堆的‘新生代’的最大大小； </p>
<hr>
<p><strong>2. 如何设置JVM的内存分配</strong></p>
<p>（1）当在命令提示符下启动并使用JVM时（只对当前运行的类Test生效）：</p>
<blockquote>
<p>java -Xmx128m -Xms64m -Xmn32m -Xss16m Test</p>
</blockquote>
<p>（2）当在集成开发环境下（如eclipse）启动并使用JVM时：</p>
<blockquote>
<p>a. 在eclipse根目录下打开eclipse.ini，默认内容为（这里设置的是运行当前开发工具的JVM内存分配）：  -vmargs -Xms40m -Xmx256m -vmargs表示以下为虚拟机设置参数，可修改其中的参数值，也可添加-Xmn，-Xss，另外，eclipse.ini内还可以设置非   堆内存，如：-XX:PermSize=56m，-XX:MaxPermSize=128m。</p>
<p>b. 打开eclipse－窗口－首选项－Java－已安装的JRE（对在当前开发环境中运行的java程序皆生效）  编辑当前使用的JRE，在缺省VM参数中输入：-Xmx128m -Xms64m -Xmn32m –Xss16m。</p>
<p>c. 打开eclipse－运行－运行－Java应用程序（只对所设置的java类生效）  选定需设置内存分配的类－自变量，在VM自变量中输入：-Xmx128m -Xms64m -Xmn32m -Xss16m  注：如果在同一开发环境中同时进行了b和c设置，则b设置生效，c设置无效，如：  开发环境的设置为：-Xmx256m，而类Test的设置为：-Xmx128m -Xms64m，则运行Test时生效的设置为：  -Xmx256m -Xms64m。</p>
</blockquote>
<p>（3）当在服务器环境下（如Tomcat）启动并使用JVM时（对当前服务器环境下所以Java程序生效）：</p>
<blockquote>
<p>a. 设置环境变量：  变量名：CATALINA_OPTS  变量值：-Xmx128m -Xms64m -Xmn32m -Xss16m。</p>
<p>b. 打开Tomcat根目录下的bin文件夹，编辑catalina.bat，将其中的%CATALINA_OPTS%（共有四处）替换为：-Xmx128m -Xms64m -Xmn32m -Xss16m。</p>
<p>c. 若没有catalina.bat，只有tomcat.exe,tomcat6w.exe;则可以在启动tomcat6w.exe 后 右键配置–Java–java option 下面输入：</p>
<p>-Xmx256m –Xms64m</p>
<p>也可以找到注册表HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\TomcatService Manager\Tomcat6\Parameters\JavaOptions原值为 -Dcatalina.home=”C:\ApacheGroup\Tomcat 6.0” -Djava.endorsed.dirs=”C:\ApacheGroup\Tomcat 6.0\common\endorsed” -Xrs 加入  -Xms300m  -Xmx350m  （我的是加入-Xmx350m，tomcat才能启动，加入-Xms300m  -Xmx350m反而tomcat都不能启动）重起tomcat服务,设置生效。</p>
</blockquote>
<p><strong>3. 查看JVM内存信息</strong></p>
<blockquote>
<p>Runtime.getRuntime().maxMemory(); //最大可用内存，对应-Xmx </p>
<p>Runtime.getRuntime().freeMemory(); //当前JVM空闲内存 </p>
<p>Runtime.getRuntime().totalMemory(); //当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和 </p>
</blockquote>
<p>关于maxMemory()，freeMemory()和totalMemory()：maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1/4，设置不能高于计算机物理内存；  totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；  freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。</p>
<p><strong>4. 实例，以下给出1G内存环境下java jvm 的参数设置参考</strong></p>
<blockquote>
<p>JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “</p>
</blockquote>
<p>大型的web工程，用tomcat默认分配的内存空间无法启动，如果不是在myeclipse中启动tomcat可以对tomcat这样设置：</p>
<blockquote>
<p>TOMCAT_HOME\bin\catalina.bat 中添加这样一句话：</p>
<p>set JAVA_OPTS= -Xmx1024M -Xms512M -XX:MaxPermSize=256m</p>
</blockquote>
<p>如果要在myeclipse中启动，上述的修改就不起作用了，可如下设置：</p>
<blockquote>
<p>Myeclipse-&gt;preferences-&gt;myeclipse-&gt;servers-&gt;tomcat-&gt;tomcat×.×-&gt;JDK面板中的</p>
<p>Optional Java VM arguments中添加：-Xmx1024M -Xms512M -XX:MaxPermSize=256m</p>
</blockquote>
<p>对于单独的.class，可以用下面的方法对Test运行时的jvm内存进行设置。 java -Xms64m -Xmx256m Test -Xms是设置内存初始化的大小 -Xmx是设置最大能够使用内存的大小。</p>
<p><strong>四、JVM内存配置与GC</strong></p>
<p>需要考虑的是Java提供的垃圾回收机制。JVM的堆大小决定了JVM花费在收集垃圾上的时间和频度。收集垃圾可以接受的速度与应用有关，应该通过分析实际的垃圾收集的时间和频率来调整。如果堆的大小很大，那么完全垃圾收集就会很慢，但是频度会降低。如果你把堆的大小和内存的需要一致，完全收集就很快，但是会更加频繁。调整堆大小的的目的是最小化垃圾收集的时间，以在特定的时间内最大化处理客户的请求。在基准测试的时候，为保证最好的性能，要把堆的大小设大，保证垃圾收集不在整个基准测试的过程中出现。如果系统花费很多的时间收集垃圾，请减小堆大小。一次完全的垃圾收集应该不超过 3-5 秒。如果垃圾收集成为瓶颈，那么需要指定堆的大小，检查垃圾收集的详细输出，研究垃圾收集参数对性能的影响。一般说来，你应该使用物理内存的 80% 作为堆大小。当增加处理器时，记得增加内存，因为分配可以并行进行，而垃圾收集不是并行的。</p>
<p><strong>Java Heap分为3个区：</strong></p>
<p>1.Young 2.Old 3.Permanent。Young保存刚实例化的对象。当该区被填满时，GC会将对象移到Old区。Permanent区则负责保存反射对象，本文不讨论该区。</p>
<p><strong>JVM有2个GC线程： </strong>第一个线程负责回收Heap的Young区；<br>第二个线程在Heap不足时，遍历Heap，将Young 区升级为Older区，Older区的大小等于-Xmx减去-Xmn，不能将-Xms的值设的过大，因为第二个线程被迫运行会降低JVM的性能。</p>
<p><strong>为什么一些程序频繁发生GC？有如下原因： </strong>1. 程序内调用了System.gc()或Runtime.gc()。<br>\2. 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。<br>\3. Java的Heap太小，一般默认的Heap值都很小。<br>\4. 频繁实例化对象，Release对象 此时尽量保存并重用对象，例如使用StringBuffer()和String()。</p>
<p>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态许多Server端的Java程序每次GC后最好能有65%的剩余空间。</p>
<p><strong>经验之谈： </strong>1．Server端JVM最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn值约等于-Xmx的1/3。<br>2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成。</p>
<p><strong>注意： </strong>1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br>2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。</p>
<p>1，什么是栈溢出？</p>
<p>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。</p>
<p>2，解决方案：</p>
<p>方法一：用栈把递归转换成非递归</p>
<p>通常,一个函数在调用另一个函数之前,要作如下的事情:a)将实在参数,返回地址等信息传递给被调用函数保存; b)为被调用函数的局部变量分配存储区;c)将控制转移到被调函数的入口. 从被调用函数返回调用函数之前,也要做三件事情:a)保存被调函数的计算结果;b)释放被调函数的数据区;c)依照被调函数保存的返回地址将控制转移到调用函数.所有的这些,不论是变量还是地址,本质上来说都是”数据”,都是保存在系统所分配的栈中的. 那么自己就可以写一个栈来存储必要的数据，以减少系统负担。</p>
<p>方法二：使用static对象替代nonstatic局部对象</p>
<p>在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</p>
<p>方法三：增大堆栈大小值</p>
<p>当创建一个线程的堆栈时，系统将会保留一个链接程序的/STACK开关指明的地址空间区域。但是，当调用CreateThread或_beginthreadex函数时，可以重载原先提交的内存数量。这两个函数都有一个参数，可以用来重载原先提交给堆栈的地址空间的内存数量。如果设定这个参数为0，那么系统将使用/STACK开关指明的已提交的堆栈大小值。后面将假定我们使用默认的堆栈大小值，即1MB的保留区域，每次提交一个页面的内存。</p>
<p><a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>在创建线程时设置栈大小：thread(threadgroup group, runnable target, string name, long stacksize)<br>​         分配新的 thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，作为 group 所引用的线程组的一员，并具有指定的堆栈大小。</p>
<p>Java虚拟机的堆大小如何设置：命令行</p>
<p>　java –Xms128m   //JVM占用最小内存</p>
<p>​     –Xmx512m   //JVM占用最大内存</p>
<p>​     –XX:PermSize=64m   //最小堆大小</p>
<p>​     –XX:MaxPermSize=128m //最大堆大小</p>
<p>在搭建完集群环境后，不得不考虑的一个问题就是用户访问产生的session如何处理。如果不做任何处理的话，用户将出现频繁登录的现象，比如集群中存在A、B两台服务器，用户在第一次访问网站时，Nginx通过其负载均衡机制将用户请求转发到A服务器，这时A服务器就会给用户创建一个Session。当用户第二次发送请求时，Nginx将其负载均衡到B服务器，而这时候B服务器并不存在Session，所以就会将用户踢到登录页面。这将大大降低用户体验度，导致用户的流失，这种情况是项目绝不应该出现的。</p>
<p>我们应当对产生的Session进行处理，通过粘性Session，Session复制或Session共享等方式保证用户的体验度。</p>
<p>以下我将说明5种Session处理策略，并分析其优劣性。</p>
<p>第一种：粘性session</p>
<p>原理：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p>优点：简单，不需要对session做任何处理。</p>
<p>缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。</p>
<p>适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。</p>
<p>实现方式：以Nginx为例，在upstream模块配置ip_hash属性即可实现粘性Session。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream mycluster&#123;</div><div class="line">    #这里添加的是上面启动好的两台Tomcat服务器</div><div class="line">    ip_hash;#粘性Session</div><div class="line">     server 192.168.22.229:8080 weight=1;</div><div class="line">     server 192.168.22.230:8080 weight=1;</div><div class="line">&#125;123456123456</div></pre></td></tr></table></figure>
<p>第二种：服务器session复制</p>
<p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p>优点：可容错，各个服务器间session能够实时响应。</p>
<p>缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</p>
<p>实现方式：</p>
<p>① 设置tomcat ，server.xml 开启tomcat集群功能</p>
<p><img src="http://img.blog.csdn.net/20160316084831378" alt="这里写图片描述"></p>
<p>Address:填写本机ip即可，设置端口号，预防端口冲突。</p>
<p>② 在应用里增加信息：通知应用当前处于集群环境中，支持分布式<br>在web.xml中添加选项</p>
<p>第三种：session共享机制</p>
<p>使用分布式缓存方案比如memcached、<a href="http://lib.csdn.net/base/redis" target="_blank" rel="external">Redis</a>，但是要求Memcached或Redis必须是集群。</p>
<p>使用Session共享也分两种机制，两种情况如下：</p>
<p>① 粘性session处理方式</p>
<p>原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上。memcache只起备份作用，读写都在tomcat上。当某一个tomcat挂掉后，集群将用户的访问定位到备tomcat上，然后根据cookie中存储的SessionId找session，找不到时，再去相应的memcached上去session，找到之后将其复制到备tomcat上。</p>
<p><img src="http://img.blog.csdn.net/20160316085031092" alt="这里写图片描述"></p>
<p>② 非粘性session处理方式</p>
<p>原理：memcached做主从复制，写入session都往从memcached服务上写，读取都从主memcached读取，tomcat本身不存储session</p>
<p><img src="http://img.blog.csdn.net/20160316085142734" alt="这里写图片描述"></p>
<p>优点：可容错，session实时响应。</p>
<p>实现方式：用开源的msm插件解决tomcat之间的session共享：Memcached_Session_Manager（MSM）</p>
<p>a. 复制相关jar包到tomcat/lib 目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">JAVA memcached客户端：spymemcached.jar</div><div class="line"></div><div class="line">msm项目相关的jar包：</div><div class="line"></div><div class="line">1. 核心包，memcached-session-manager-&#123;version&#125;.jar</div><div class="line">2. Tomcat版本对应的jar包：memcached-session-manager-tc&#123;tomcat-version&#125;-&#123;version&#125;.jar</div><div class="line"></div><div class="line">序列化工具包：可选kryo，javolution,xstream等，不设置时使用jdk默认序列化。1234567812345678</div></pre></td></tr></table></figure>
<p>b. 配置Context.xml ，加入处理Session的Manager</p>
<p>粘性模式配置：</p>
<p><img src="http://img.blog.csdn.net/20160316085319130" alt="这里写图片描述"></p>
<p>非粘性配置：</p>
<p><img src="http://img.blog.csdn.net/20160316085415800" alt="这里写图片描述"></p>
<p>第四种：session持久化到<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a></p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。</p>
<p>优点：服务器出现问题，session不会丢失</p>
<p>缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<p>第五种terracotta实现session复制</p>
<p>原理：Terracotta的基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta只把变化的部分发送给Terracotta服务器，然后由服务器把它转发给真正需要这个数据的节点。可以看成是对第二种方案的优化。</p>
<p><img src="http://img.blog.csdn.net/20160316085627162" alt="这里写图片描述"><br>优点：这样对网络的压力就非常小，各个节点也不必浪费CPU时间和内存进行大量的序列化操作。把这种集群间数据共享的机制应用在session同步上，既避免了对数据库的依赖，又能达到负载均衡和灾难恢复的效果。</p>
<p>小结</p>
<p>以上讲述的就是集群或分布式环境下，session的5种处理策略。其中就应用广泛性而言，第三种方式，也就是基于第三方缓存框架共享session，应用的最为广泛，无论是效率还是扩展性都很好。而Terracotta作为一个JVM级的开源群集框架，不仅提供HTTP Session复制，它还能做分布式缓存，POJO群集，跨越群集的JVM来实现分布式应用程序协调等，也值得学习一下。</p>
<p>HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</p>
<p>​    通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p>通用头域（即通用头）</p>
<p>通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。</p>
<p>Cache-Control头域</p>
<p>Cache -Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：Public指示响应可被任何缓存区缓存；Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效；no-cache指示请求或响应消息不能缓存；no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存；max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应；min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应；max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>
<p>Date头域</p>
<p>date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<p>Pragma头域</p>
<p>Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。</p>
<p>Connection表示连接状态</p>
<p>请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>
<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>
<p>响应：close（连接已经关闭）。</p>
<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>
<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>
<p>请求消息（请求头）</p>
<p>请求消息的第一行为下面的格式：</p>
<p>Method Request-URI HTTP-Version</p>
<p>Method 表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、 TRACE。方法GET和HEAD应该被所有的通用WEB服务器支持，其他所有方法的实现是可选的，GET方法取回由Request-URI标识的信息， HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体；POST方法可以请求服务器接收包含在请求中的实体信息，可以用于提交表单，向新闻组、BBS、邮件群组和数据库发送消息。Request-URI表示请求的URL。Request-URI遵循URI格式，在此字段为星号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务器本身。HTTP- Version表示支持的HTTP版本，例如为HTTP/1.1。</p>
<p>请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域,一般将会作为实体头域处理。</p>
<p>典型的请求消息：</p>
<p>GET <a href="http://download.microtool.de:80/somedata.exe" target="_blank" rel="external">http://download.microtool.de:80/somedata.exe</a></p>
<p>Host: download.microtool.de</p>
<p>Accept:<em>/</em></p>
<p>Pragma: no-cache</p>
<p>Cache-Control: no-cache</p>
<p>Referer: <a href="http://download.microtool.de/" target="_blank" rel="external">http://download.microtool.de/</a></p>
<p>User-Agent:Mozilla/4.04<a href="Win95;I;Nav">en</a></p>
<p>Range:bytes=554554-</p>
<p>上例第一行表示HTTP客户端（可能是浏览器、下载程序）通过GET方法获得指定URL下的文件。棕色的部分表示请求头域的信息，绿色的部分表示通用头部分。</p>
<p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回；Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。Accept-Charset： 浏览器申明自己接收的字符集。Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。User-Agent头域的内容包含发出请求的用户信息。Referer 头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址； Range头域可以请求实体的一个或者多个子范围。例如</p>
<p>表示头500个字节：bytes=0-499</p>
<p>表示第二个500字节：bytes=500-999</p>
<p>表示最后500个字节：bytes=-500</p>
<p>表示500字节以后的范围：bytes=500-</p>
<p>第一个和最后一个字节：bytes=0-0,-1</p>
<p>同时指定几个范围：bytes=500-600,601-999</p>
<p>但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）</p>
<p>响应消息（响应头）</p>
<p>响应消息的第一行为下面的格式：</p>
<p>HTTP-Version Status-Code Reason-Phrase</p>
<p>HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。Status- Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自 动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：</p>
<p>1xx:信息响应类，表示接收到请求并且继续处理</p>
<p>2xx:处理成功响应类，表示动作被成功接收、理解和接受</p>
<p>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理</p>
<p>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行</p>
<p>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>
<p>响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头 域，一般将会作为实体头域处理。</p>
<p>典型的响应消息：</p>
<p>HTTP/1.0 200 OK</p>
<p>Date:Mon,31Dec200104:25:57GMT</p>
<p>Server:Apache/1.3.14(Unix)</p>
<p>Content-type:text/html</p>
<p>Last-modified:Tue,17Apr200106:46:28GMT</p>
<p>Etag:”a030f020ac7c01:1e9f”</p>
<p>Content-length:39725426</p>
<p>Content-range:bytes554554-40279979/40279980</p>
<p>上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。</p>
<p>Location响应头用于重定向接收者到一个新URI地址。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序</p>
<p>实体消息（实体头和实体）</p>
<p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。</p>
<p>实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。</p>
<p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型，表示后面的文档属于什么MIME类型。Content-Length表示实际传送的字节数。Allow 实体头至服务器支持哪些请求方法（如GET、POST等）。Content-Range表示传送的范围，用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：</p>
<p>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth</p>
<p>例 如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求）。Content-Encoding 指文档的编码（Encode）方法。</p>
<p>实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。</p>
<p>附录：</p>
<p>HTTP头部详解</p>
<p>1、 Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>
<p>2、 Accept-Charset： 浏览器申明自己接收的字符集</p>
<p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</p>
<p>Accept-Language：：浏览器申明自己接收的语言</p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>
<p>3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</p>
<p>4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p>
<p>5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</p>
<p>6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）</p>
<p>max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）</p>
<p>max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）</p>
<p>min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）</p>
<p>响应：public(可以用 Cached 内容回应任何用户)</p>
<p>private（只能用缓存内容回应先前请求该内容的那个用户）</p>
<p>no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）</p>
<p>max-age：（本响应包含的对象的过期时间）</p>
<p>ALL: no-store（不允许缓存）</p>
<p>7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>
<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>
<p>响应：close（连接已经关闭）。</p>
<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>
<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>
<p>8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p>
<p>9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。</p>
<p>10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012</p>
<p>11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</p>
<p>12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</p>
<p>13、 ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。</p>
<p>14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</p>
<p>15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p>
<p>16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</p>
<p>17、If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</p>
<p>18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</p>
<p>19、If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</p>
<p>20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</p>
<p>21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p>
<p>22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：<a href="http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif" target="_blank" rel="external">http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</a></p>
<p>23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache</p>
<p>24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p>
<p>25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</p>
<p>26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：<a href="http://www.sina.com/" target="_blank" rel="external">http://www.sina.com/</a></p>
<p>27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)</p>
<p>28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p>
<p>29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</p>
<p>30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding</p>
<p>31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<p>===============================================================================</p>
<p>HTTP 请求消息头部实例：</p>
<p>Host：rss.sina.com.cn</p>
<p>User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14</p>
<p>Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,<em>/</em>;q=0、5</p>
<p>Accept-Language：zh-cn,zh;q=0、5</p>
<p>Accept-Encoding：gzip,deflate</p>
<p>Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7</p>
<p>Keep-Alive：300</p>
<p>Connection：keep-alive</p>
<p>Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;– Cookie</p>
<p>If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT</p>
<p>Cache-Control：max-age=0</p>
<p>HTTP 响应消息头部实例：</p>
<p>Status：OK - 200 &lt;– 响应状态码，表示 web 服务器处理的结果。</p>
<p>Date：Sun, 01 Jun 2008 12:35:47 GMT</p>
<p>Server：Apache/2、0、61 (Unix)</p>
<p>Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT</p>
<p>Accept-Ranges：bytes</p>
<p>Content-Length：18616</p>
<p>Cache-Control：max-age=120</p>
<p>Expires：Sun, 01 Jun 2008 12:37:47 GMT</p>
<p>Content-Type：application/xml</p>
<p>Age：2</p>
<p>X-Cache：HIT from 236-41、D07071951、sina、com、cn &lt;– 反向代理服务器使用的 HTTP 头部</p>
<p>Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<p>Connection：close</p>
<p><strong>一、MAC帧头定义</strong></p>
<p>/<em>数据帧定义，头14个字节，尾4个字节</em>/<br>typedef struct _MAC_FRAME_HEADER<br>{<br> char m_cDstMacAddress[6];    //目的mac地址<br> char m_cSrcMacAddress[6];    //源mac地址<br> short m_cType;       　　　　　//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp<br>}<strong>attribute</strong>((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER;</p>
<p>typedef struct _MAC_FRAME_TAIL<br>{<br> unsigned int m_sCheckSum;    //数据帧尾校验和<br>}<strong>attribute</strong>((packed))MAC_FRAME_TAIL, *PMAC_FRAME_TAIL;</p>
<p><strong>二、IP头结构的定义</strong></p>
<p>/<em>IP头定义，共20个字节</em>/<br>typedef struct _IP_HEADER<br>{<br> char m_cVersionAndHeaderLen;     　　//版本信息(前4位)，头长度(后4位)<br> char m_cTypeOfService;      　　　　　 // 服务类型8位<br> short m_sTotalLenOfPacket;    　　　　//数据包长度<br> short m_sPacketID;      　　　　　　　 //数据包标识<br> short m_sSliceinfo;      　　　　　　　  //分片使用<br> char m_cTTL;        　　　　　　　　　　//存活时间<br> char m_cTypeOfProtocol;    　　　　　 //协议类型<br> short m_sCheckSum;      　　　　　　 //校验和<br> unsigned int m_uiSourIp;     　　　　　//源ip<br> unsigned int m_uiDestIp;     　　　　　//目的ip<br>} <strong>attribute</strong>((packed))IP_HEADER, *PIP_HEADER ;</p>
<p><strong>三、tcp头结构定义</strong></p>
<p><img src="http://my.csdn.net/uploads/201205/25/1337910956_9817.jpg" alt="img"></p>
<p> <img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/1337910956_9817.jpg" alt="1337910956_9817"></p>
<p>/<em>TCP头定义，共20个字节</em>/<br>typedef struct _TCP_HEADER<br>{<br> short m_sSourPort;        　　　　　　// 源端口号16bit<br> short m_sDestPort;       　　　　　　 // 目的端口号16bit<br> unsigned int m_uiSequNum;       　　// 序列号32bit<br> unsigned int m_uiAcknowledgeNum;  // 确认号32bit<br> short m_sHeaderLenAndFlag;      　　// 前4位：TCP头长度；中6位：保留；后6位：标志位<br> short m_sWindowSize;       　　　　　// 窗口大小16bit<br> short m_sCheckSum;        　　　　　 // 检验和16bit<br> short m_surgentPointer;      　　　　 // 紧急数据偏移量16bit<br>}<strong>attribute</strong>((packed))TCP_HEADER, *PTCP_HEADER;</p>
<p>/*TCP头中的选项定义</p>
<p>kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话)</p>
<p>KIND = 1表示 无操作NOP，无后面的部分</p>
<p>  2表示 maximum segment   后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度）</p>
<p>  3表示 windows scale     后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度）</p>
<p>  4表示 SACK permitted    LENGTH为2，没有内容部分</p>
<p>  5表示这是一个SACK包     LENGTH为2，没有内容部分</p>
<p>  8表示时间戳，LENGTH为10，含8个字节的时间戳<br>*/</p>
<p>typedef struct _TCP_OPTIONS<br>{<br> char m_ckind;<br> char m_cLength;<br> char m_cContext[32];<br>}<strong>attribute</strong>((packed))TCP_OPTIONS, *PTCP_OPTIONS;</p>
<p><strong>四、UDP头结构的定义</strong></p>
<p><img src="http://my.csdn.net/uploads/201205/25/1337910963_6079.jpg" alt="img"></p>
<p>/<em>UDP头定义，共8个字节</em>/</p>
<p>typedef struct _UDP_HEADER<br>{<br> unsigned short m_usSourPort;    　　　// 源端口号16bit<br> unsigned short m_usDestPort;    　　　// 目的端口号16bit<br> unsigned short m_usLength;    　　　　// 数据包长度16bit<br> unsigned short m_usCheckSum;    　　// 校验和16bit<br>}<strong>attribute</strong>((packed))UDP_HEADER, *PUDP_HEADER;</p>
<p>====</p>
<p><a href="http://www.cnblogs.com/li-hao/archive/2011/12/07/2279912.html" target="_blank" rel="external">http://www.cnblogs.com/li-hao/archive/2011/12/07/2279912.html</a></p>
<p>-———————————————————————————————————————————— </p>
<h3 id="tcp、ip、udp头部格式"><a href="#tcp、ip、udp头部格式" class="headerlink" title="tcp、ip、udp头部格式"></a>tcp、ip、udp头部格式</h3><p>2.2　TCP/IP报文格式</p>
<p>　　</p>
<p>　　1、IP报文格式</p>
<p>　　</p>
<p>　　IP<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>是TCP/IP<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>族中最为核心的<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。在局域网环境，IP协议往往被封装在以太网帧（见本章1.3节）中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如图2-3所示：</p>
<p>　　 　</p>
<p>　　 图2-3　 TCP/IP报文封装</p>
<p>　　<img src="http://my.csdn.net/uploads/201205/25/1337910967_8133.jpg" alt="img"></p>
<p>　　图2-4是IP头部（报头）格式：（RFC 791）。</p>
<p>　　 <img src="http://my.csdn.net/uploads/201205/25/1337910978_9542.jpg" alt="img">　</p>
<p>　　 图2-4　 IP头部格式</p>
<p>　　</p>
<p>　　其中：</p>
<p>　　</p>
<p>　　●版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</p>
<p>　　</p>
<p>　　●报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。</p>
<p>　　</p>
<p>　　●服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态<a href="http://cisco.chinaitlab.com/List_6.html" target="_blank" rel="external">路由</a>协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p>
<p>　　</p>
<p>　　●总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</p>
<p>　　</p>
<p>　　●标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</p>
<p>　　</p>
<p>　　●标志位字段：占3比特。标志一份数据报是否要求分段。</p>
<p>　　</p>
<p>　　●段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</p>
<p>　　</p>
<p>　　●生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</p>
<p>　　</p>
<p>　　●协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</p>
<p>　　</p>
<p>　　●头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</p>
<p>　　</p>
<p>　　●源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</p>
<p>　　</p>
<p>　　可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p>
<p>　　</p>
<p>　　2、TCP数据段格式</p>
<p>　　</p>
<p>　　TCP是一种可靠的、面向连接的字节流服务。源主机在传送数据前需要先和目标主机建立连接。然后，在此连接上，被编号的数据段按序收发。同时，要求对每个数据段进行确认，保证了可靠性。如果在指定的时间内没有收到目标主机对所发数据段的确认，源主机将再次发送该数据段。</p>
<p>　　</p>
<p>　　如图2-5所示，是TCP头部结构（RFC 793、1323）。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337910993_8515.jpg" alt="img"></p>
<p>　　 图2-5　 TCP头部结构</p>
<p>　　</p>
<p>　　●源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>动态地为客户端的应用程序分配端口号。在<a href="http://server.chinaitlab.com/" target="_blank" rel="external">服务器</a>端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</p>
<p>　　</p>
<p>　　●顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。</p>
<p>　　</p>
<p>　　●确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。</p>
<p>　　</p>
<p>　　●头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p>
<p>　　</p>
<p>　　●标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p>
<p>　　</p>
<p>　　◆URG：紧急指针（urgent pointer）有效。</p>
<p>　　</p>
<p>　　◆ACK：确认序号有效。</p>
<p>　　</p>
<p>　　◆PSH：接收方应该尽快将这个报文段交给应用层。</p>
<p>　　</p>
<p>　　◆RST：重建连接。</p>
<p>　　</p>
<p>　　◆SYN：发起一个连接。</p>
<p>　　</p>
<p>　　◆FIN：释放一个连接。</p>
<p>　　</p>
<p>　　●窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</p>
<p>　　</p>
<p>　　●TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p>
<p>　　</p>
<p>　　●紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p>
<p>　　</p>
<p>　　●选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
<p>　　</p>
<p>　　3、UDP数据段格式</p>
<p>　　</p>
<p>　　UDP是一种不可靠的、无连接的数据报服务。源主机在传送数据前不需要和目标主机建立连接。数据被冠以源、目标端口号等UDP报头字段后直接发往目的主机。这时，每个数据段的可靠性依靠上层协议来保证。在传送数据较少、较小的情况下，UDP比TCP更加高效。</p>
<p>　　</p>
<p>　　如图2-6所示，是UDP头部结构（RFC 793、1323）：</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911478_8471.jpg" alt="img"></p>
<p>　　 图2-6　 UDP数据段格式</p>
<p>　　</p>
<p>　　●源、目标端口号字段：占16比特。作用与TCP数据段中的端口号字段相同，用来标识源端和目标端的应用进程。</p>
<p>　　</p>
<p>　　●长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。</p>
<p>　　</p>
<p>　　●校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。</p>
<p>　　</p>
<p>　　2.3　套接字</p>
<p>　　</p>
<p>　　在每个TCP、UDP数据段中都包含源端口和目标端口字段。有时，我们把一个IP地址和一个端口号合称为一个套接字（Socket），而一个套接字对（Socket pair）可以唯一地确定互连网络中每个TCP连接的双方（客户IP地址、客户端口号、<a href="http://server.chinaitlab.com/" target="_blank" rel="external">服务器</a>IP地址、服务器端口号）。</p>
<p>　　</p>
<p>　　如图2-7所示，是常见的一些协议和它们对应的服务端口号。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911485_7934.jpg" alt="img"></p>
<p>　　 图2-7　 常见协议和对应的端口号</p>
<p>　　</p>
<p>　　需要注意的是，不同的应用层协议可能基于不同的传输层协议，如FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。</p>
<p>　　</p>
<p>　　同时，有些应用层协议占用了两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。</p>
<p>　　</p>
<p>　　还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供域名解析服务，在TCP的53端口提供DNS区域文件传输服务。</p>
<p>　　</p>
<p>　　2.4　TCP连接建立、释放时的握手过程</p>
<p>　　</p>
<p>　　1、TCP建立连接的三次握手过程</p>
<p>　　</p>
<p>　　TCP会话通过三次握手来初始化。三次握手的目标是使数据段的发送和接收同步。同时也向其他主机表明其一次可接收的数据量（窗口大小），并建立逻辑连接。这三次握手的过程可以简述如下：</p>
<p>　　</p>
<p>　　●源主机发送一个同步标志位（SYN）置1的TCP数据段。此段中同时标明初始序号（Initial Sequence Number，ISN）。ISN是一个随时间变化的随机值。</p>
<p>　　</p>
<p>　　●目标主机发回确认数据段，此段中的同步标志位（SYN）同样被置1，且确认标志位（ACK）也置1，同时在确认序号字段表明目标主机期待收到源主机下一个数据段的序号（即表明前一个数据段已收到并且没有错误）。此外，此段中还包含目标主机的段初始序号。</p>
<p>　　</p>
<p>　　●源主机再回送一个数据段，同样带有递增的发送序号和确认序号。</p>
<p>　　</p>
<p>　　至此为止，TCP会话的三次握手完成。接下来，源主机和目标主机可以互相收发数据。整个过程可用图2-8表示。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911008_5159.jpg" alt="img"></p>
<p>　　 图2-8　 TCP建立连接的三次握手过程</p>
<p>　　</p>
<p>　　2、TCP释放连接的四次握手过程</p>
<p>　　</p>
<p>　　TCP连接的释放需要进行四次握手，步骤是：</p>
<p>　　</p>
<p>　　●源主机发送一个释放连接标志位（FIN）为1的数据段发出结束会话请求</p>
<p><strong>常见的批处理作业调度算法</strong></p>
<p>1.<strong>先来先服务调度算法（FCFS）</strong>:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p>
<p>2.<strong>短作业优先调度算法**</strong>(SPF):** 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。 </p>
<p>3.<strong>最高响应比优先算法(HRN)：</strong>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。</p>
<ol>
<li><strong>基于优先数调度算法(HPF)：</strong>每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。</li>
</ol>
<p>5.<strong>均衡调度算法，即**</strong>多级队列调度算法**</p>
<p>基本概念：</p>
<p>   作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)</p>
<p>   作业平均周转时间(T)＝周转时间/作业个数</p>
<p>   作业带权周转时间（Wi）＝周转时间/运行时间</p>
<p>   响应比＝（等待时间＋运行时间）/运行时间</p>
<p><strong>二、进程调度算法</strong></p>
<p>1.<strong>先进先出算法(FIFO)：</strong>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。</p>
<ol>
<li><strong>时间片轮转算法(RR)：</strong>分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。</li>
</ol>
<p>3.<strong> 最高优先级算法(HPF)：</strong>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。</p>
<ol>
<li><strong>多级队列反馈法：</strong>几种调度算法的结合形式多级队列方式。</li>
</ol>
<p><strong>三、空闲分区分配算法</strong></p>
<p><strong>1. 首先适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。</p>
<ol>
<li><p><strong>最佳适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。</p>
</li>
<li><p><strong>最坏适应算法：</strong>当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p>
</li>
</ol>
<p><strong>四、虚拟页式存储管理中的页面置换算法</strong></p>
<p>1.<strong>理想页面置换算法(OPT)：</strong>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</p>
<p>2.<strong>先进先出页面置换算法(FIFO)：</strong>选择最先进入内存的页面予以淘汰。</p>
<ol>
<li><strong>最近最久未使用算法（LRU）：</strong>选择在最近一段时间内最久没有使用过的页，把它淘汰。</li>
</ol>
<p><strong>4.最少使用算法（LFU）：</strong>选择到当前时间为止被访问次数最少的页转换。</p>
<p>五、<strong>磁盘调度</strong></p>
<p><strong>1.先来先服务（FCFS）：</strong>是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置</p>
<p><strong>2.最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，</strong>即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</p>
<p><strong>3.扫描算法（SCAN）或电梯调度算法：</strong>总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<p><strong>4.循环扫描算法（CSCAN）：</strong>循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求</p>
<p>首先，你需要明白的一点是：数据库的物理结构是由数据库的操作系统文件所决定，每一个Oracle数据库是由三种类型的文件组成：数据文件、日志文件和控制文件。数据库的文件为数据库信息提供真正的物理存储。<br>​    每一个Oracle数据库有一个或多个物理的数据文件（data file）。一个数据库的数据文件包含全部数据库数据。逻辑数据库结构（如表、索引等）的数据物理地存储在数据库的数据文件中。数据文件通常为*.dbf格式，例如：userCIMS.dbf。数据文件有下列特征：①、一个数据文件仅与一个数据库联系；②、一旦建立，数据文件只增不减；③、一个表空间（数据库存储的逻辑单位）由一个或多个数据文件组成。<br>​    其次，我们再来叙述一下Oracle的逻辑结构：Oracle的逻辑结构包括表空间（tablespace），段（segment），数据块（data block）以及模式对象（schema object）。<br>​    Oracle数据库在逻辑上是由多个表空间组成的，表空间在物理上包含一个或多个数据文件。而数据文件大小是块大小的整数倍；表空间中存储的对象叫段，比如数据段，索引段和回退段。段由区组成，区是磁盘分配的最小单位。段的增大是通过增加区的个数来实现的。每个区的大小是数据块大小的整数倍，区的大小可以不相同；数据块是数据库中的最小的I/O单位，同时也是内存数据缓冲区的单位，及数据文件存储空间单位。块的大小由参数DB_BLOCK_SIZE设置，其值应设置为操作系统块大小的整数倍。<br>   ⑴、表空间（tablespace）<br>   表空间是数据库中最大的逻辑单位，每一个表空间由一个或多个数据文件组成，一个数据文件只能与一个表空间相联系。每一个数据库都有一个SYSTEM表空间，该表空间是在数据库创建或数据库安装时自动创建的，用于存储系统的数据字典表，程序系统单元，过程函数，包和触发器等，也可用于存储用户数据表，索引对象。表空间具有在线（online）和离线（offline）属性，可以将除SYSTME以外的其他任何表空间置为离线。<br>   ⑵、段（segment）<br>   数据库的段可以分为四类：数据段、索引段、回退段和临时段。<br>   ⑶、区<br>   区是磁盘空间分配的最小单位。磁盘按区划分，每次至少分配一个区。区存储与段中，它由连续的数据块组成。<br>   ⑷、数据块<br>   数据块是数据库中最小的数据组织单位与管理单位，是数据文件磁盘存储空间单位，也是数据库I/O的最小单位，数据块大小由DB_BLOCK_SIZE参数决定，不同的Oracle版本DB_BLOCK_SIZE的默认值是不同的。<br>   ⑸、模式对象<br>   模式对象是一种应用，包括：表、聚簇、视图、索引序列生成器、同义词、哈希、程序单元、数据库链等。<br>   最后，在来说一下Oracle的用户、表空间和数据文件的关系：<br>   一个用户可以使用一个或多个表空间，一个表空间也可以供多个用户使用。用户和表空间没有隶属关系，表空间是一个用来管理数据存储的逻辑概念，表空间只是和数据文件发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。<br>   总结一下：解释数据库、表空间、数据文件、表、数据的最好办法就是想象一个装满东西的柜子。数据库其实就是柜子，柜中的抽屉是表空间，抽屉中的文件夹是数据文件，文件夹中的纸是表，写在纸上的信息就是数据。</p>
<p>TCP 三次握手<br>TCP 连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。以下步骤概述了通常情况下客户端计算机联系服务器计算机的过程：<br>\1. 客户端向服务器发送一个SYN置位的TCP报文，其中包含连接的初始序列号x和一个窗口大小（表示客户端上用来存储从服务器发送来的传入段的缓冲区的大小）。<br>\2. 服务器收到客户端发送过来的SYN报文后，向客户端发送一个SYN和ACK都置位的TCP报文，其中包含它选择的初始序列号y、对客户端的序列号的确认x+1和一个窗口大小（表示服务器上用来存储从客户端发送来的传入段的缓冲区的大小）。<br>\3. .客户端接收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号y+1和序号x+1的ACK报文，一个标准的TCP连接完成。<br>TCP 使用类似的握手过程来结束连接。这可确保两个主机均能完成传输并确保所有的数据均得以接收<br>TCP Client<br>Flags<br>TCP Server<br>1 Send SYN (seq=x)<br>—-SYN—&gt;<br>SYN Received<br>2 SYN/ACK Received<br>&lt;—SYN/ACK—-<br>Send SYN (seq=y)， ACK (x+1)<br>3 Send ACK (y+1)<br>—-ACK—&gt;<br>ACK Received， <a href="http://www.yesky.com/key/1551/261551.html" target="_blank" rel="external">Connection</a> Established<br>w: ISN (Initial Sequence Number) of <a href="http://www.yesky.com/key/3226/13226.html" target="_blank" rel="external">the</a> Client<br>x: ISN of the Server</p>
<p><strong>1. TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。</strong></p>
<p>如果采用两次的话，会出现下面这种情况。<br>比如是A机要连到B机，结果发送的连接信息由于某种原因没有到达B机；<br>于是，A机又发了一次，结果这次B收到了，于是就发信息回来，两机就连接。<br>传完东西后，断开。<br>结果这时候，原先没有到达的连接信息突然又传到了B机，于是B机发信息给A，然后B机就以为和A连上了，这个时候B机就在等待A传东西过去。</p>
<p><strong>2. 三次握手改成仅需要两次握手，死锁是可能发生</strong></p>
<p>考虑计算机A和B之间的通信，假定B给A发送一个连接请求分组，A收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A认为连接已经成功地建立了，可以开始发送数据分组。可是，B在A的应答分组在传输中被丢失的情况下，将不知道A是否已准备好，不知道A建议什么样的序列号，B甚至怀疑A是否收到自己的连接请求分组。在这种情况下，B认为连接还未建立成功，将忽略A发来的任何数据分组，只等待连接确认应答分组。而A在发出的分组超时后，重复发送同样的分组。这样就形成了死锁</p>
<p>在<a href="http://wenwen.soso.com/z/Search.e?sp=S%E5%8D%8F%E8%AE%AE%E6%A0%88&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">协议栈</a>中，传输层位于网络层之上，传输层协议为不同<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%B8%BB%E6%9C%BA&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">主机</a>上运行的进程提供<a href="http://wenwen.soso.com/z/Search.e?sp=S%E9%80%BB%E8%BE%91&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">逻辑</a>通信，而<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">网络层协议</a>为不同主机提供逻辑通信。这个区别很微妙，但是却非常重要。让我们用一家人作为<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%B1%BB%E6%AF%94&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">类比</a>来说明一下这个区别。</p>
<p>　　设想一下有两所房子，一个位于<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%B8%9C%E6%B5%B7%E5%B2%B8&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">东海岸</a>而另一个位于<a href="http://wenwen.soso.com/z/Search.e?sp=S%E8%A5%BF%E6%B5%B7%E5%B2%B8&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">西海岸</a>，每所房子里都住着12个小孩。东海岸的房子里的小孩和西海岸房子里的小孩是堂兄妹。两所房子里的孩子喜欢互相通信——每个孩子每周都给每一个堂兄妹写一封信，每一封信都由老式的<a href="http://wenwen.soso.com/z/Search.e?sp=S%E9%82%AE%E5%B1%80&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">邮局</a>分别用<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%BF%A1%E5%B0%81&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">信封</a>来寄。这样，每一家每周就都有144封信要送到另一家(这些孩子如果可以用<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">电子邮件</a>的话就可以省掉很多钱了!)在每一家里面.都由一个孩子——西海岸的房子里的Ann和东海岸房子里的BilI——负责邮件的收集和分发。每周Ann都从她的<a href="http://wenwen.soso.com/z/Search.e?sp=S%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">兄弟姐妹</a>那里收集起来信件，并将这些信件送到每天都来的邮递服务员那里。当信件到达西海岸的房子，Ann又将这些信件分发给她的兄弟姐妹。BilI在东海岸有着同样的工作。</p>
<p>　　在这个例于中，邮递服务提供着两所房子之间的逻辑通信——邮递服务在两所房子之间传递邮件，而不是针对每个人的服务。另一方面，Ann和BilI提供堂兄妹之间的逻辑通信——Ann和BilI从他们的兄弟姐妹那里收集邮件并将邮件递送给他们。注意，从这些堂兄妹的角度看，Ann和BilI是邮件的服务人，尽管他们俩只是端到端寄送服务的一部分(终端系统部分)。这个例子是传输层和网络层之间的关系的一个形象比喻:</p>
<p>　　主机(也称为终端系统)=房子<br>　　进程=堂兄妹<br>　　应用程序消息=信封里的信<br>　　网络层协议=邮递服务(包括邮递员)<br>　　传输层协议=Ann和Bill</p>
<p>现在常用的开源数据连接池主要有c3p0、dbcp和proxool三种，其中：<br>hibernate开发组推荐使用c3p0;<br>spring开发组推荐使用dbcp(dbcp连接池有weblogic连接池同样的问题，就是强行关闭连接或数据库重启后，无法reconnect，告诉连接被重置，这个设置可以解决);<br>hibernate in action推荐使用c3p0和proxool;</p>
<p>dbcp所需jar：commons-dbcp.jar、commons-pool.jar<br>c3p0所需jar：c3p0-0.9.2.1.jar mchange-commons-java-0.2.3.4.jar</p>
<p>proxool暂时没有接触到</p>
<p>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。<br>dbcp简介：<br>DBCP(DataBase connection pool),数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。<br>c3p0与dbcp区别：<br>dbcp没有自动的去回收空闲连接的功能  c3p0有自动回收空闲连接功能<br>两者主要是对数据连接的处理方式不同！C3P0提供最大空闲时间，DBCP提供最大连接数。<br>前者当连接超过最大空闲连接时间时，当前连接就会被断掉。DBCP当连接数超过最大连接数时，所有连接都会被断开。</p>
<p>今天早上发现网站访问时，突然访问不了了，提示数据库连接不上了，报出了：<br>Warning: mysql_connect() [function.mysql-connect]: Too many connections in ../common/common.database.class.php on line 541<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>的错误。用远程查看服务器，mysql进程已经占了CPU的99%了，mysql的也登陆不进去了。当时马上判断是数据库连接数过多了，最快的办法就是重启服务器，所以我立刻做了：<br>1、通知托管商重启服务器（马上联系了托管，说了又得抱怨了，起个服务器他们既然拖了半个多小时）；<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>2、马上修改代码，屏蔽掉错误提示，因为这个错误提示已经把我们网站的代码路径显示出来了。<br>重启服务器后网站恢复了正常，后来我查找原因，用mysqldumpslow -s c -t 20 mysql-slow.log查慢查询，找慢查询的语句，这时才发现我们网站的mysql慢查询日志没有开启，所以我没法通过日志知道到底是哪些sql查询比较耗资源和耗时间；如下：<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>[root@localhost bin]# ./mysqldumpslow -s c -t 20 mysql-slow.log<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>Reading mysql slow query log from mysql-slow.logCan’t open mysql-slow.log: No such file or directory at ./mysqldumpslow line 73.Died at ./mysqldumpslow line 143.<br>对于这次问题，我的分析是：<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>1、9点到11点之间是一天内我们网站受访的一个高峰，这个高峰本来数据库操作就比较多，再加上今天这个时刻我再后台添加和修改新闻，这么多数据操作中任何一个低效率的sql语句都有可能导致数据库操作的死锁；<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>2、当同事们都听说网站访问不了的时候，都在不断地刷新主页，这就更加加重了数据库的负载，这个时候CPU的mysql进程达到了99%，有个时间降到了80%，但大家还都在不断的刷新主页，负载又升到了99%；<br><a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a>3、代码里的sql查询语句可能有一些是低效率的；<br>4、 服务器上目前放在几个网站，其中主站、sns的数据库操作比较频繁，当数据库操作频繁时，都有可能造成一些sql查询死锁，当死锁量一多起来后，服务器的 压力将非常大。 </p>
<p>解决办法：<br>1、如何优化数据库访问是任何一个拥有相对比较多的数据库操作的网站所要面临 的问题，这是我们网站第一次碰到这个问题，所以还有待观察和分忻；<br>2、检查代码里的sql语句，优化低效率的sql查询（目前我只 能检查主站的，sns网站上的由于时间和精力无法一一检查）<br>3、开启mysql慢查询日志，这个需要何老师来做，在mysql的配置文件my.cnf里添加<br>log-slow-queries=/var/lib/mysql/slowquery.loglong_query_time=2<br>第一行是慢查询日志的存放路径，第二行是查询超过2秒才记录<br>4、如果以后还继续发生这类事件，咱们可以减少apache的连接数和mysql的连接数，目前咱们的网站不算大，apache和mysql的连接数分别是150和100，连接数都不算多，如果以后还继续发生这类事件就需要调的更少。</p>
<p><strong>概念介绍</strong></p>
<p>​     通俗来讲，会话(Session) 是通信双方从开始通信到通信结束期间的一个上下文（Context）。这个上下文是一段位于服务器端的内存：记录了本次连接的客户端机器、通过哪个应用程序、哪个用户登录等信息.</p>
<p>​     连接（Connection）：连接是从客户端到<a href="http://lib.csdn.net/base/oracle" target="_blank" rel="external">Oracle</a>实例的一条物理路径。连接可以在网络上建立，或者在本机通过IPC机制建立。通常会在客户端进程与一个专用服务器或一个调度器之间建立连接。</p>
<p>​     <strong>会话(Session) 是和连接(Connection)是同时建立的，两者是对同一件事情不同层次的描述。简单讲，连接(Connection)是物理上的客户端同服务器的通信链路，会话(Session)是逻辑上的用户同服务器的通信交互。</strong></p>
<p>​     ORACLE中一个用户登录ORACLE服务器的前提，就是该用户具有ORACLE的 “CREATE SESSION”权限。ORACE允许同一个用户在同一个客户机上建立多个同服务器的会话，每个SESSION都代表了用户与服务器的一个交互。就像你用IE浏览器打开博客园网站，然后你再打开一个IE窗口，又打开一个博客园网站。两个IE窗口就相当于两个SESSION， 而物理链路就相当于连接（Connection）。后台进程PMON会每隔一段时间，就会检测用户连接状况，如果连接已断开，PMON会清理现场，释放相关的资源。</p>
<p>​     在一条连接而无相应的会话。另外，一个会话可以有连接也可以没有连接。使用高级Oracle Net特性（如连接池）时，客户可以删除一条物理连接，而会话依然保留（但是会话会空闲）。客户在这个会话上执行某个操作时，它会重新建立物理连接。</p>
<p>​    在专用服务器中，一个会话对应一个服务器进程（Process),如果<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>运行在共享服务器方式，一个服务器进程可以为多个会话服务。</p>
<p>​       <strong>下面用通俗易懂的方式来解释连接和会话。</strong></p>
<p>   有A/B两个城市，需要从A运送白菜到B城<br>   我们先建设一条公路<br>   然后运送白菜过去，包括准备白菜和运送白菜以及返回等一系列的动作。<br>   一条公路，可以运送0-n次的白菜<br>   当然从A到B的公路也可能不只一条。<br>   某一次运送白菜，可以在真正上路时才开通某一条道路<br>   一次运送不会影响别的运送的状态<br>   对应数据库<br>   A代表客户端进程<br>   B代表服务器端进程<br>   公路代表连接，<br>   运送一次白菜代表一个会话<br>   一个连接可以进行多次的会话<br>   一个会话可以不依赖于某个连接，甚至没有连接(当我准备好了，真正开始运送时再建立连接)<br>   一个会话不会影响别的会话</p>
<p><strong>会话&amp;链接</strong></p>
<hr>
<p>在具体的应用场景中连接(connction) 和 会话(session) 有很多情况：</p>
<p>\1. SQL*PLUS 登录 ORACLE</p>
<p>这种场景比较容易理解，一个连接对应一个Session。</p>
<p>\2. PL/SQL Developer工具登录ORACLE</p>
<p>PL/SQL Developer工具——&gt;首选项——&gt;连接下，你可以设置会话方式，如下图所示：</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029403907308.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024418595945.png" alt="clip_image001"></a></p>
<p>如果设置选项选择多路会话，：PL/SQL Developer 登录ORACLE，每打开一个窗口，将创建一个新的会话，而设置选项选择单路会话，则新打开的窗口会共用一个会话。具体你可以参考PLSQL Developer8.0用户指南：</p>
<p>多路会话：每个<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>窗口、SQL窗口和命令窗口都将有它自己的会话，另外的一个会话将被用于编译。这是最灵活的设置，明显地会导致最大数量的数据库会话。另外可能的缺点是，在更新被提交之后，它们只在X窗口中可以看到，而在Y窗口看不到。</p>
<p>双路会话：测试窗口、SQL窗口和命令窗口将共享一个会话，另外一个会话将被用于编译。这个模式的缺点是每次只有一个窗口可以运行程序。</p>
<p>单路会话：所有的窗口和所有的编译都使用同一个会话，这使事务管理变得很困难。在这个模式中调试器被禁用使用。如果你被限制只能使用一个数据库会话，那么你只能使用这个设置了。</p>
<hr>
<p><strong>会话&amp;进程</strong></p>
<hr>
<hr>
<p>在Oracle中如何查看参数sessiones或processes的值呢？一般使用show parameter命令查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter processes;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE                             VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ -------------------------------- ---------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aq_tm_processes                      integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db_writer_processes                  integer                          1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcs_server_processes                 integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">job_queue_processes                  integer                          10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log_archive_max_processes            integer                          2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processes                            integer                          850</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter session;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE                             VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ -------------------------------- -----------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_max_sessionspace_size           integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_soft_sessionspace_limit         integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_max_sessions                 integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_sessions_warning             integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logmnr_max_persistent_sessions       integer                          1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_cached_cursors               integer                          20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_max_open_files               integer                          10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                             integer                          940</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_server_sessions               integer</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt;</div></pre></td></tr></table></figure>
<p>方法2：查询v$parameter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select name, type, value ,display_value, isses_modifiable, issys_modifiable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$parameter</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where name=&apos;sessions&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select name, type, value ,display_value, isses_modifiable, issys_modifiable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$parameter</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where name=&apos;processes&apos;;</div></pre></td></tr></table></figure>
<p>方法3：查询v$resiyrce_limit;</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029412658407.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024432651715.png" alt="clip_image002"></a></p>
<hr>
<p>Oracle的sessions和processes的数量关系是：</p>
<p><strong>Oracle 11g R1以及之前版本</strong></p>
<p>​             sessions=(1.1 * processes) + 5</p>
<p><strong>Oracle 11g R2</strong></p>
<p>​             sessions=(1.5 * processes) + 22</p>
<p>如下例子所示，在Oracle 10g 版本中，processes与sessions的关系如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; select * from v$version;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BANNER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">----------------------------------------------------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Oracle Database 10g Release 10.2.0.4.0 - 64bit Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PL/SQL Release 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CORE    10.2.0.4.0      Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TNS for Linux: Version 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NLSRTL Version 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<p>SELECT (1.1 *850)+ 5 FROM DUAL; 其值刚好为940</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029423439977.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024451258114.png" alt="clip_image003"></a></p>
<p>一般修改参数processes后，sessions参数也会随之变化，但是有一个奇怪的现象时，如下所示，我将processes从</p>
<p>850改为120后，重启数据库实例，发现sessions的值并没有随之变化。这个现象一般发生在改小processes参数。为什么这样呢？</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029435628505.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024471405297.png" alt="clip_image004"></a></p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029449535748.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024492181696.png" alt="clip_image005"></a></p>
<p>共享服务器模式，一个会话可能由多个服务进程轮流为之服务，一个进程可能为多个会话服务。简单地说，进程和会话之间有一种多对多的关系。</p>
<hr>
<p><strong>会话管理</strong></p>
<p>1：查看当前所有用户的会话(SESSION)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME IS NOT NULL</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME , SID;</div></pre></td></tr></table></figure>
<p>其中Oracle内部进程的USERNAME为空</p>
<p>2：查看当前用户的所有SESSION：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME = USER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME, SID;</div></pre></td></tr></table></figure>
<p>3：查看当前窗口/当前用户的会话信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT SID, SERIAL#, STATUS FROM V$SESSION WHERE AUDSID=USERENV(&apos;SESSIONID&apos;);</div></pre></td></tr></table></figure>
<p>4：查看所有ACTIVE会话(活动会话)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME IS NOT NULL AND STATUS=&apos;ACTIVE&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME, SID;</div></pre></td></tr></table></figure>
<p>5：查看当前会话的ID可以通过如下脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$MYSTAT WHERE ROWNUM =1</div></pre></td></tr></table></figure>
<p>查看当前用户的SPID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT P.SPID, S.SID, S.SERIAL#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$PROCESS P</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INNER JOIN V$SESSION S ON P.ADDR = S.PADDR</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE S.AUDSID=USERENV(&apos;SESSIONID&apos;);</div></pre></td></tr></table></figure>
<p>6：查看数据库允许最大会话数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SHOW PARAMETER SESSIONS;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE        VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ ----------- ------------------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_max_sessionspace_size           integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_soft_sessionspace_limit         integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_max_sessions                 integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_sessions_warning             integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logmnr_max_persistent_sessions       integer     1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                             integer     225</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_server_sessions               integer</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SELECT NAME, TYPE, VALUE FROM V$PARAMETER WHERE NAME LIKE &apos;session%&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                       TYPE                 VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">---------                 ----------             -----------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                          3                225</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_cached_cursors            3                20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_max_open_files            3                10</div></pre></td></tr></table></figure>
<p>7：查看曾经的最大会话数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SELECT SESSIONS_MAX,SESSIONS_WARNING,SESSIONS_CURRENT,SESSIONS_HIGHWATER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2  FROM v$license;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SESSIONS_MAX SESSIONS_WARNING SESSIONS_CURRENT SESSIONS_HIGHWATER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------ ---------------- ---------------- ------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0                0              512                553</div></pre></td></tr></table></figure>
<p>SESSIONS_HIGHWATER表示曾经的最大会话数512</p>
<p>8：查询那些应用的连接数此时是多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT  B.PROGRAM , COUNT(1)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$PROCESS A, V$SESSION B</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE A.ADDR = B.PADDR</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND  B.USERNAME IS NOT NULL</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GROUP BY B.PROGRAM;</div></pre></td></tr></table></figure>
<hr>
<p><strong>会话状态：</strong></p>
<p>会话有ACTIVE、INACTIVE、KILLED、CACHED、SNIPED五个状态，一般比较常见的有ACTIVE、INACTIVE、KILLED三个状态。</p>
<p>ACTIVE   ：处于此状态的会话，表示正在执行，处于活动状态。</p>
<p>INACTIVE ：处于此状态的会话表示不是正在执行的</p>
<p>KILLED   ：处于此状态的会话，表示出现了错误或进程被杀掉，正在回滚，当然，这个状态的会话也占用系统资源的。还有一点就是，    KILLED的状态一般会持续较长时间，如果你想快速杀掉回话，可以参考我以前的一篇文章<a href="http://www.cnblogs.com/kerrycode/p/4034231.html" target="_blank" rel="external">ORACLE快速彻底Kill掉的会话</a></p>
<p>CACHED   ： Session temporarily cached for use by Oracle*XA</p>
<p>SNIPED   ： Session inactive, waiting on the client。 标记为SNIPED的进程被释放有两种条件：</p>
<p>​         1、相关的terminal再一次试图登录及执行sql</p>
<p>​         2、手动的在<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>后台kill掉相应的spid</p>
<p>关于会话信息</p>
<p>通过如下SQL你可以查询你的每个应用程序到底在等待什么，从而针对这些信息对数据库的性能进行调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL USERNAME FOR A12;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL PROGRAM  FOR A32;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL EVENT    FOR A26;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT S.USERNAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,S.PROGRAM</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,S.STATUS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.EVENT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TOTAL_WAITS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TOTAL_TIMEOUTS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TIME_WAITED</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.AVERAGE_WAIT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$SESSION S, V$SESSION_EVENT SE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE S.SID=SE.SID AND SE.EVENT NOT LIKE &apos;SQL*Net%&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND S.STATUS =&apos;ACTIVE&apos; AND S.USERNAME IS NOT NULL;</div></pre></td></tr></table></figure>
<p>2.ORACLE中查询被锁的表并释放session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT A.OWNER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,A.OBJECT_NAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDUSN</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDSLOT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDSQN</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.SESSION_ID</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.ORACLE_USERNAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.OS_USER_NAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.PROCESS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.LOCKED_MODE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.MACHINE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.STATUS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SERVER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SID</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SERIAL#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.PROGRAM</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM ALL_OBJECTS A,V$LOCKED_OBJECT B,SYS.GV_$SESSION C</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE  A.OBJECT_ID = B.OBJECT_ID  AND B.PROCESS = C.PROCESS  ORDER BY 1,2;</div></pre></td></tr></table></figure>
<p>3.查看占用系统IO较大的session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT se.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.serial#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,pr.spid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.username</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.status</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.terminal</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.program</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.module</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.sql_address</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,st.event</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,st.p1text</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,si.physical_reads</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,si.block_changes</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM v$session se,v$session_wait st,v$sess_io si,v$process pr</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE st.sid=se.sid  AND st.sid=si.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND se.paddr=pr.ADDR AND se.sid&gt;6</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND st.wait_time=0 AND st.event NOT LIKE &apos;%SQL%&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY physical_reads DESC;</div></pre></td></tr></table></figure>
<p>4.找出耗cpu较多的session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select a.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,spid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,status</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,substr(a.program,1,40) prog</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,a.terminal</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,osuser</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,value/60/100 value</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$session a,v$process b,v$sesstat c</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where c.statistic#=12 and c.sid=a.sid and a.paddr=b.addr</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">order by value desc</div></pre></td></tr></table></figure>
<hr>
<h1 id="object类的结构"><a href="#object类的结构" class="headerlink" title="object类的结构"></a>object类的结构</h1><p><img src="http://img.blog.csdn.net/20161205181623207" alt="Object类的函数"><br>如图可知，Object类有12个成员方法，按照用途可以分为以下几种<br>1，构造函数<br>2，hashCode和equale函数用来判断对象是否相同,<br>3，wait(),wait(long),wait(long,int),notify(),notifyAll()<br>4，toString()和getClass,<br>5，clone()<br>6，finalize()用于在垃圾回收</p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>clone()函数的用途是用来另存一个当前存在的对象。</p>
<h3 id="hashCode-和equale"><a href="#hashCode-和equale" class="headerlink" title="hashCode()和equale()"></a>hashCode()和equale()</h3><ul>
<li>equale()用于确认两个对象是否相同。</li>
<li>hashCode()用于获取对象的哈希值，这个值的作用是检索，具体的作用可以参考<a href="http://www.cnblogs.com/return/archive/2009/11/06/1597611.html" target="_blank" rel="external">这里</a></li>
<li>哈希值相同的对象不一定equale()</li>
<li>equale()返回true的两个对象一定相同。</li>
</ul>
<h3 id="toString-和getClass"><a href="#toString-和getClass" class="headerlink" title="toString()和getClass()"></a>toString()和getClass()</h3><p>toString()返回一个String对象，用来标识自己<br>getClass()返回一个Class对象，如果打印出来会发现结果是如下格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class package.name.xxx 11</div></pre></td></tr></table></figure>
<p>因为返回的是一个class对象,后面可以跟class类的方法。用的是谁的构造函数，那么getClass返回的就是谁的类型。<br>getClass()经常用于java反射机制</p>
<h3 id="wait-wait-long-wait-long-int-notify-notifyAll"><a href="#wait-wait-long-wait-long-int-notify-notifyAll" class="headerlink" title="wait(),wait(long),wait(long,int),notify(),notifyAll()"></a>wait(),wait(long),wait(long,int),notify(),notifyAll()</h3><ul>
<li>这几个函数体现的是Java的多线程机制</li>
<li>在使用的时候要求在synchronize语句中使用</li>
<li>wait()用于让当前线程失去操作权限，当前线程进入等待序列</li>
<li>notify()用于随机通知一个持有对象的锁的线程获取操作权限</li>
<li>notifyAll()用于通知所有持有对象的锁的线程获取操作权限</li>
<li>wait(long) 和wait(long,int)用于设定下一次获取锁的距离当前释放锁的时间间隔</li>
</ul>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>这个函数在进行垃圾回收的时候会用到，匿名对象回收之前会调用到，具体的例子如图所示</p>
<p><img src="http://img.blog.csdn.net/20161206085522582" alt="finalize函数说明"></p>
<p>Cookie和Session都是为了保持用户的访问状态，一方面为了方便业务实现，另一方面为了简化服务端的程序设计，提高访问性能。Cookie是客户端（也就是浏览器端）的技术，设置了Cookie之后，每次访问服务端，请求中都会带上Cookie；Session是服务端技术，在服务端存储用户的访问信息。</p>
<p>　　使用Cookie传递信息，随着Cookie个数增多和访问量增大，它占用的带宽会越来越大；使用Session保存信息，最大的弱点就是不容易在多台服务器之间共享。</p>
<p><strong>1 Cookie</strong></p>
<p>　　通俗地讲，当用户使用HTTP访问服务器时，服务器会将一些键值对信息返回给客户端浏览器，并且给这些数据加一些限制条件，在符合限制条件情况下用户下次访问服务器时，会带上之前设置的Cookie键值对信息。当该用户输入 URL 时，浏览器便会在本地硬盘上查找与该 URL 关联的 Cookie。如果该 Cookie 存在，浏览器便将该 Cookie 与页请求一起发送到您的站点。</p>
<p>　　Cookie 与网站关联，而不是与特定的页面关联。因此，无论用户请求站点中的哪一个页面，浏览器和服务器都将交换 Cookie 信息。用户访问不同站点时，各个站点都可能会向用户的浏览器发送一个 Cookie；浏览器会分别存储所有 Cookie。</p>
<p><strong>Cookie属性项</strong></p>
<p>　　当前Cookie有2个版本，Version 0 和 Version 1，它们有2种设置响应头标识，分别是”Set-Cookie”和”Set-Cookie2”。</p>
<p>Cookie 0属性值</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910374.png" alt="img"></p>
<p><strong>Cookie 1属性值</strong></p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910375.png" alt="img"></p>
<p>Java中使用Cookie示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</div><div class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</div><div class="line">PrintWriter out = response.getWriter();</div><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">String name = getCoodie(cookies, &quot;name&quot;);</div><div class="line">if (name == null) &#123;</div><div class="line">response.addCookie(new Cookie(&quot;name&quot;, &quot;luoxn28&quot;));</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">System.out.println(name);</div><div class="line">&#125;</div><div class="line">out.println(&quot;hello world&quot;);</div><div class="line">&#125;</div><div class="line">public static String getCoodie(Cookie[] cookies, String key) &#123;</div><div class="line">if (cookies != null) &#123;</div><div class="line">for (Cookie cookie : cookies) &#123;</div><div class="line">if (cookie.getName().equals(key)) &#123;</div><div class="line">return cookie.getValue();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910376.png" alt="img"></p>
<p>使用Cookie的一些注意事项（以Java使用为例）</p>
<p>•所创建的Cookie的name和value不能为非ASSIC字符，如果是中文，可以通过RRLEncoder将其编码，否则会抛出java.lang.IllegalArgumentException异常。</p>
<p>•多出现多个name和value值时，它们实在同一个”Cookie”头中的。</p>
<p>•Cookies的值中可以保存除了“;”以外的标点符号。但是不能保存汉字。保存汉字会出现乱码。</p>
<p><strong>Cookie的一些限制</strong></p>
<p>　　Cookie是HTTP头中的一个字段，HTTP本身对该字段没有限制，但是Cookie最终存储在浏览器中，不同的浏览器对Cookie的存储有一些限制，如下表所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910377.png" alt="img"></p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910378.png" alt="img"></p>
<p>　　如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。</p>
<p><strong>2 Session</strong></p>
<p>　　Session解决了Cookie增多时会增加客户端与服务器的数据传输量问题，同一个客户端与服务器交互时，不需要每次都传回所有的Cookie值，而是只要传回一个ID值，这个ID是客户端第一次访问服务器时生成的，而且每个客户端是唯一的，这个ID通常是name为JSESSIONID的一个Cookie。</p>
<p>　　Session是如何基于Cookie工作的呢，可以是基于URL Path Parameter方式；也可以是基于Cookie，如果没有修改Context容器中的Cookies标识，则默认也是支持的。当浏览器不支持Cookie功能时，浏览器会将用户的SessionCookieName重写到用户请求的URL参数中，它的传递方式如/path/Servlet;name=xxx;name2=xxx2?name3=xxx3。SessionCookieName如果在web.xml中配置session-config配置项，其cookie-config下的name属性就是这个SessionCookieName的值。如果没有配置session-config配置项，默认的SessionCookieNamejiushi “JSESSIONID”。注意，与Session关联的Cookie与其他Cookie并没有什么不同。如果客户端也支持Cookie，则Tomcat仍会解析Cookie中的Session ID，并会覆盖URL中的Session ID。</p>
<p><strong>Session如何工作</strong></p>
<p>　　有了Session ID，服务器就可以创建HttpSession对象了，第一次调用request.getSession()方法，如果没有对应的HttpSession对象，则会创建一个新的，并将这个对象加入到org.apache.catalina.Manager的sessions容器中保存。Manage保存所有的session生命周期，Session过期被回收，服务器关闭，Session被序列化到磁盘。注意，一个客户端对应一个Session对象，这个对象正是保存我们创建的Session值的。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910379.png" alt="img"></p>
<p>　　request.getSession()方法调用的StandardSession永远都会存在，即使与这个客户端关联的Session已经过期。如果过期，则会创建一个新的，但是以前设置的Session值将会丢失。</p>
<p><strong>3 Cookie与Session安全性比较</strong></p>
<p>　　Cookie将保存的数据通过HTTP头部从客户端传到服务端，从服务端再传回到客户端，所有的数据都保存在客户端浏览器中，这些数据都是可以访问到的，甚至可以通过插件添加、修改Cookie，所有Cookie的安全性是比较差的。相比较而言，Session将数据保存在服务器端，安全性高很多，只需要Cookie传回一个Cookie ID就可以，所以Session更适合保存用户隐私和重要的数据。</p>
<p><strong>分布式Session框架</strong></p>
<p>　　在大型互联网应用中，单用Cookie和Session都是不可行的，因为如果使用Cookie可以很好地解决应用的分布式部署问题，大型互联网应用系统一个应用有上百台机器，而且有很多不同的应用系统协同工作，由于Cookie是将数据存储在用户浏览器中，用户每次访问都会讲数据带回到服务器，也就解决了同一个用户的请求在不同服务器上处理而导致的Cookie不一致问题。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/2016092409103710.png" alt="img"></p>
<p>　　由于应用是一个集群，所以不能将Session都保存在每台服务器的内存中，如果每台服务器有几十万访问用户，服务器内存也容不下，即使容得下，也无法保证该Session同步到其他服务器中，所以共享这些Session需要将它们保存在专门的分布式缓存中，可以随时读取和写入，性能要够好满足要求，如memcache/redis或者淘宝的开源分布式框架Tair都是很好的选择。</p>
<p><strong>表单重复提交问题</strong></p>
<p>　　网站中有很多地方有重复提交表单问题，为了防止表单重复提交，就要标识用户的每一次访问请求，使得每一次访问请求对服务端来说都是唯一的，为了标识用户的每次请求，可以在用户请求的表单域增加一个隐藏表单项，其值为唯一的token，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form id=&quot;form&quot; method=&quot;post&quot;&gt;</div><div class="line">...</div><div class="line">&lt;input type=hidden name=&quot;token&quot; value=&quot;xxx&quot;/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>　　用户请求表单时生成唯一的token，并且设置到该用户的Session中，等用户提交时检测这个token是否和Session中保存的token一致，如果一致，说明没有重复提交，同时把Session中的token更新成一个新的token值；否则用户提交上来的token已经不是当前请求的合法token，提交失败。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/2016092409103711.png" alt="img"></p>
<p>以上所述是小编给大家介绍的Java中Cookie和Session的那些事儿，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！</p>
<p>当某个用户发出页面请求时，WEB服务器只是简单的进行响应，然后就关闭与该用户的连接，请求的相关数据将不再存在，这样明显有不好的地方。cookie和session解决了这一问题，客户端(一般是浏览器)与服务器之间的交互，将操作所涉及的数据记录下来，保存在cookie（保存在浏览器客户端）或者session（保存在服务器）中。</p>
<h2 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h2><p>1、什么是cookie</p>
<p>浏览器在访问服务器时，服务器将一些数据以 set-cookie 消息头的形式发送给浏览器。浏览器会将这些数据保存起来。当浏览器再次访问服务器时，会将这些数据以 cookie 消息头的形式发送给服务器。</p>
<p>2、创建 cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Cookie cookie = new Cookie(String name,String value);</div><div class="line">response.addCookie(cookie);1212</div></pre></td></tr></table></figure>
<p>cookie的name不可以重复，和Map集合类似，当有重复的name的时候，会替代。</p>
<p>3、查询cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//如果没有 cookie，则返回 null。</div><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">String name = cookie.getName();</div><div class="line">String value = cookie.getValue();12341234</div></pre></td></tr></table></figure>
<p>4、cookie 保存时的编码问题</p>
<p>cookie 的值叧能是ascii 字符，如果是中文，需要将中文转换成 ascii 字符形式。可以使用 URLEncoder.encode()方法和 URLDecoder.decode()方法来进行这种转换。</p>
<p>5、cookie 的保存时间</p>
<p>cookie.setMaxAge(int seconds);//单位为秒<br> seconds &gt; 0<br>浏览器会将 cookie 以文件的方式保存在硬盘上。在超过指定的时间以后，会删除该文件。<br> seconds &lt; 0<br>默认值，浏览器会将 cookie 保存在内存里面。叧有当浏览器关闭以后，才会删除。<br> seconds = 0<br>立即删除该 Cookie</p>
<p>6、删除 cookie</p>
<p>比如要删除一个 name 为”username”的 cookie。<br>Cookie c = new Cookie(“username”,”“);<br>c.setMaxAge(0);<br>cookie.setPath(request.getContextPath());//路径<br>response.addCookie(c);</p>
<p>7、cookie 的限制</p>
<p> cookie 可以禁止<br> cookie 的大小有限制(4k 左右)<br> cookie 的数量也有限制(浏览器大约能保存 300 个)<br> cookie 的值叧能是字符串，要考虑编码问题。<br> cookie 不安全</p>
<p>8、cookie 的路径问题</p>
<p>浏览器在向服务器上的某个地址发送请求时，会先比较 cookie 的路径不向访问的路径(地址)是否匹配， 叧有匹配的 cookie， 才会发送。<br>cookie 的路径可以通过 cookie.setPath(String path)方法来设置。如果没有设置, 则有一个缺省的路径，缺省的路径是生成该 cookie 的组件的路径。<br>比如: /appname/addCookie 保存了一个 cookie,则该 cookie 的路径就是/appname/addCookie。<br>规则:<br>cookie 的路径必须是要访问的路径的上层目录戒者是不要访问的路径相等， 浏览器才会将 cookie 发送给服务器。一般可以设置 setPath(“/appname”),表示访问该应用下的所有地址，均会发送</p>
<h2 id="二、session"><a href="#二、session" class="headerlink" title="二、session"></a>二、session</h2><p>1、什么是session</p>
<p>浏览器访问服务器时，服务器会创建一个 session 对象(该对象有一个唯一的 id, 一般称为 sessionId)。服务器在缺省情况下，会将 sessionId 以 cookie 机制发送给浏览器。当浏览器再次访问服务器时， 会将sessionId 发送给服务器。 服务器依据 sessionId 就可以找到对应的 session 对象。</p>
<p>2、如何获得 session 对象</p>
<p>HttpSession session = request.getSession();</p>
<p>3、HttpSession 接口提供的一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获得 sessionId。</div><div class="line">String session.getId();</div><div class="line">//绑订数据</div><div class="line">session.setAttribute(String name,Object obj);</div><div class="line">//获取数据</div><div class="line">Object session.getAttribute(String name);</div><div class="line">//删除绑定</div><div class="line">session.removeAttribute(String name);1234567812345678</div></pre></td></tr></table></figure>
<p>4、session保存时间设置</p>
<p>服务器会将超过指定时间的 session 对象删除(在指定的时间内，该 session 对象没有<br>使用)。<br>两种设置方式：<br>方式一：<br>session.setMaxInactiveInterval(int seconds);<br>方式二：<br>服务器有一个缺省的超时限制，可以通过相应的配置文件来重新设置。比如可以修改 tomcat 的 web.xml(tomcat_home/conf 下面)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</div><div class="line">&lt;/session-config&gt;123123</div></pre></td></tr></table></figure>
<p>另外，也可以叧修改某个应用的 web.xml。</p>
<p>5、session删除</p>
<p>session.invalidate();</p>
<h2 id="三、用cookie记录最近10条记录"><a href="#三、用cookie记录最近10条记录" class="headerlink" title="三、用cookie记录最近10条记录"></a>三、用cookie记录最近10条记录</h2><p>用cookie查询最近一个月请求的前10条历史记录。cookie的中文要求转码和解码。如下图<br><img src="http://img.blog.csdn.net/20160805132326366" alt="这里写图片描述"></p>
<p>1、加入cookie到客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cookie[] cookies = request.getCookies();//浏览器在第一请求时调用该方法会返回null</div><div class="line">//浏览器第一次请求返回到浏览器之前会创建一个名为JSESSIONID 的cookie</div><div class="line">//param（请求参数）中文转码</div><div class="line">String paramEnd = URLEncoder.encode(param);</div><div class="line">Cookie cookie = new Cookie(&quot;param&quot;+cookies.length,paramEnd);//name不可以重复</div><div class="line">cookie.setMaxAge(60*60*24*30);//保留一个月的时间</div><div class="line">response.addCookie(cookie);//cookie在第一次加入时会创建一个JSESSIONID cookie12345671234567</div></pre></td></tr></table></figure>
<p>2、获取所有满足条件的cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">if(cookies!=null &amp;&amp; cookies.length&gt;0)&#123;</div><div class="line">    Map&lt;String,Object&gt; historyPar =  (Map&lt;String, Object&gt;)new ListOrderedMap();//按存入顺序取出,HashMap并不是按存入顺序取出</div><div class="line">    for(int i=cookies.length-1;i&gt;=0;i--)&#123;</div><div class="line">        Cookie cookie = cookies[i];</div><div class="line">        String cookVal = URLDecoder.decode(cookie.getValue());</div><div class="line">        if(cookie.getName().startsWith(&quot;param&quot;))&#123;</div><div class="line">            if(historyPar.size()==10) break;//查询最近10条记录</div><div class="line">            historyPar.put(cookVal, cookVal);//map的key值用cookie的value，以免历史记录重复</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    model.addAttribute(&quot;historyPar&quot;,historyPar);</div><div class="line">&#125;1234567891011121312345678910111213</div></pre></td></tr></table></figure>
<p>3、js实现历史清除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//删除该路径下所有cookie</div><div class="line">    function cleanCookie()&#123;</div><div class="line">         var keys=document.cookie.match(/[^ =;]+(?=\=)/g);</div><div class="line">         if (keys) &#123;</div><div class="line">            for (var i =  keys.length; i--;)&#123;</div><div class="line">               document.cookie=keys[i]+&apos;=0;expires=&apos; + new Date( 0).toUTCString()</div><div class="line">            &#125;</div><div class="line">         &#125;  </div><div class="line">         window.location.href=&quot;$&#123;ctx&#125;/searchController/globalSearch&quot;;</div><div class="line">    &#125;1234567891012345678910</div></pre></td></tr></table></figure>
<p>至此即可查询出最近一个月的前10条历史记录。</p>
<p>死锁是两个甚至多个线程被永久阻塞时的一种运行局面，这种局面的生成伴随着至少两个线程和两个或者多个资源。在这里我已写好一个简单的程序，它将会引起死锁方案然后我们就会明白如何分析它。</p>
<h1 id="Java死锁范例"><a href="#Java死锁范例" class="headerlink" title="Java死锁范例"></a>Java死锁范例</h1><p>ThreadDeadlock.java</p>
<p>在上面的程序中同步线程正完成Runnable的接口，它工作的是两个对象，这两个对象向对方寻求死锁而且都在使用同步阻塞。</p>
<p>在主函数中，我使用了三个为同步线程运行的线程，而且在其中每个线程中都有一个可共享的资源。</p>
<p>这些线程以向第一个对象获取封锁这种方式运行。但是当它试着像第二个对象获取封锁时，它就会进入等待状态，因为它已经被另一个线程封锁住了。这样，在线程引起死锁的过程中，就形成了一个依赖于资源的循环。</p>
<p>当我执行上面的程序时，就产生了输出，但是程序却因为死锁无法停止。</p>
<p>在此我们可以清楚地在输出结果中辨认出死锁局面，但是在我们实际生活所用的应用中，发现死锁并将它排除是非常难的。</p>
<h1 id="分析死锁"><a href="#分析死锁" class="headerlink" title="分析死锁"></a>分析死锁</h1><p>为了分析一个死锁，我们需要关注下应用中的<a href="http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java" target="_blank" rel="external">Java线程转存</a>，在上一节中我已经解释了如何使用VisualVM收集资料或者jstack应用程序<a href="http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java" target="_blank" rel="external">产生线程转存</a>。</p>
<p>以下就是上述程序的线程转存。</p>
<p>这三个线程转存的输出清楚地说明了死锁环境和线程，以及包含死锁环境的资源。</p>
<p>为了分析死锁，我们需要关注死锁状态的线程，然后资源再等待去封锁，每一个资源都有一个独特的ID，有了这个ID我们就能发现是哪一个进程已经封锁住对象。举个例子，线程“t3”正在等待封锁0x000000013df2f658,但是它已经被线程“t1”封锁住了。</p>
<p>当我们分析死锁环境的时候，如果发现线程正在引起死锁，这是我们就要改变代码来避免死锁的产生。</p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>有很多方针可供我们使用来避免死锁的局面。</p>
<ul>
<li><strong>避免嵌套封锁：</strong>这是死锁最主要的原因的，如果你已经有一个资源了就要避免封锁另一个资源。如果你运行时只有一个对象封锁，那是几乎不可能出现一个死锁局面的。例如，这里是另一个运行中没有嵌套封锁的run()方法，而且程序运行没有死锁局面，运行得很成功。</li>
</ul>
<ul>
<li><strong>只对有请求的进行封锁：</strong>你应当只想你要运行的资源获取封锁，比如在上述程序中我在封锁的完全的对象资源。但是如果我们只对它所属领域中的一个感兴趣，那我们应当封锁住那个特殊的领域而并非完全的对象。</li>
<li><strong>避免无限期的等待：</strong>如果两个线程正在等待对象结束，无限期的使用线程加入，如果你的线程必须要等待另一个线程的结束，若是等待进程的结束加入最好准备最长时间。</li>
</ul>
<h1 id="Mysql并发时经典常见的死锁原因及解决方法"><a href="#Mysql并发时经典常见的死锁原因及解决方法" class="headerlink" title="Mysql并发时经典常见的死锁原因及解决方法"></a><a href="http://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="external">Mysql并发时经典常见的死锁原因及解决方法</a></h1><p> <strong>1.    **</strong>mysql<strong>**都有什么锁</strong></p>
<p>MySQL有三种锁的级别：页级、表级、行级。</p>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>算法：</p>
<p>next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap    </p>
<p>Gap锁，不锁记录，仅仅记录前面的Gap</p>
<p>Recordlock锁（锁数据，不锁Gap）</p>
<p>所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</p>
<p><strong>2.    **</strong>什么情况下会造成死锁**</p>
<p>所谓死锁<deadlock>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</deadlock></p>
<p>死锁的关键在于<strong>：两个(**</strong>或以上)<strong><strong>的Session</strong></strong>加锁的顺序<strong>**不一致。</strong></p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<p><strong>3.    **</strong>一些常见的死锁案例**</p>
<p><strong>案例一：</strong></p>
<p>需求：将投资的钱拆成几份随机分配给借款人。</p>
<p>起初业务程序思路是这样的：</p>
<p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p>
<p>抽象出来就是一个session通过for循环会有几条如下的语句：</p>
<p>Select * from xxx where id=’随机id’ for update</p>
<p>基本来说，程序开启后不一会就死锁。</p>
<p>这可以是说最经典的死锁情形了。</p>
<p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p>
<p>B用户金额随机分为2份，分给借款人2，1</p>
<p>由于加锁的顺序不一样，死锁当然很快就出现了。</p>
<p><strong>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</strong></p>
<p><strong>Select * from xxx where id in (xx,xx,xx) for update</strong></p>
<p><strong>在in**</strong>里面的列表值mysql<strong>**是会自动从小到大排序，加锁也是一条条从小到大加的锁</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">例如（以下会话id为主键）：</div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id in (8,9) for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">|  8 | WA     | f    | 2016-03-02 11:36:30 |</div><div class="line"></div><div class="line">|  9 | JX     | f    | 2016-03-01 11:36:30 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">2 rows in set (0.04 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">select * from t3 where id in (10,8,5) for update;</div><div class="line"></div><div class="line">锁等待中……</div><div class="line"></div><div class="line">其实这个时候id=10这条记录没有被锁住的，但id=5的记录已经被锁住了，锁的等待在id=8的这里。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">不信请看</div><div class="line"></div><div class="line">Session3:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id=5 for update;</div><div class="line"></div><div class="line">锁等待中</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session4:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id=10 for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| 10 | JB     | g    | 2016-03-10 11:45:05 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">在其它session中id=5是加不了锁的，但是id=10是可以加上锁的。</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>案例2**</strong>：**</p>
<p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">以id为主键为例，目前还没有id=22的行</div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">select * from t3 where id=22 for update;</div><div class="line"></div><div class="line">Empty set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">session2:</div><div class="line"></div><div class="line">select * from t3 where id=23  for update;</div><div class="line"></div><div class="line">Empty set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">insert into t3 values(22,&apos;ac&apos;,&apos;a&apos;,now());</div><div class="line"></div><div class="line">锁等待中……</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">insert into t3 values(23,&apos;bc&apos;,&apos;b&apos;,now());</div><div class="line"></div><div class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>当对存在的行进行锁的时候(主键)，mysql就只有行锁。</p>
<p>当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</p>
<p>锁住的范围为：</p>
<p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p>
<p>如：如果表中目前有已有的id为（11 ， 12）</p>
<p>那么就锁住（12，无穷大）</p>
<p>如果表中目前已有的id为（11 ， 30）</p>
<p>那么就锁住（11，30）</p>
<p><strong>对于这种死锁的解决办法是：</strong></p>
<p><strong>insert into t3(xx,xx) on duplicate key update <code>xx</code>=’XX’;</strong></p>
<p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p>
<p><strong>案例3**</strong>：**</p>
<p>直接上情景：</p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t3 where id=9 for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">|  9 | JX     | f    | 2016-03-01 11:36:30 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id&lt;20 for update;</div><div class="line"></div><div class="line">锁等待中</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">mysql&gt; insert into t3 values(7,&apos;ae&apos;,&apos;a&apos;,now());</div><div class="line"></div><div class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p>
<p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p>
<p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p>
<p>需要用以下模式来设定锁定模式</p>
<p>1、SELECT …… LOCK IN SHARE MODE（共享锁）<br>查询到的数据，就是数据库在这一时刻的数据（其他已commit事务的结果，已经反应到这里了）<br>SELECT 必须等待，某个事务结束后才能执行</p>
<p>2、SELECT …… FOR UPDATE（排它锁）<br>例如 SELECT * FROM tablename WHERE id&lt;200<br>那么id&lt;200的数据，被查询到的数据，都将不能再进行修改、删除、SELECT …… LOCK IN SHARE MODE操作<br>一直到此事务结束</p>
<p>共享锁 和 排它锁 的区别：在于是否阻断其他客户发出的 SELECT …… LOCK IN SHARE MODE命令</p>
<p>3、INSERT / UPDATE / DELETE<br>所有关联数据都会被锁定，加上排它锁</p>
<p>4、防插入锁<br>例如 SELECT * FROM tablename WHERE id&gt;200<br>那么id&gt;200的记录无法被插入</p>
<p>5、死锁<br>自动识别死锁<br>先进来的进程被执行，后来的进程收到出错消息，并按ROLLBACK方式回滚<br>innodb_lock_wait_timeout = n 来设置最长等待时间，默认是50秒</p>
<p>附记，推荐两篇好文章</p>
<p>案例4：</p>
<p><a href="http://hedengcheng.com/?p=844" target="_blank" rel="external">http://hedengcheng.com/?p=844</a></p>
<p>MySQL 加锁处理分析：</p>
<p><a href="http://hedengcheng.com/?p=771" target="_blank" rel="external">http://hedengcheng.com/?p=771</a></p>
<p>Skip lists are a data structure that can <strong>be used in place of balanced trees</strong>. Skip lists use <strong>probabilistic balancing</strong> rather than strictly enforced balancing and as a result the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.</p>
<p>invokespecial    类的构造方法，类的私有方法        静态绑定</p>
<p>invokestatic       类的静态方法</p>
<p>invokeinterface      接口的方法</p>
<p>invokevirtual       普通的实例方法                    动态绑定</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/15/JVM-的GC机制/" rel="next" title="JVM 的GC机制">
                <i class="fa fa-chevron-left"></i> JVM 的GC机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/16/Mysql/" rel="prev" title="Mysql">
                Mysql <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Wuxinyua" />
          <p class="site-author-name" itemprop="name">Wuxinyua</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步-1-synchronized-2-volatile-3-lock-4-AtomicXX"><span class="nav-number">1.</span> <span class="nav-text">同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number"></span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景："><span class="nav-number">1.</span> <span class="nav-text">应用场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number"></span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Deeper…"><span class="nav-number">1.</span> <span class="nav-text">Deeper…</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile和synchronized的区别："><span class="nav-number">1.1.</span> <span class="nav-text">volatile和synchronized的区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number"></span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锁的两种特性："><span class="nav-number">1.</span> <span class="nav-text">锁的两种特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正确的使用方式："><span class="nav-number">1.1.</span> <span class="nav-text">正确的使用方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基本锁的获取过程"><span class="nav-number">1.2.</span> <span class="nav-text">基本锁的获取过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#释放锁过程"><span class="nav-number">1.3.</span> <span class="nav-text">释放锁过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.4.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantReadWriteLock-当主要操作为读访问时，可以使用提供性能"><span class="nav-number">1.5.</span> <span class="nav-text">ReentrantReadWriteLock  当主要操作为读访问时，可以使用提供性能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition对象"><span class="nav-number">2.</span> <span class="nav-text">Condition对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#await-过程："><span class="nav-number">2.1.</span> <span class="nav-text">await()过程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#正确的使用方式：-1"><span class="nav-number">2.2.</span> <span class="nav-text">正确的使用方式：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA中线程的状态"><span class="nav-number"></span> <span class="nav-text">JAVA中线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子变量类"><span class="nav-number"></span> <span class="nav-text">原子变量类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Happens-Before原则"><span class="nav-number"></span> <span class="nav-text">Happens-Before原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发的数据结构"><span class="nav-number"></span> <span class="nav-text">并发的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number"></span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⑴-原子性（Atomicity）"><span class="nav-number"></span> <span class="nav-text">⑴ 原子性（Atomicity）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⑵-一致性（Consistency）"><span class="nav-number"></span> <span class="nav-text">⑵ 一致性（Consistency）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⑶-隔离性（Isolation）"><span class="nav-number"></span> <span class="nav-text">⑶ 隔离性（Isolation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#⑷-持久性（Durability）"><span class="nav-number"></span> <span class="nav-text">⑷ 持久性（Durability）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1，脏读"><span class="nav-number"></span> <span class="nav-text">1，脏读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2，不可重复读"><span class="nav-number"></span> <span class="nav-text">2，不可重复读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3，虚读-幻读"><span class="nav-number"></span> <span class="nav-text">3，虚读(幻读)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp、ip、udp头部格式"><span class="nav-number"></span> <span class="nav-text">tcp、ip、udp头部格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#object类的结构"><span class="nav-number"></span> <span class="nav-text">object类的结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数说明"><span class="nav-number"></span> <span class="nav-text">函数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clone"><span class="nav-number"></span> <span class="nav-text">clone()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-和equale"><span class="nav-number"></span> <span class="nav-text">hashCode()和equale()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-和getClass"><span class="nav-number"></span> <span class="nav-text">toString()和getClass()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-wait-long-wait-long-int-notify-notifyAll"><span class="nav-number"></span> <span class="nav-text">wait(),wait(long),wait(long,int),notify(),notifyAll()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize"><span class="nav-number"></span> <span class="nav-text">finalize()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、cookie"><span class="nav-number"></span> <span class="nav-text">一、cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、session"><span class="nav-number"></span> <span class="nav-text">二、session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、用cookie记录最近10条记录"><span class="nav-number"></span> <span class="nav-text">三、用cookie记录最近10条记录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java死锁范例"><span class="nav-number"></span> <span class="nav-text">Java死锁范例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分析死锁"><span class="nav-number"></span> <span class="nav-text">分析死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#避免死锁"><span class="nav-number"></span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql并发时经典常见的死锁原因及解决方法"><span class="nav-number"></span> <span class="nav-text">Mysql并发时经典常见的死锁原因及解决方法</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wuxinyua</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
