<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/25/系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/25/系统设计/" itemprop="url">
                  系统设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-25T11:30:35+08:00">
                2017-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>1.优化技术</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/cc2a92e324587867c8cfba3022ea9cca_b.jpg" alt="cc2a92e324587867c8cfba3022ea9cca_b"></p>
<table>
<thead>
<tr>
<th>Cache</th>
<th>缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>Queue</td>
<td>消息队列，linkedin的kafka</td>
</tr>
<tr>
<td>Asynchronized</td>
<td>批处理+异步 减少IO的系统瓶颈</td>
</tr>
<tr>
<td>Load Balance</td>
<td>负载均衡，使用一致性的hash技术减少数据</td>
</tr>
<tr>
<td>Parallelization</td>
<td>并行化，MapReduce</td>
</tr>
<tr>
<td>Replication</td>
<td>提高可靠性</td>
</tr>
<tr>
<td>Partition</td>
<td>数据库分区，通过hash取模</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/18/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/18/计算机网络/" itemprop="url">
                  计算机网络
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-18T11:21:32+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="OSI七层协议和TCP-IP分层"><a href="#OSI七层协议和TCP-IP分层" class="headerlink" title="OSI七层协议和TCP/IP分层"></a>OSI七层协议和TCP/IP分层</h4><h4 id="TCP表头、IP表头、Http表头"><a href="#TCP表头、IP表头、Http表头" class="headerlink" title="TCP表头、IP表头、Http表头"></a>TCP表头、IP表头、Http表头</h4><p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/1337910943_1128.jpg" alt="1337910943_1128"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>ip协议的版本号</td>
<td>标志位</td>
<td>是否要求分段</td>
</tr>
<tr>
<td>Internet Header Length</td>
<td>报头的头部长度，默认长度为20字节</td>
<td>段偏移</td>
<td>报文被分段的时候，记录偏移量</td>
</tr>
<tr>
<td>Type Of Service</td>
<td>第4-7位分别表示延迟，吞吐量，可靠性和费用，根据设置的值在进行网络传输时如何处理</td>
<td>TTL</td>
<td>设置最多可以经过的路由数</td>
</tr>
<tr>
<td>Total Length</td>
<td>总长度，以字节为单位</td>
<td>协议</td>
<td>指明上层的协议类型</td>
</tr>
<tr>
<td>标志字段</td>
<td>每个报文的唯一识别</td>
<td>校验和</td>
<td>头部校验，按2字节进行二进制反码求和</td>
</tr>
<tr>
<td>IP地址</td>
<td>源IP地址和目的IP地址</td>
<td>可选项字段</td>
<td>必须为4字节的整数倍</td>
</tr>
</tbody>
</table>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/1337910956_9817.jpg" alt="1337910956_9817"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>端口号</td>
<td>源端口号和目的端口号</td>
<td>Seq序号</td>
<td>报文的标识</td>
</tr>
<tr>
<td>ACK序号</td>
<td>ACK位置1时，表示期望收到的报文标识</td>
<td>头部长度</td>
<td>默认20字节</td>
</tr>
<tr>
<td>标志位</td>
<td>SYN 发起连接  FIN 释放链接  RST 重建连接 ACK 确认序号 URG 紧急指针有效 PSH 接收方尽快将报文传给应用层</td>
<td>窗口大小</td>
<td>期望接收到的字节数</td>
</tr>
<tr>
<td>校验和</td>
<td>包括头部和数据</td>
<td>紧急指针</td>
<td>偏移量，和Seq相加后表示紧急数据的最后一个字节的序号</td>
</tr>
</tbody>
</table>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/2012021116181545.png" alt="2012021116181545"></p>
<table>
<thead>
<tr>
<th>TCP</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td></td>
</tr>
<tr>
<td>HTTP</td>
</tr>
</tbody>
</table>
<p>浏览器输入URL之后的执行过程：</p>
<p>1.浏览器发起一个Http请求，通过DNS解析url到特定的IP地址</p>
<p>2.Http数据包在传输层分成报文段，添加TCP头部后发起TCP请求连接</p>
<p>3.TCP数据包在IP层添加IP头部信息，通过IP地址查找路由表确定传送路径</p>
<p>4.IP数据包在数据链路层添加以太网帧头和帧尾形成以太网帧，进行数据传输</p>
<p>5.以太网帧通过物理层转换成高低电平并开始在传输介质上传输</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/64bd78296562f1b7410c195554fc5231_b.jpg" alt="64bd78296562f1b7410c195554fc5231_b"></p>
<p>6.服务器接收到后反向进行上述步骤，处理该请求后返回一个Response应答</p>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><h5 id="头部内容"><a href="#头部内容" class="headerlink" title="头部内容:"></a>头部内容:</h5><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>接受媒体类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>接收字符集</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>接收编码方式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Accept-Language</td>
<td>接收自然语言</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Age</td>
<td>通知接收端响应产生的时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Allow</td>
<td>通知客户端可以对特定资源使用哪些HTTP方法</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.无状态的 同一个客户端的多个连续请求之间没有联系</p>
<p>用户识别机制：</p>
<p>1.</p>
<p>Web程序通过使用Cookie来维护状态</p>
<p>2.</p>
<p><strong>状态码：</strong></p>
<p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<p>1XX  信息状态码 </p>
<p>2XX  成功 - 表示请求已被成功接收，理解，接受</p>
<p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p>
<p>​    301    请求的url已被移除使用</p>
<p>​    302  临时定位资源</p>
<p>​    304 Not Modified  资源未被修改</p>
<p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p>
<p>​    400   Bad Request 客户端发送了一个错误的请求</p>
<p>​    403   Forbidden  请求被服务器拒绝</p>
<p>​    404   Not Found  服务器无法找到请求的url</p>
<p>5XX  服务器端错误 -   服务器未能实现合法的请求</p>
<p>​    500  Internal Server Error  服务器内部错误</p>
<p>​    503 Server Unavaliable  服务器当前无法处理客户端的请求</p>
<h4 id="ARP-RARP-地址解析协议-反地址解析协议"><a href="#ARP-RARP-地址解析协议-反地址解析协议" class="headerlink" title="ARP/RARP    地址解析协议/反地址解析协议"></a>ARP/RARP    地址解析协议/反地址解析协议</h4><p>ARP地址解析协议：<u>为IP地址到对应的硬件地址之间提供动态映射</u></p>
<p>对于以太网，数据链路层上是根据48bit的以太网地址来确定目的接口，设备驱动程序从不检查IP数据报中的目的IP地址。</p>
<p>在以太网（ARP协议只适用于局域网）中，如果本地主机想要向某一个IP地址的主机（路由表中的下一跳路由器或者直连的主机，注意此处IP地址不一定是IP数据报中的目的IP）发包，但是并不知道其硬件地址，此时利用ARP协议提供的机制来获取硬件地址，具体过程如下：</p>
<p>1) 本地主机在局域网中广播ARP请求，ARP请求数据帧中包含目的主机的IP地址。意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址”。</p>
<p>2) 目的主机的ARP层解析这份广播报文，识别出是询问其硬件地址。于是发送ARP应答包，里面包含IP地址及其对应的硬件地址。</p>
<p>3) 本地主机收到ARP应答后，知道了目的地址的硬件地址，之后的数据报就可以传送</p>
<p>将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。RARP协议广泛应用于无盘工作站引导时获取IP地址</p>
<p>DHCP、NAT <!--待补充--></p>
<p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段</p>
<p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机</p>
<h4 id="DNS域名解析原理"><a href="#DNS域名解析原理" class="headerlink" title="DNS域名解析原理"></a>DNS域名解析原理</h4><p>DNS是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作</p>
<p>客户端通过发送包含指定的域名，查询类别，以及DNS域名的指定类别请求报文(UDP类型)给本地DNS服务器，获取对应的IP地址</p>
<p>DNS 数据库中包含资源记录 (RR)。 每个 RR 标识数据库中的特定资源。我们在建立DNS服务器时，经常会用到<u><strong>SOA,NS,A</strong></u>之类的记录，在维护DNS服务器时，会用到<strong><u>MX，CNAME</u></strong>记录</p>
<h5 id="DNS服务过程"><a href="#DNS服务过程" class="headerlink" title="DNS服务过程"></a>DNS服务过程</h5><p>当 DNS 客户机需要查询程序中使用的名称时，它会查询本地DNS 服务器来解析该名称。客户机发送的每条查询消息都包括3条信息，以指定服务器应回答的问题。<br>● 指定的 DNS 域名，表示为完全合格的域名 (FQDN) 。<br>● 指定的查询类型，它可根据类型指定资源记录，或作为查询操作的专门类型。<br>● DNS域名的指定类别。</p>
<p>1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </p>
<p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p>
<p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p>
<p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </p>
<p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 </p>
<p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机</p>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询</p>
<p><strong>DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在<code>/etc/resolv.conf</code>文件</strong></p>
<h5 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h5><p>1） <code>A</code>：地址记录（Address），返回域名指向的IP地址。</p>
<p>2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p>
<p>4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。</p>
<p>5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文</p>
<hr>
<h4 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p><strong><u>会话Cookie</u></strong>：临时Cookie，记录用户访问站点的设置和偏好 用户退出浏览器即被删除  默认下MaxAge为负值</p>
<p><u><strong>持久Cookie</strong></u>：存放在磁盘上，维护用户周期性访问的站点的配置信息</p>
<p>默认情况下为会话Cookie，除非设置了Discard参数或者设置了Expires参数，Max-Age参数</p>
<p>区别：过期时间不同</p>
<p><strong>工作原理</strong>：浏览器积累一组服务器特有的信息，使得客户端每次访问该服务器时提供相应的信息给它</p>
<p><strong><u>特点：</u></strong></p>
<p>1.只能保存字符串信息，不能保存对象类型</p>
<p>2.存放在客户端</p>
<p>3.需要浏览器的支持，浏览器可以设置禁止使用Cookie</p>
<p>4.Cookie可以设置域属性和路径属性来限制获取Cookie的站点</p>
<p><strong><u>主要属性：</u></strong></p>
<table>
<thead>
<tr>
<th>Comment</th>
<th>注释信息</th>
<th>MaxAge</th>
<th>设置生存周期</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain</td>
<td>设置符合的域</td>
<td>Secure</td>
<td>是否必须使用SSL连接</td>
</tr>
<tr>
<td>Path</td>
<td>设置符合的路径</td>
<td>Version</td>
<td>Cookie的版本号</td>
</tr>
<tr>
<td>Key</td>
<td>键名</td>
<td>Value</td>
<td>键值</td>
</tr>
</tbody>
</table>
<p><u><strong>主要目的：</strong></u></p>
<p>1.标识用户</p>
<p>2.定制站点和定向广告</p>
<h5 id="发送和接收-删除："><a href="#发送和接收-删除：" class="headerlink" title="发送和接收 删除："></a><strong><u>发送和接收 删除：</u></strong></h5><p>发送：1.创建Cookie对象，设置最大时效，添加到HTTP的响应头</p>
<p>接收：1.通过request.getCookies()遍历数组获取</p>
<p>删除：1.服务端将Cookie设置setMaxAge(0)</p>
<h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><p>Servlet中存在一个对象为HttpSession</p>
<p>当调用HttpServletRequest的getSession接口时，Web容器创建HttpSession对象，同时对应一个唯一的JSESSIONID，客户端发送请求时如果附带JSESSIONID，wbe容器便会将相应的HttpSession对象放入request中</p>
<p>当用户禁止使用Cookie时，利用url重写。HttpServletResponse对象的encodeURL接口对url重写根据情况添加JSESSIONID</p>
<p>如何确定Session失效：</p>
<p>1.Session可以设置MaxInActiveInterval的值，当超过该值，Session便处于非活跃状态可被删除</p>
<p>2.主动调用invalidate()或者logout()接口</p>
<p>3.服务器的web.xml文件可以配置session-timeout属性</p>
<h5 id="Session和Cookie的区别："><a href="#Session和Cookie的区别：" class="headerlink" title="Session和Cookie的区别："></a><u>Session和Cookie的区别：</u></h5><p>1.存放位置不同，Cookie位于客户端，Session处于服务器端</p>
<p>2.Cookie只能保存字符串信息，Session可以支持各种类型的对象</p>
<p>3.Cookie可以通过设置MaxAge限制生存周期</p>
<p>4.Session通过利用Cookie或者URL重写来维护用户的会话状态</p>
<p>5.Cookie的数量和大小都存在限制</p>
<p>6.Cookie的编码为ascii字符，如果需要保存中文的信息需要编码，使用URLEncoder.encode()</p>
<p><strong><u>Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态</u></strong>。</p>
<p>使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用</p>
<p><strong>三种方式能可以让 Session 正常工作：</strong></p>
<ol>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持</li>
</ol>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p>
<p>客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p>
<p>根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image023.jpg" alt="image023"></p>
<p><strong>购物车的会话跟踪</strong></p>
<p>1.Cookie中记录JSESSIONID，服务器通过该值从hash表中查找相应的信息</p>
<p>2.URL重写，将JSEESIONID的相关信息添加在url的末端</p>
<p>3.隐藏的表单域，在input输入域添加隐藏的值，存在局限性</p>
<h4 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h4><p>session记录用户的会话状态，当服务器从单台机器变成一个集群时，需要对session进行分布式管理</p>
<p>1.缓存式集中管理   基于memcached 的session  、基于Redis 进行 session 共享</p>
<p><strong>简介：</strong>将Session存入分布式缓存集群中的某台机器上，当用户访问不同节点时先从缓存中拿Session信息</p>
<p><strong>使用场景</strong>：集群中机器数多、网络环境复杂</p>
<p><strong>优点</strong>：可靠性好，高可用性</p>
<p><strong>缺点</strong>：实现复杂、稳定性依赖于缓存的稳定性、Session信息放入缓存时要有合理的策略写入</p>
<p>2.Session Sticky 方式管理</p>
<p>简介：即粘性Session、当用户访问集群中某台机器后，强制指定后续所有请求均落到此机器上</p>
<p>使用场景：机器数适中、对稳定性要求不是非常苛刻</p>
<p>优点：实现简单、配置方便、没有额外网络开销</p>
<p>缺点：网络中有机器离线时、用户Session会丢失、容易造成单点故障</p>
<p>3.session复制</p>
<p><strong>简介：</strong>将一台机器上的Session数据广播复制到集群中其余机器上</p>
<p><strong>使用场景</strong>：机器较少，网络流量较小</p>
<p><strong>优点</strong>：实现简单、配置较少、当网络中有机器离线时不影响用户访问</p>
<p> <strong>缺点</strong>：广播式复制到其余机器有一定廷时，带来一定网络开销</p>
<p>4.基于cookie 进行session共享</p>
<hr>
<p>####慢启动算法</p>
<p>通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作</p>
<p>拥塞窗口：当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为一个报文段，每收到一个ack，窗口增加一个报文段大小，发送方取拥塞窗口和通告窗口中的最小值作为发送上限、其中拥塞窗口是发送方使用的流量控制，通告窗口为接收方使用的流量控制。</p>
<h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a>快速重传算法</h4><p>Restful接口</p>
<hr>
<h4 id="Tomcat的工作原理"><a href="#Tomcat的工作原理" class="headerlink" title="Tomcat的工作原理"></a>Tomcat的工作原理</h4><h5 id="1-tomcat处理http请求-http-localhost-8080-wsota-wsota-index-jsp"><a href="#1-tomcat处理http请求-http-localhost-8080-wsota-wsota-index-jsp" class="headerlink" title="1.tomcat处理http请求        http://localhost:8080/wsota/wsota_index.jsp"></a>1.tomcat处理http请求        <a href="http://localhost:8080/wsota/wsota_index.jsp" target="_blank" rel="external">http://localhost:8080/wsota/wsota_index.jsp</a></h5><p>1) 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得<br>2) Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应<br>3) Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host<br>4) Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）<br>5) localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context<br>6) Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为””的Context去处理）<br>7) path=”/wsota”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet<br>8) Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类<br>9) 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法<br>10)Context把执行完了之后的HttpServletResponse对象返回给Host<br>11)Host把HttpServletResponse对象返回给Engine<br>12)Engine把HttpServletResponse对象返回给Connector<br>13)Connector把HttpServletResponse对象返回给客户browser</p>
<h5 id="2-Servlet的生命周期"><a href="#2-Servlet的生命周期" class="headerlink" title="2.Servlet的生命周期"></a>2.Servlet的生命周期</h5><p>1.创建servlet实例    服务器在接收到对servlet的第一个请求时，创建一个唯一的实例</p>
<p>2.调用init()方法进行初始化任务，init方法在servlet的生命周期中只被调用一次</p>
<p>3.服务器在每接收到一个请求的时候，创建一个新的线程调用service方法，service方法检查http请求的类型相应的调用doGet(),doPost()…等方法。如果在处理过程中访问了全局的共享变量，需要增加同步控制</p>
<p>4.调用destroy()方法，停止接收请求，servlet实例被GC回收</p>
<h5 id="3-Tomcat的设计模式"><a href="#3-Tomcat的设计模式" class="headerlink" title="3.Tomcat的设计模式"></a>3.Tomcat的设计模式</h5><p><strong><u>1.观察者模式</u></strong>   控制组件生命周期的 Lifecycle </p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image003.png" alt="image003"></p>
<table>
<thead>
<tr>
<th>LifecycleListener</th>
<th>抽象观察者</th>
<th>定义一个 lifecycleEvent 方法，当主题变化时触发执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServerLifecycleListener</td>
<td>具体的观察者</td>
<td>实现了 LifecycleListener 接口的方法</td>
</tr>
<tr>
<td>Lifecycle</td>
<td>抽象主题</td>
<td>定义了管理观察者的方法和它要所做的其它方法</td>
</tr>
<tr>
<td>StandardServer</td>
<td>具体主题</td>
<td>实现了抽象主题的所有方法</td>
</tr>
<tr>
<td>LifecycleEvent</td>
<td></td>
<td>定义事件类别，不同的事件可区别处理，更加灵活</td>
</tr>
<tr>
<td>LifecycleSupport</td>
<td>代理了主题对多观察者的管理</td>
<td>将这个管理抽出来统一实现，以后如果修改只要修改 LifecycleSupport 类就可以了，不需要去修改所有具体主题，因为所有具体主题的对观察者的操作都被代理给 LifecycleSupport 类</td>
</tr>
</tbody>
</table>
<p>Tomcat 对观察者扩展，增加了另外两个类：LifecycleSupport、LifecycleEvent作为辅助类扩展了观察者的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LifecycleSupport 中的 fireLifecycleEvent 方法  对所有监听者的管理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line">    LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</div><div class="line">    LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">        interested = (LifecycleListener[]) listeners.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</div><div class="line">        interested[i].lifecycleEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//容器中的 start 方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">    lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">    started = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">synchronized</span> (services) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (services[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                ((Lifecycle) services[i]).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong><em>2.责任链模式</em></strong></u> 多个不同层次的容器通过责任链将请求正确的传递给最终处理请求的那个 Servlet</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image005.jpg" alt="image005"></p>
<p>上图基本描述了四个子容器使用责任链模式的类结构图，Container 扮演抽象处理者角色，具体处理者由 StandardEngine 等子容器扮演。</p>
<p>与标准的责任链不同的是，这里引入了 <u><em>Pipeline 和 Valve 接口</em></u>。</p>
<p>实际上 Pipeline 和 Valve 是扩展了这个链的功能，使得在链往下传递过程中，能够接受外界的干预。Pipeline 就是连接每个子容器的管子，里面传递的 Request 和 Response 对象好比管子里流的水，而 Valve 就是这个管子上开的一个个小口子，让你有机会能够接触到里面的水，做一些额外的事情。</p>
<p>为了防止水被引出来而不能流到下一个容器中，每一段管子最后总有一个节点保证它一定能流到下一个子容器，所以每个容器都有一个 StandardXXXValve。</p>
<p><strong><u>3.命令设计模式</u></strong>  Connector 和 Container 组件之间</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image004.png" alt="image004"></p>
<p>Connector 作为抽象请求者，HttpConnector 作为具体请求者。HttpProcessor 作为命令。Container 作为命令的抽象接受者，ContainerBase 作为具体的接受者。客户端就是应用服务器 Server 组件了。Server 首先创建命令请求者 HttpConnector 对象，然后创建命令 HttpProcessor 命令对象。再把命令对象交给命令接受者 ContainerBase 容器来处理命令。命令的最终是被 Tomcat 的 Container 执行的。命令可以以队列的方式进来，Container 也可以以不同的方式来处理请求，如 HTTP1.0 协议和 HTTP1.1 的处理方式就会不同</p>
<p><strong><u>4.门面设计模式</u></strong></p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image002.png" alt="image002"></p>
<p>HttpRequestFacade 类封装了 HttpRequest 接口能够提供数据，通过 HttpRequestFacade 访问到的数据都被代理到 HttpRequest 中，通常被封装的对象都被设为 Private 或者 Protected 访问修饰，以防止在 Façade 中被直接访问</p>
<h5 id="4-servlet-Filter-Listener-interceptor"><a href="#4-servlet-Filter-Listener-interceptor" class="headerlink" title="4.servlet Filter Listener interceptor"></a>4.servlet Filter Listener interceptor</h5><table>
<thead>
<tr>
<th>Servlet</th>
<th>运行于服务器端的java应用程序，具有独立于平台和协议的特性，并且可以动态的生成web页面，工作在客户端请求与服务器响应的中间层</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filter</td>
<td>主要的用途是转换HTTP请求、响应和头信息，进行字符编码、做一些业务逻辑判断(登录权限)， 不能直接向用户生成响应 一般的处理流程为  <strong>Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理</strong></td>
</tr>
<tr>
<td>Listener</td>
<td>监听web服务器中某一个执行动作，并根据其要求作出相应的响应。随着web的启动而创建，与web容器拥有相同的生命周期。通常监听web容器的启动，session的创建和消失</td>
</tr>
<tr>
<td>interceptor</td>
<td>出现在web框架中，基于面向切面编程的思想，利用动态代理在处理前后添加额外的逻辑处理</td>
</tr>
</tbody>
</table>
<p>多个filter可以形成一个FilterChain，请求<strong>按照其在web.xml中配置的顺序</strong>依次经过各个filter进行处理后再到达servlet，类似一个栈式调用</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image025.png" alt="image025"></p>
<p><u><strong>Filter和interceptor的区别：</strong></u></p>
<p>1.配置的位置不同  filter依赖于servlet容器的配置，interceptor在框架对应的XXX.xml文件进行配置</p>
<p>2.实现的原理不同   filter基于函数回调，interceptor基于动态代理</p>
<h5 id="5-Context容器的启动过程-一个context容器对应一个Web应用"><a href="#5-Context容器的启动过程-一个context容器对应一个Web应用" class="headerlink" title="5.Context容器的启动过程  一个context容器对应一个Web应用"></a><strong>5.Context容器的启动过程</strong>  一个context容器对应一个Web应用</h5><p>当 Context 容器初始化状态设为 init 时，添加在 Context 容器的 Listener -ContextConfig (继承 LifecycleListener )启动init方法。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作</p>
<p>ContextConfig 的 init 方法将会主要完成以下工作：</p>
<ol>
<li>创建用于解析 xml 配置文件的 contextDigester 对象</li>
<li>读取默认 context.xml 配置文件，如果存在解析它</li>
<li>读取默认 Host 配置文件，如果存在解析它</li>
<li>读取默认 Context 自身的配置文件，如果存在解析它</li>
<li>设置 Context 的 DocBase</li>
</ol>
<p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，主要包括如下几个部分：</p>
<ol>
<li>创建读取资源文件的对象</li>
<li>创建 ClassLoader 对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类如：logger、realm、resources 等</li>
<li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li>
<li>子容器的初始化</li>
<li>获取 ServletContext 并设置必要的参数</li>
<li>初始化“load on startup”的 Servlet</li>
</ol>
<h5 id="6-Web应用的初始化"><a href="#6-Web应用的初始化" class="headerlink" title="6.Web应用的初始化"></a><strong>6.Web应用的初始化</strong></h5><p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要<strong>解析 web.xml 文件</strong>，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p>
<p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找<strong>应用的配置文件 examples/WEB-INF/web.xml</strong>。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中</p>
<h5 id="7-Tomcat的映射原理"><a href="#7-Tomcat的映射原理" class="headerlink" title="7.Tomcat的映射原理"></a>7.Tomcat的映射原理</h5><p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：</p>
<p><a href="http://hostname" target="_blank" rel="external">http://hostname</a>: port /contextpath/servletpath，</p>
<p>hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p>
<p>这种映射工作有专门一个类来完成的，这个就是 <strong><u>org.apache.tomcat.util.http.mapper</u></strong>，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，<strong>mapper 将会根据这次请求的 hostname 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中</strong>。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image020.jpg" alt="image020"></p>
<h5 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h5><p>负责接收浏览器发送的tcp连接请求并创建request和response对象用于和请求端交互数据，同时启动一个线程HttpProcessor，HttpProcessor将request和response对象进行内容解析和填充后传递给container容器中相应的wrapper容器进行逻辑处理。</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/origin_image006.png" alt="origin_image006"></p>
<h5 id="Container容器-schema-host-port-contextPath-servletpath…"><a href="#Container容器-schema-host-port-contextPath-servletpath…" class="headerlink" title="Container容器   schema://host:port/contextPath/servletpath…"></a>Container容器   schema://host:port/contextPath/servletpath…</h5><p>组件的生命周期由包含它的父组件控制</p>
<table>
<thead>
<tr>
<th>Engine</th>
<th>servlet引擎，将请求分配给虚拟主机处理，相当于一个container， 一个特定的Service的请求处理流水线</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>解析每个war包的web.xml文件，加载，运行，结束多个应用</td>
</tr>
<tr>
<td>Context</td>
<td>创建servlet，维持所有的servlet实例，代表一个web应用程序   url和path分别代表应用的访问路径和实际的物理路径</td>
</tr>
<tr>
<td>Wrapper</td>
<td>对每个servlet实例进行封装，负责servlet的 装载、初始化、执行以及资源回收</td>
</tr>
<tr>
<td>service</td>
<td>将多个connector绑定到container容器上</td>
</tr>
<tr>
<td>server</td>
<td>表示整个Catalina Servlet容器,包含一个或者多个service组件</td>
</tr>
<tr>
<td>connector</td>
<td>接收tcp请求，创建request和response对象，传递给相应的container处理</td>
</tr>
</tbody>
</table>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/origin_image010.png" alt="origin_image010"></p>
<h5 id="创建和初始化Servlet"><a href="#创建和初始化Servlet" class="headerlink" title="创建和初始化Servlet"></a>创建和初始化Servlet</h5><p>1.如果servlet的load-on-startup项大于0，那么在 Context 容器启动的时候就会被实例化</p>
<p>2.Wrapper. loadServlet 获取 servletClass 然后 InstanceManager 创建一个基于 servletClass.class 的对象</p>
<p>3.StandardWrapper调用initServlet方法，方法中调用servlet的init方法并传递ServletConfig对象给servlet</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image007.jpg" alt="image007"></p>
<h5 id="servlet的体系结构"><a href="#servlet的体系结构" class="headerlink" title="servlet的体系结构"></a>servlet的体系结构</h5><p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果</p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/image010.jpg" alt="image010"></p>
<hr>
<p>操作系统</p>
<p>LRU和LFU页面替换算法</p>
<p>LRU是最近最少使用页面置换<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!</p>
<p>LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!</p>
<p>比如,第二种方法的时期T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4</p>
<p>注意,当调页面4时会发生缺页中断</p>
<p>若按LRU算法,应换页面1(1页面最久未被使用) 但按LFU算法应换页面3(十分钟内,页面3只使用了一次)</p>
<p>可见LRU关键是看页面最后一次被使用到发生调度的时间长短,</p>
<p>而LFU关键是看一定时间段内页面被使用的频率!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/Focus-JAVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/Focus-JAVA/" itemprop="url">
                  Focus JAVA
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-17T15:31:48+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-a-b-和-a-equals-b-的区别"><a href="#1-a-b-和-a-equals-b-的区别" class="headerlink" title="1.a == b  和 a.equals(b)的区别"></a>1.a == b  和 a.equals(b)的区别</h4><p>两种情况：如果a,b都是基本类型，a == b直接比较值,不存在a.equals(b)的调用方式</p>
<p>​           如果a,b都是对象引用，a == b判断两个引用是否指向堆中的同一个对象，而a.equals(b)则需要视情况而定，如果类中没有覆盖Object中自带的equals方法，则与a == b相同；如果覆盖该方法，则根据覆盖后的语义进行判断，通常会比较值是否相同</p>
<p>引申：</p>
<h5 id="1-1-Object类包含的方法及作用"><a href="#1-1-Object类包含的方法及作用" class="headerlink" title="1.1    Object类包含的方法及作用"></a>1.1    Object类包含的方法及作用</h5><table>
<thead>
<tr>
<th></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td>hashcode() 和 equals()</td>
<td style="text-align:left">1.符合自反性，传递性，对称性，一致性     2.hashcode默认返回对象在JVM中的内部地址并转成int类型的值  3.equals返回true的两个对象必须拥有相同的hashcode</td>
</tr>
<tr>
<td>wait() 和notify() notifyAll()</td>
<td style="text-align:left">进行线程间的同步</td>
</tr>
<tr>
<td>finalize()</td>
<td style="text-align:left">该对象没有被任何引用时，JVM调用该对象的finalize() 每个对象只会被调用一次</td>
</tr>
<tr>
<td>getClass()</td>
<td style="text-align:left">返回对象的运行时类对象</td>
</tr>
<tr>
<td>clone()</td>
<td style="text-align:left">对象必须实现cloneable接口 默认执行</td>
</tr>
<tr>
<td>toString()</td>
<td style="text-align:left">返回对象的字符串表示     默认是对象的名称和hashcode的十六进制表示</td>
</tr>
</tbody>
</table>
<p>1.1.1 wait()的正确调用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">  <span class="keyword">while</span>(!conditionPredicate())</div><div class="line">      lock.wait(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.1.2equals()的正确写法</p>
<h4 id="2-final-finally-finalize"><a href="#2-final-finally-finalize" class="headerlink" title="2.final finally finalize"></a>2.final finally finalize</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><table>
<thead>
<tr>
<th>JVM final</th>
<th>1.putfield 更新final字段的值时必须处于声明该字段的类的<init>方法中 2.putstatic更新静态final字段时必须在声明该字段的类的<clinit>方法中</clinit></init></th>
</tr>
</thead>
<tbody>
<tr>
<td>修饰方法</td>
<td>1.保证方法不会被重载 2.同意编译器将该方法的调用转为内嵌(inline)调用</td>
</tr>
<tr>
<td>修饰类</td>
<td>保证类不会被继承</td>
</tr>
<tr>
<td>修饰基本类型</td>
<td>基本类型的变量值无法修改</td>
</tr>
<tr>
<td>修饰成员变量</td>
<td>必须直接初始化或者在构造器内部初始化  同时只能保证引用对象的地址不变，内部值可以变化</td>
</tr>
<tr>
<td>修饰局部变量</td>
<td>可以在定义时赋值，也可以随后赋值，但是不能重新赋值</td>
</tr>
</tbody>
</table>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p>finally与try…catch联合使用，保证不管是否抛出异常都需要执行的语句，通常用于资源的释放</p>
<h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h5><p>在对象被回收之前由JVM调<!--待细化--></p>
<h4 id="3-编译期常量"><a href="#3-编译期常量" class="headerlink" title="3.编译期常量"></a>3.编译期常量</h4><p>定义：使用static final修饰的基本类型变量和直接声明的string变量(没有使用new String创建的)</p>
<p>1.编译期常量的访问不会导致类的初始化</p>
<p>2.在编译时期即可确定该变量的值</p>
<h4 id="4-String-StringBuffer-和-StringBuilder"><a href="#4-String-StringBuffer-和-StringBuilder" class="headerlink" title="4.String StringBuffer 和 StringBuilder"></a>4.String StringBuffer 和 StringBuilder</h4><table>
<thead>
<tr>
<th>StringBuffer</th>
<th>可变</th>
<th>与StringBuilder类似，不过使用synchronized修饰方法</th>
<th>线程安全</th>
<th>实现 AbstractStringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>不可变</td>
<td>final修饰类和内部char[]数组</td>
<td>线程安全</td>
<td>实现Comparable接口</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>可变</td>
<td>内部是一个动态增长的char类型的数组 默认为2倍+2，如果仍然不够则视情况增加</td>
<td>非线程安全</td>
<td>实现 AbstractStringBuilder</td>
</tr>
</tbody>
</table>
<p>String.intern()方法</p>
<hr>
<h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h3><p>相对于IO的区别：</p>
<h4 id="1-ByteBuffer"><a href="#1-ByteBuffer" class="headerlink" title="1.ByteBuffer"></a>1.ByteBuffer</h4><p>应用场景：</p>
<p>1.socket通信的数据的传输(读写)</p>
<p>2.访问本地文件内容</p>
<p>包含两种形式：</p>
<p>HeapByteBuffer</p>
<p>DirectByteBuffer 使用Unsafe的api接口操作堆外内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">byteBuffer = ByteBuffer.allocate(N);</div><div class="line"><span class="comment">//读取数据，写入byteBuffer</span></div><div class="line">readableByteChannel.read(byteBuffer);</div><div class="line"><span class="comment">//变读为写</span></div><div class="line">byteBuffer.flip();</div><div class="line"><span class="comment">//读取byteBuffer，写入数据</span></div><div class="line">writableByteChannel.write(byteBuffer);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte[] buff</td>
<td>字节类型的缓冲数组</td>
<td>位于ByteBuffer对象中</td>
</tr>
<tr>
<td>position</td>
<td>新字节的插入位置</td>
<td>the index of the next element to be read or written.  A buffer’s position is never negative and is never greater than its limit.</td>
</tr>
<tr>
<td>mark</td>
<td>标记</td>
<td>the index to which its position will be reset when the reset method is invoked</td>
</tr>
<tr>
<td>capacity</td>
<td>数组的容量</td>
<td>The number of elements it contains.  The capacity of a buffer is never negative and never changes.</td>
</tr>
<tr>
<td>limit</td>
<td>读写的上限</td>
<td>the index of the first element that should not be read or written.  A buffer’s limit is never negative and is never greater than its capacity.</td>
</tr>
</tbody>
</table>
<p>Invariants: mark &lt;= position &lt;= limit &lt;= capacity</p>
<table>
<thead>
<tr>
<th>操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>flip()</td>
<td>将position复位到0，同时将limit设置为当前的position值，mark置为-1</td>
<td>从通道读完数据写到buffer后在进行读取buffer内容之前调用</td>
</tr>
<tr>
<td>clear()</td>
<td>将position复位到0，limit设置为capacity，同时mark置为-1</td>
<td>清空buffer</td>
</tr>
<tr>
<td>rewind()</td>
<td>将position置为0，mark置为-1</td>
<td>buffer内的数据已经读完</td>
</tr>
<tr>
<td>mark() reset()</td>
<td>设置mark为position  设置position为mark</td>
</tr>
</tbody>
</table>
<h5 id="创建ByteBuffer"><a href="#创建ByteBuffer" class="headerlink" title="创建ByteBuffer"></a>创建ByteBuffer</h5><p>1.ByteBuffer buffer=ByteBuffer.allocate(N);        直接分配内存</p>
<p>2.ByteBuffer buffer=ByteBuffer.wrap(byteArray);    对已有的字节数组进行封装</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1、ByteBuffer默认的字节序为大端模式</p>
<p>2、Java API中有ByteOrder类，定义了大端模式和小端模式</p>
<p>3、java.nio.ByteOrder类中的nativeOrder()可以获取当前系统的字节顺序</p>
<h5 id="内存映射缓存区-NIO相对于IO包的区别-通过-FileChannel-类创建"><a href="#内存映射缓存区-NIO相对于IO包的区别-通过-FileChannel-类创建" class="headerlink" title="内存映射缓存区(NIO相对于IO包的区别)  通过 FileChannel 类创建"></a>内存映射缓存区(NIO相对于IO包的区别)  通过 FileChannel 类创建</h5><p><strong><u>基础铺垫：</u></strong></p>
<p>传统的文件I/O操作，通过调用操作系统底层的标准IO系统调用函数read()和write(),此时调用该函数的进程从用户态切换到内核态，OS负责将文件的数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有空间。</p>
<p>内核缓冲区的作用：减少磁盘的IO操作，根据局部性原理，当访问一个文件的某段数据时，很大概率会接着访问相邻的数据，所以OS会在一次read系统调用中预读文件的内容放在缓冲区中，如果继续访问的数据已在缓冲区中，便直接拷贝到进程的私有空间中，从而避免IO操作。</p>
<p>BufferedInputStream中缓冲区作用：因为线程读取内核缓冲区的数据时需要发起系统调用(native的c函数调用)，而系统调用涉及到用户态和内核态的上下文切换，所以缓冲区的作用是为了减少系统调用的次数</p>
<p><strong><em><u>内存映射文件和标准的IO操作的区别在于不需要将从磁盘读取的数据写到OS的内核缓冲区</u></em></strong>，而是<strong>直接将进程的用户私有地址空间中的一部分与文件建立起映射关系</strong>。在进程的虚拟地址空间中有一部分共享库的内存映射区可以用来使用。当进程的代码第一次引用该地址时，触发缺页异常，OS根据映射关系直接将文件的相关数据拷贝到相应的位置。</p>
<p>Java提供三种内存映射模式，只读，读写和专用</p>
<p>只读：顾名思义，不能修改文件</p>
<p>读写：可以修改文件，同时会立刻反应到磁盘文件中，而且别的进程也可以看到最新的修改</p>
<p>专用：OS的写时拷贝原则，在没有写操作的时候，多个进程共享同一块物理内存，一旦某个进程进行写操作时，将受影响的文件拷贝一份到进程的私有缓冲区。</p>
<p>内存映射缓存区属于JVM中的直接缓冲区，可以通过Byte.allocateDirect()进行创建。</p>
<h5 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h5><p>1.所处的区域不同，直接缓冲区的内存分配独立于JVM，使用native接口直接利用OS的内存空间，可用的最大空间通常与OS的虚拟内存空间相关，而非直接缓冲区直接在JVM的堆中分配</p>
<p>2.使用直接缓冲区可以尝试避免拷贝缓冲区内容到临时缓冲区的操作</p>
<hr>
<h4 id="JAVA-集合框架"><a href="#JAVA-集合框架" class="headerlink" title="JAVA 集合框架"></a>JAVA 集合框架</h4><p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/08171028-a5e372741b18431591bb577b1e1c95e6.jpg" alt="08171028-a5e372741b18431591bb577b1e1c95e6"></p>
<hr>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h4><p>1.基于数组实现的，是一个动态数组，其容量能自动增长</p>
<p>​    增长的策略：默认情况下为oldCapacity + (oldCapacity &gt;&gt; 1) </p>
<p>​                如果仍然小于minCapacity直接使用minCapacity</p>
<p>2.非线程安全的</p>
<p>3.数组的初始大小为10，能够存储的最大空间为Integer.MAX_VALUE - 8</p>
<p>4.根据modcount的值判断是否抛出ConcurrentModificationException</p>
<p>5.允许Null元素</p>
<p>6.默认的clone方法为浅拷贝</p>
<p>7.支持迭代器遍历(包括Itr和ListItr两种迭代器)，forEach遍历和随机访问</p>
<h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h4><p>1.内部利用双向链表存储元素，可以作为队列或者栈进行使用</p>
<p>2.包含多套接口，其中</p>
<table>
<thead>
<tr>
<th>peek() 和 poll()</th>
<th>如果队列为空，返回<code>null</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>element() 和 remove()</td>
<td>如果队列为空的话，抛出NoSuchElementException</td>
</tr>
</tbody>
</table>
<p>3.同样可以随机访问，迭代器遍历(ListItr迭代器)</p>
<p>4.查找特定下标的元素时，先判断下标处于链表的前半段还是后半段再遍历</p>
<p>5.允许Null元素</p>
<p><u>!!如何在遍历List的同时删除元素，而且 不抛出ConcurrentModificationException</u></p>
<p><strong>使用Iterator迭代器对list进行遍历，同时使用它iterator提供的方法remove()删除元素</strong></p>
<p><strong>综上：随机访问使用ArrayList  元素频繁插入和删除使用LinkedList</strong></p>
<h4 id="3-Fail-Fast原理"><a href="#3-Fail-Fast原理" class="headerlink" title="3.Fail-Fast原理"></a>3.Fail-Fast原理</h4><p>多个线程访问并修改同一个容器，当一个线程在遍历容器的同时容器的元素被另一个线程修改，则会抛出并发异常</p>
<p>fail-fast机制只是用来检测并发错误的发生，通过比较modCount和迭代器创建时设置的ExpectedModCount的大小</p>
<h4 id="4-CopyOnWriteArrayList"><a href="#4-CopyOnWriteArrayList" class="headerlink" title="4.CopyOnWriteArrayList"></a>4.CopyOnWriteArrayList</h4><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>1.读取容器元素的时候不需要同步机制</p>
<p>2.修改容器的元素时先拷贝一份数组，然后在新的数组中修改</p>
<p>3.迭代器不支持对容器的修改</p>
<h5 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h5><p>1.读取操作远多于修改操作的情况，比如黑名单或者白名单，抑或者定期更新商品类目</p>
<h5 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h5><p>1.写时复制如果数组自身较大，可能会导致频繁的GC操作</p>
<p>所以应该减少扩容的开销，同时批量进行添加新的元素</p>
<hr>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/08221402-aa63b46891d0466a87e54411cd920237.jpg" alt="08221402-aa63b46891d0466a87e54411cd920237"></p>
<p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/Jietu20170317-212150.png" alt="Jietu20170317-212150"></p>
<h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h4><p>1.基于哈希表实现的,每个元素都是一个键值对使用Node类表示</p>
<p>2.因为使用hash方法进行存储，所以通过单链表的形式解决hash冲突</p>
<p>3.非线程安全</p>
<p>4.允许Null的键和值</p>
<p>5.使用两个变量支持容器的扩容，Capacity表示内部bin的数量，loadFactor表示负载因子，当容器内的bin的使用数量达到capacity*loadfactor的大小时，进行自动扩容</p>
<p>默认的初始容量为16，负载因子为0.75，负载因子过高，可以减少空间的浪费，同时提高了hash冲突的可能性，从而降低查询效率。容量过高，可以降低hash冲突，但是无用空间增多</p>
<p>6.每个bin的内部存在两种形式：</p>
<p>1.单链表形式  2.红黑树形式</p>
<p>前提在容器的大小超过64之后，当bin中节点的个数超过8个时，便会从1的形式转化为2，当bin中个数减少为6个时，又从2的形式转化为1.</p>
<p>7.如何确定元素所在的bin下标</p>
<p>首先获取key的hashcode值，如果key为null，直接赋0，否则再与右移16位后的值进行异或，然后与当前容器的大小-1进行与操作，保证其值在[0,len - 1]的范围内</p>
<p>原因是避免当容器的大小偏小时，在经过上述与操作(容器大小的掩码mask)之后增加了hash冲突的可能性</p>
<p>8.容器的大小必须是2的倍数</p>
<p>保证在扩容的时候减少元素的移动，因为在扩容的时候，每个元素只会存在两种选择。</p>
<h4 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2.ConcurrentHashMap"></a>2.ConcurrentHashMap</h4><p>1.迭代器中保持在创建迭代器时的容器状态，所以之后容器被修改，不会抛出并发异常</p>
<p>2.不允许Null元素</p>
<p>3.在最小化update竞争的同时，提供并发可读性</p>
<p>   支持在初始时对空容器的多线程插入</p>
<p>4.三种类型的Node，包括Node,TreeNode,<u><strong>TreeBin,ReservationNode,ForwardNode</strong></u></p>
<p>后面三种特殊的节点hash值为-1，且key和value为null hashcode值的最高位用来表示节点类型</p>
<p>5.当bin为空时，插入新的节点只需要CAS操作即可，当bin不为空的时候，需要锁机制(使用每个bin list的第一个节点)</p>
<p>6.变量<strong>sizeCtl</strong>控制扩容和初始化</p>
<p>-1表示初始化</p>
<p>小于-1表示正在扩容</p>
<p>容器为空的时候，记录初始化的容器大小</p>
<p>否则记录下一次扩容的阈值</p>
<h4 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3.TreeMap"></a>3.TreeMap</h4><p>1.有序的键值对集合，基于红黑树实现</p>
<p>2.非线程安全的</p>
<p>3.排序机制可以基于自然序，或者是给定的Comparator类</p>
<p>4.存在六个通用的接口</p>
<table>
<thead>
<tr>
<th>firstEntry()</th>
<th>中序遍历的第一个节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>lastEntry()</td>
<td>中序遍历的最后一个节点</td>
</tr>
<tr>
<td>lowerEntry()</td>
<td>返回小于当前key的最大entry</td>
</tr>
<tr>
<td>higherEntry()</td>
<td>返回大于当前key的最小entry</td>
</tr>
<tr>
<td>floorEntry()</td>
<td>如果存在key，返回key，否则返回小于当前key的最大entry</td>
</tr>
<tr>
<td>ceilingEntry()</td>
<td>如果存在key，返回key，否则返回大于当前key的最小entry</td>
</tr>
</tbody>
</table>
<p>5.包含两种迭代器，可以进行顺序遍历和逆序遍历</p>
<p>3.1红黑树的特性:</p>
<p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h4 id="4-WeakHashMap"><a href="#4-WeakHashMap" class="headerlink" title="4.WeakHashMap"></a>4.WeakHashMap</h4><p>1.与hashMap的区别在于key的类型是WeakReference的</p>
<p>2.实现原理：基于WeakReference对象和ReferenceQueue队列</p>
<p>2.1.新建WeakHashMap，将“<strong>键值对</strong>”添加到WeakHashMap中。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。</p>
<p>2.2.当<strong>某“弱键”不再被其它对象引用</strong>，并<strong>被GC回收</strong>时。在GC回收该“弱键”时，<strong>这个“弱键”也同时会被添加到ReferenceQueue(queue)队列</strong>中。</p>
<p>2.3.当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是<strong>删除table中被GC回收的键值对</strong></p>
<h4 id="5-LinkedHashMap"><a href="#5-LinkedHashMap" class="headerlink" title="5.LinkedHashMap"></a>5.LinkedHashMap</h4><p>1.在hashMap的基础上添加了两种访问顺序</p>
<p>2.每个bin之间使用指针相连，形成一个双向链表</p>
<p>用于实现LRU缓存算法</p>
<p>1.存在一个接口removeEldestEntry()，在进行put()或者putAll()操作时调用</p>
<p>可以通过覆盖该方法的默认实现,实现自己需要的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; store;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialCapacity = <span class="number">16</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor = <span class="number">0.75f</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> accessOrder = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = <span class="number">1000</span>;  <span class="comment">// 缓存中最多1000个元素</span></div><div class="line">        <span class="keyword">this</span>.store = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(initialCapacity,loadFactor,accessOrder)&#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3834209229668463829L</span>;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> size() &gt; max;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="JAVA的四种引用类型"><a href="#JAVA的四种引用类型" class="headerlink" title="JAVA的四种引用类型"></a>JAVA的四种引用类型</h4><p>1.StrongReference</p>
<p>对象具有强引用时，GC不会回收该对象 </p>
<p>2.SoftReference</p>
<p>当内存空间充足的时候，不会回收该对象，反之则会回收</p>
<p>3.WeakReference</p>
<p>弱引用具有更加短暂的生命周期，GC回收内存时，发现只具有弱引用的对象就会回收</p>
<p>4.PhantomReference</p>
<p>虚引用不决定对象的生命周期，虚引用主要用来跟踪对象被垃圾回收器回收的<!--啥意思--></p>
<p>通常可以使用软引用和弱引用实现缓存</p>
<h4 id="JAVA的Comparator和Comparable"><a href="#JAVA的Comparator和Comparable" class="headerlink" title="JAVA的Comparator和Comparable"></a>JAVA的Comparator和Comparable</h4><hr>
<h4 id="JAVA线程池"><a href="#JAVA线程池" class="headerlink" title="JAVA线程池"></a>JAVA线程池</h4><p><img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/07231601-3ee0f7defe5847289e6e308d1d312ed1.jpg" alt="07231601-3ee0f7defe5847289e6e308d1d312ed1"></p>
<table>
<thead>
<tr>
<th>Executor</th>
<th>提供execute接口执行已提交的任务，将任务的提交和执行进行解耦</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExecutorService</td>
<td>提供结束，提交或者执行的接口</td>
</tr>
<tr>
<td>AbstractExecutorService</td>
<td>提供ExecutorService的默认实现，将提交的任务包装为RunnableFuture</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>提供在执行大量异步任务的时候优化的性能</td>
</tr>
<tr>
<td>ScheduledExecutorService</td>
<td>提供延时和周期执行的服务</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>提供上一个的默认实现</td>
</tr>
<tr>
<td>Executors</td>
<td>静态工厂类，返回各种对象</td>
</tr>
</tbody>
</table>
<h5 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h5><p>1.原子整型ctl包含两个状态：</p>
<p>workerCount        有效的线程个数</p>
<p><u><strong>runState</strong></u>        显示线程池的运行状态        状态位位于最高的3位</p>
<table>
<thead>
<tr>
<th>RUNNING</th>
<th>Accept new tasks and process queued tasks</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHUTDOWN</td>
<td>Don’t accept new tasks, but process queued tasks</td>
</tr>
<tr>
<td>STOP</td>
<td>Don’t accept new tasks, don’t process queued tasks,and interrupt in-progress tasks</td>
</tr>
<tr>
<td>TIDYING</td>
<td>All tasks have terminated, workerCount is zero,the thread transitioning to state TIDYING will run the terminated() hook method</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminated() has completed</td>
</tr>
</tbody>
</table>
<p>2.使用Set存放当前所有的worker线程，通过锁机制进行访问</p>
<p>每个worker线程继承自AbstractQueuedSynchronizer</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/Mysql/" itemprop="url">
                  Mysql
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-16T09:20:22+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql知识点总结"><a href="#Mysql知识点总结" class="headerlink" title="Mysql知识点总结"></a>Mysql知识点总结</h1><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>涉及两个层面的控制：服务器层和存储引擎层</p>
<p>锁策略：在锁的开销和数据的安全性之间寻求平衡  同时需要根据特定的场景进行选取</p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a><strong>锁粒度</strong></h4><p>在mysql中涉及到的对象 数据库 表 属性 行记录</p>
<p><strong>表锁</strong> 即锁定整张表 此时不会发生死锁</p>
<p>用户在对表进行写操作的时候，需要获取写锁，此时会阻塞其他用户对表的所有读写操作 读锁不会相互阻塞</p>
<p><strong>行级锁</strong> 只在存储引擎层实现</p>
<p><strong>页面锁 </strong>与行级锁都会出现死锁</p>
<h4 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a><strong>死锁</strong>：</h4><p>含义：死锁指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环 </p>
<p>如何产生:</p>
<p>1.多个事务试图以不同的顺序锁定资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">start TRANSACTION;  #1</div><div class="line">update stockPrice set close = 20 where stockid = 2</div><div class="line">update stockPrice set close = 30 where stockid = 3</div><div class="line">commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">update stockPrice set close = 30 where stockid = 3</div><div class="line">update stockPrice set close = 20 where stockid = 2</div><div class="line">commit;</div></pre></td></tr></table></figure>
<p>解决方式：加锁顺序保持一致</p>
<p>2.使用事务插入新行  两个事务同时插入新的行  <!--好像没有死锁啊--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#第一种情况：假设当前该表的主键值的范围为1-1000</div><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 1020 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1020);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id = 1022 for update;</div><div class="line">④ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1022);</div><div class="line">#commit;</div><div class="line">#这种情况下，如果事务1未执行commit，则事务2无法执行insert操作，因为事务1使用gap锁将(1000,正无穷)进行锁定</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#第二种情况：假设当前该表的主键值的范围为1-1050</div><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 1020 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1020);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id = 1060 for update;</div><div class="line">④ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1060);</div><div class="line">#commit;</div><div class="line">#这种情况下，如果事务1未执行commit，则事务2也可以执行insert操作，因为事务1使用gap锁将(1,1000)进行锁定,不会影响到事务2的key值</div></pre></td></tr></table></figure>
<p>3.多个事务同时锁定一个资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 20 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,18);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id &lt; 30 for update;</div><div class="line">#commit;</div><div class="line"></div><div class="line">#按执行顺序来看，首先事务1锁定键为20的行，然后事务2锁定键为1-19的行，此时事务1需要锁定键为18的行，发生死锁</div></pre></td></tr></table></figure>
<p>死锁检测和死锁超时机制：</p>
<p>InnoDB：将持有最少行级排它锁的事务进行回滚</p>
<hr>
<p>schema和数据类型优化</p>
<p>添加计数表和汇总表<!--：待查询--></p>
<p>1.尽量使用可以正确存储数据的最小数据类型</p>
<p>2.尽量避免Null 对MyISAM来说，可为Null的列需要更多的存储空间，索引的构建也更加复杂</p>
<p>3.</p>
<hr>
<h3 id="mysql加锁机制"><a href="#mysql加锁机制" class="headerlink" title="mysql加锁机制"></a>mysql加锁机制</h3><hr>
<h3 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h3><p><strong>事务</strong>：一组原子性的sql查询 用户可以根据业务是否需要事务处理来选择合适的存储引擎</p>
<p>为什么要使用事务：</p>
<p>1.提供一种从失败中恢复的可靠机制，同时在系统故障的时候摆正数据的一致性</p>
<p>2.为并发访问数据库提供隔离机制</p>
<h5 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a><strong><u><em>ACID</em></u></strong>特性</h5><p>原子性：事务可以视为不可分割的最小工作单元，要么全部成功，要么执行回滚(全部失败)</p>
<p>一致性：从一个一致的状态转移到另一个一致的状态 (可以举在A,B之间转账的例子)</p>
<p>隔离性：一个事务所做的修改在提交之前，对其他事务不可见，即对个并发的事务不会相互影响</p>
<p>持久性：一旦事务提交，相应的修改永久保存在数据库之中</p>
<h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><strong>隔离级别</strong></h5><p><u>read uncommitted</u></p>
<p>事务A未提交，但是其中的修改可以对其他事务可见</p>
<p><u>read committed</u></p>
<p>事务从开始到提交之前，包含的修改对其他事务不可见</p>
<p><u>repeatable read</u> –Mysql默认级别</p>
<p>保证在同一个事务之中多次执行同样的读取记录的结果是一致的</p>
<p><u>serializable</u></p>
<p>强制事务串行执行，对读取的每一行数据都进行加锁</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read committed</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Read uncommited</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>serializable</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<h5 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a><strong>事务日志</strong></h5><p>1.事务型存储引擎 InnoDB NDB Cluster</p>
<p>2.自动提交 在不使用事务的时候，mysql默认视每个sql语句为一个事务</p>
<p>​    部分语句会强制触发commit语句的执行</p>
<p>3.查看事务隔离级别：  select @@tx_isolation</p>
<p>4.设置事务隔离级别     set session(global) transaction isolation level XXXX</p>
<p><strong>SavePoint</strong></p>
<p>Mysql逻辑架构    </p>
<p><img src="/Users/wuxinyua/Desktop/0_1314877463Mm91.gif" alt="0_1314877463Mm91"><img src="/Users/wuxinyua/Desktop/Jietu20170317-150337.png" alt="Jietu20170317-150337"></p>
<p>架构主要分为三层</p>
<p>第一层负责连接处理(线程池获取线程，一个连接对应一个线程)，授权认证，安全等</p>
<p>第二层包括查询解析，分析优化，缓存 所有跨存储引擎的功能在这一层实现(触发器，存储过程，视图)</p>
<p>在内部创建解析树，包括语法解析和词法解析，进行各种优化</p>
<p>第三层为存储引擎，负责数据的存储和提取</p>
<p><strong>Session 和Connection 事务</strong></p>
<p>session是通信双方从开始通信到通信结束的一个上下文环境，记录连接的相关信息</p>
<p>connection是从客户端到数据库的一条物理连接路径</p>
<p>session和connection是同时建立的，两者是对同一事件不同层次的描述，有点类似OSI分层中的传输层和会话层</p>
<p>一个连接可以进行多次会话，一个会话可以不依赖于某个连接</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>读锁(共享锁)</p>
<p>写锁(排它锁)</p>
<p>如何设置锁定模式：</p>
<p>1.select …… lock in share mode</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>索引的实现通常使用B树及其变种B+树</strong></p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>第二，可以大大加快数据的检索速度</p>
<p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p><strong>需要创建索引的列：</strong></p>
<p>1.在经常需要搜索的列上，可以加快搜索的速度；</p>
<p>2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p>
<p>3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p>
<p>4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p>
<p>5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<h5 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h5><p><strong>唯一索引</strong> 唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>
<p><strong>主键索引</strong>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>
<p><strong>聚集索引</strong>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h4 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B+Tree索引的性能分析"></a>B+Tree索引的性能分析</h4><p>到这里终于可以分析B+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。</strong>一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>1）B树</p>
<p>B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。</p>
<p>成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。</p>
<p>在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。</p>
<p>2）B+树</p>
<p>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引是稀疏索引。</p>
<p>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>所以 B+树有两种搜索方法：</p>
<p>一种是按叶节点自己拉起的链表顺序搜索。</p>
<p>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</p>
<p>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>这两种处理索引的数据结构的不同之处：<br>a，B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。<br>b，因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。<br>c，B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a><strong>分区表</strong></h4><p>将数据按照较粗的粒度分布在不同的物理子表当中</p>
<p>1.在创建表的时候使用partition by子句定义每个分区存放的数据</p>
<p>2.在执行查询的时候，优化器根据分区定义过滤没有需要数据的分区</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a><strong>使用场景:</strong></h5><p>1.表的数据量大于可用的内存，或者表中的部分数据为热点数据</p>
<p>优势：可以以分区为单位进行维护，备份和恢复。不同分区的数据可以分布在不同的物理设备上</p>
<p>局限性：无法使用外键约束 最多只能有1024个分区</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图只是一种逻辑对象，是一种虚拟表，它并不是物理对象，因为视图不占物理存储空间，在视图中被查询的表称为视图的基表，大多数的select语句都可以用在创建视图中</p>
<p>优点：集中用户使用的数据，掩盖数据的复杂性，简化权限管理以及为向其他应用程序输出而重新组织数据等等</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>当有操作影响到触发器保护的数据时，触发器就自动发生，因此，触发器是在特定表上进行定义的，该表也称为触发器表，也是一种特殊类型的存储过程，与存储过程的区别：<u><strong>存储过程可以由用户直接调用执行，但是触发器不能被直接调用执行</strong></u></p>
<p>触发器的类型：insert类型，update类型，delete类型</p>
<p>语法：   create trigger trigger_name</p>
<p>　　　　on {table |view}</p>
<p>　　　　with encryprion</p>
<p>　　　　{for|after|instead of}{[delete][,][insert][,][update]}</p>
<p>　　　　as sql _statement</p>
<p>工作原理：</p>
<p>（insert）当向表中插入数据时，insert触发器触发执行，当insert触发器触发时，新的记录增加到触发器表中和inserted表中。触发器可以检查inserted表，来确定该触发器的操作是否应该执行和如何执行，在inserted表中的那些记录，总是触发器表中一行或多行记录的冗余；</p>
<p>（delete）当触发一个delete触发器时，被删除的记录放置在一个特殊的deleted表中。deleted表是一个逻辑表，用来保存已经从表中删除的记录；</p>
<p>（update）修改一条记录就等于插入一条新记录和删除一条旧记录，当在某一个update触发器表的上面修改一条记录时，表中原来的记录移动到deleted表中，修改过的记录插入到了inserted表中，触发器可以检查deleted表和inserted表以及被修改的表。</p>
<h4 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h4><p>存储过程是存储在服务器上的一组预编译的Transact-SQL语句，存储过程是一种封装重复任务操作的一种方法，支持用户提供的变量，具有强大的编程功能</p>
<p>优点：与其他应用程序共享应用程序的逻辑，因此确保一致的数据访问和操纵</p>
<p>   　　提供一种安全机制</p>
<p>　　　加速存储过程的执行，提高系统的性能</p>
<p>　　　减少网络交通</p>
<p>存储过程的类型：系统存储过程、本地存储过程、临时存储过程、远程存储过程和扩展存储过程。不同类型的存储过程具有不同的作用</p>
<p>语法：    create procedure procedure_name</p>
<p>　　　　 @parameter data_type</p>
<p> 　　　   with{recompile|encryption|recompile,encryption}</p>
<p>　　　    as sql_statement<br>执行存储过程有两种方法：</p>
<p>方法一：直接执行存储过程，就是调用execute语句来执行存储过程</p>
<p>方法二：在insert语句中执行存储过程</p>
<h4 id="应用层优化"><a href="#应用层优化" class="headerlink" title="应用层优化"></a>应用层优化</h4><p>问题：1.应用创建的数据库连接是否过多？是否使用了连接池？</p>
<p>​        2.应用是否在处理应该有数据库处理的事情？</p>
<p>​        3.应用是否在不使用的时候还保持连接打开？</p>
<p>思路：</p>
<p>1.缓存代理服务器</p>
<p>​    被动缓存  缓存未命中时返回空 memcached</p>
<p>​    主动缓存  访问未命中时将请求转发给应用来生成请求结果，然后存储该结果  squid</p>
<p>2.硬件负载均衡器</p>
<h4 id="mysql查询优化"><a href="#mysql查询优化" class="headerlink" title="mysql查询优化"></a>mysql查询优化</h4><p>数据库连接池</p>
<p>数据库索引</p>
<p>单点失效</p>
<p>负载均衡</p>
<h4 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h4><p><strong>原因：</strong></p>
<p>1.灾难恢复 硬件故障，操作失误，黑客攻击</p>
<p>2.测试  将备份文件还原到测试服务器上方便测试最新的额生产环境数据</p>
<p>3.需求发生变化，需要还原</p>
<p><strong>规划备份和恢复策略需要考虑的问题</strong></p>
<p>—-复制不是备份，使用RAID阵列也不是备份</p>
<p>1.可以容忍丢失多少数据量</p>
<p>2.恢复时间需要多长，备份数据需要多久</p>
<p>3.恢复的时候是否需要持续提供服务</p>
<p>4.恢复的对象是整个库，还是当个表</p>
<p>5.备份操作对服务器性能的影响</p>
<p><strong>备份类型</strong></p>
<table>
<thead>
<tr>
<th>数据库是否离线</th>
<th>冷备份</th>
<th>需要关闭mysql服务，不允许读写请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.根据业务需求选择  2. MyISAM不支持热备份，InnoDB支持</td>
<td>热备份</td>
<td>备份的同时，持续提供服务   <strong>文件系统快照</strong></td>
</tr>
<tr>
<td></td>
<td>温备份</td>
<td>备份的时候只允许读请求，不支持写请求</td>
</tr>
<tr>
<td>备份的数据范围</td>
<td>完全备份</td>
<td>备份完全的数据</td>
</tr>
<tr>
<td></td>
<td>增量备份</td>
<td>基于任意备份的基础，对更新的数据进行备份</td>
</tr>
<tr>
<td></td>
<td>差异备份</td>
<td>基于完全备份的基础，对更新的数据进行备份</td>
</tr>
<tr>
<td>备份的类型</td>
<td>物理备份</td>
<td>优点：1.可以直接复制存放在磁盘上的文件  2.恢复速度快                  缺点：物理备份不一定可以跨平台</td>
</tr>
<tr>
<td></td>
<td>逻辑备份</td>
<td>备份结果为 mysql可以解析的格式                                                                                                    优点：1.可以使用编辑器查看数据       2.可以通过网络来备份和恢复          3.与存储引擎无关                                    缺点：1.恢复速度慢，需要mysql加载解析语句，转化存储格式 2.浮点数的精度出现偏差  3.必须由数据库服务器完成备份</td>
</tr>
</tbody>
</table>
<p>建议混合使用物理备份和逻辑备份，先使用物理复制，以此数据启动mysql服务器实例并运行mysqlcheck，然后周期性的使用mysqldump之下就那个逻辑备份</p>
<p>增量备份和差异备份的区别：</p>
<p>1.差异备份是对上次全备份之后所有改变的部分进行备份，增量备份从任意类型的上次备份后所有的修改进行备份</p>
<p><strong>备份对象</strong></p>
<p>1.数据，配置文件，代码(存储过程，触发器，存储函数)，OS的相关配置，复制的相关配置，二进制日志，事务日志等</p>
<p><strong>备份和恢复的实现</strong><!--模拟一次实现--></p>
<h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><h4 id="语句类型"><a href="#语句类型" class="headerlink" title="语句类型"></a>语句类型</h4><table>
<thead>
<tr>
<th>DDL</th>
<th>数据定义语言</th>
<th>create,drop,alter</th>
</tr>
</thead>
<tbody>
<tr>
<td>DML</td>
<td>数据操纵语言</td>
<td>insert,delete,update,select</td>
</tr>
<tr>
<td>DCL</td>
<td>数据控制语言</td>
<td>grant，revoke</td>
</tr>
</tbody>
</table>
<h5 id="DDL、DML、DCL"><a href="#DDL、DML、DCL" class="headerlink" title="DDL、DML、DCL"></a>DDL、DML、DCL</h5><table>
<thead>
<tr>
<th>create DATABASE dbname;</th>
<th>创建数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>drop DATABASE</strong> dbname;</td>
<td>删除数据库</td>
</tr>
<tr>
<td><strong>create TABLE tablename</strong>(col_name,col_type,contraints,…. key `alias`(col_name)) ENGINE=”” CHARSET=””</td>
<td>创建表</td>
</tr>
<tr>
<td><strong>desc</strong> tablename;</td>
<td>描述表</td>
</tr>
<tr>
<td><strong>drop TABLE</strong> tablename;</td>
<td>删除表</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>MODIFY/CHANGE</strong> col_name column_def [<strong>FIRST/AFTER</strong> col_name];</td>
<td>更改表中的列定义</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>ADD</strong> [<strong>COLUMN</strong>] col_name [<strong>FIRST/AFTER</strong> col_name];</td>
<td>添加列到指定表</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>DROP [COLUMN]</strong> col_name;</td>
<td>在指定表中删除列</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>RENAME[TO]</strong> new_tablename;</td>
<td>更改表名</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>insert into tablename(field,..) into values(val,…)</th>
<th>插入数据</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>update</strong> tablename <strong>set</strong> field=val,… <strong>[where condition]</strong></td>
<td>更新数据</td>
</tr>
<tr>
<td><strong>delete from</strong> tablename <strong>[where condition]</strong></td>
<td>删除数据</td>
</tr>
<tr>
<td><strong>select * from</strong> tablename <strong>[where condition]</strong>[group by field…][order by field..][desc\</td>
<td>asc][limit offset,count][with ROLLUP][HAVING condition]</td>
<td>选择数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>grant priviledges on dbname.*/tname to ‘user’@’ip’ identified by ‘passwd’;</th>
<th>授权</th>
</tr>
</thead>
<tbody>
<tr>
<td>revoke priviledges on dbname.*/tname from ‘user’@’ip’</td>
<td>撤回权限</td>
</tr>
</tbody>
</table>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型用来指定存储格式，约束和有效范围</p>
<h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><table>
<thead>
<tr>
<th style="text-align:left">整数类型</th>
<th>tinyint,smallint,mediumint,int,bigint  [1,2,3,4,8]</th>
<th>小括号内的数字表示指定的显示宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">浮点类型</td>
<td>float,double</td>
<td>浮点数不写精度和标度的时候，根据实际值显示，如果指定后，自动进行四舍五入知之后的结果插入</td>
</tr>
<tr>
<td style="text-align:left">定点数类型</td>
<td>dec(m,d),decimal(m,d) [M+2]</td>
<td><strong>m表示有效数字的位数，d表示小数点之后的位数</strong>。decimal在不指定精度时，默认为(10,0)</td>
</tr>
<tr>
<td style="text-align:left">位类型</td>
<td>bit(m)</td>
<td>存放位字段值，必须使用<strong>bin()或者hex()函数查看结果</strong></td>
</tr>
</tbody>
</table>
<h5 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h5><table>
<thead>
<tr>
<th>date</th>
<th>显示年月日</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>datetime</td>
<td>显示年月日，时分秒</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>显示时分秒</td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td>显示时间戳，可以返回字符串或者数值</td>
<td>1、需要经常插入或者更新日期为当前系统时间，2、和时区相关，插入日期时，先转换为本地的时区后存放。3、支持的时间范围比较小</td>
</tr>
<tr>
<td>year</td>
<td>显示年份</td>
</tr>
</tbody>
</table>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><table>
<thead>
<tr>
<th>char(M)</th>
<th>长度固定</th>
<th>M为0-255，字节为单位，检索时char类型删除末尾的空格，varchar保留空格</th>
</tr>
</thead>
<tbody>
<tr>
<td>varchar(M)</td>
<td>变长字符串</td>
<td>M为0-65535</td>
</tr>
<tr>
<td>tinyblob/blob/mediumblob/longblob</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tinytext/text/mediumtext/longtex</td>
<td></td>
<td></td>
</tr>
<tr>
<td>varbinary/binary</td>
<td></td>
<td>0-M的变长/定长二进制字符串</td>
</tr>
<tr>
<td>enum</td>
<td></td>
<td>枚举类型，最多保存65535个成员，每次只允许从值集合中选取单个值</td>
</tr>
<tr>
<td>set</td>
<td></td>
<td>可以包含0-64个成员，每次可以一次选取多个成员</td>
</tr>
</tbody>
</table>
<p>char和varchar：</p>
<p>1、保存方式不同 char使用固定长度的字符类型，varchar使用可变长度的字符类型</p>
<p>​    固定长度的优势在于处理速度更快，但是浪费存储空间</p>
<p>2、检索方式不同，char会自动删除尾部的空格</p>
<p>3.不同的数据引擎选择不同，MyISAM建议使用固定长度的数据列，InnoDB建议使用varchar</p>
<p>text和blob：</p>
<p>1、blob可以保存二进制文件，text只能保存字符数据</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h3 id="如何生成分布式系统中唯一的ID"><a href="#如何生成分布式系统中唯一的ID" class="headerlink" title="如何生成分布式系统中唯一的ID"></a>如何生成分布式系统中唯一的ID</h3><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在分布式系统中存在多个Shard的场景中，同时在各个Shard插入数据，如何给数据生成全局的唯一ID？</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1.全局唯一性</p>
<p>2.数据在多个shard之间进行迁移的时候不收到ID生成方法的限制</p>
<p>3.生成的ID包含时间信息</p>
<p>4.ID的长度最好不要超过64位</p>
<p>5.生成ID的速度应该达到一定的要求，比如10万+/秒</p>
<p>6.服务不存在<strong><u>单点</u></strong>   性能和可靠性</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>1.Twitter的Snowflake</strong></p>
<p>UniqueID ：0    +    41bits         +                    10bits                             + 12bits</p>
<p>​                     时间戳                节点ID(data center ID + worker ID)               序列号</p>
<ol>
<li>10bits的节点ID，可以在ID分配worker启动的时候，从Zookeeper集群获取</li>
<li>12bits的序列号根据时间戳进行一下操作<ol>
<li>如果当前的时间戳和上一个已生成ID的时间戳相同，使用前一个序列号+1，如果本毫秒内的序列号使用完毕，等待下一毫秒继续</li>
<li>如果当前的时间戳大于前一个ID的时间戳，随机生成一个序列号作为本毫秒中的第一个序列号</li>
</ol>
</li>
</ol>
<p><strong><u>异常情况</u></strong></p>
<p>如果当前获取的时间戳小于前一个ID的时间戳？</p>
<p>继续获取系统的时间戳直到大于前一个ID的时间戳</p>
<p><strong>2.Boundary flake</strong></p>
<p>ID：    64bits         +         48bits         +        16bits</p>
<p>​        时间戳                worker ID            序列号</p>
<p>优势：1.序列号的bits位增多可以减小冲突的概率</p>
<p>​        2.workID使用48bits可以直接利用机器的Mac地址 从而起到去中心化的目的</p>
<p><strong>3.instagram</strong></p>
<p>UniqueID :     41bits         +         13bits            +             10bits</p>
<p>​            时间戳                logic shard的编号                序列号</p>
<p>分布式存储方案：</p>
<p>1.将table横向拓展，划分为多个逻辑分片(logic shard)</p>
<p>2.规定每个逻辑分片存储到对已经的数据库实例上</p>
<p>3.每个table指定一个字段作为分片字段</p>
<p>4.插入数据时根据分片字段的值决定数据分配到相应的逻辑分片</p>
<p>5.根据逻辑分片和数据库实例的映射关系确定插入的数据库实例</p>
<p>–序列号利用postgreSQL的auto increment sequence 生成然后对2^10取模</p>
<p>优势：1.利用逻辑分片可以去中心化</p>
<p>​        2.通过ID可以直接知道记录被存放在哪个逻辑分片上</p>
<p>​        3.方便进行数据迁移</p>
<h3 id="数据库拓展"><a href="#数据库拓展" class="headerlink" title="数据库拓展"></a>数据库拓展</h3><h4 id="垂直拓展"><a href="#垂直拓展" class="headerlink" title="垂直拓展"></a>垂直拓展</h4><h4 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h4><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><p>高可用性是在宕机造成的损失和降低宕机时间花费的成本之间取平衡点</p>
<h5 id="造成数据库宕机可能的原因"><a href="#造成数据库宕机可能的原因" class="headerlink" title="造成数据库宕机可能的原因"></a>造成数据库宕机可能的原因</h5><p>1.磁盘的空间耗尽</p>
<p>2.性能问题，运行糟糕的sql操作，服务器bug</p>
<p>3.糟糕的schema和索引设计</p>
<p>4.复制问题，主备数据不一致</p>
<p>5.数据丢失问题，误删操作</p>
<p>提高高可用性</p>
<p>1.提升平均的失效时间</p>
<p>​    正确的监控Mysql的信息   为常见的失败情况制定对应的计划  测试所有的schema和sql语句</p>
<p>2.降低平均恢复时间</p>
<p>​    建立冗余，进行故障转移，避免单点失效</p>
<h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>1.为海量的前台数据提供高性能，大容量，高可用性的访问</p>
<p>2.为数据变更的消费者提供准实时的保障</p>
<p>3.高效的异地数据同步</p>
<h3 id="单点登录-分布式Session"><a href="#单点登录-分布式Session" class="headerlink" title="单点登录 + 分布式Session"></a>单点登录 + 分布式Session</h3><p>实现多系统应用群的登录，在多系统中登录一个系统，便可以在其他所有的系统中得到授权而无需再次登录</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡用来在多个计算机，网络连接，CPU，磁盘驱动器等其他资源中分配负载，达到资源的最佳化使用，最大化吞吐率，最小化响应时间，避免过载，同时通过冗余提高可靠性</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>NoSQL的文档数据库</p>
<p>文档由键值对的集合组成，也是数据库数据的基本单元</p>
<p>优点：</p>
<p>1.灵活的数据模型，没有预定义的数据模式(schema)</p>
<p>2.性能</p>
<p>3.可拓展性和可靠性</p>
<p>4.非阻塞式的异步IO drivers</p>
<p>5.服务端的脚本XX.js</p>
<p>缺点：</p>
<p>1.不支持事务</p>
<p>2.没有触发器</p>
<p>3.不自动进行磁盘清理</p>
<h5 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a><strong>Hardware</strong></h5><ul>
<li>Ensure your working set fits in RAM</li>
<li>Use compression</li>
<li>Run single MongoDB per server.</li>
<li>Use SSDs for write-heavy applications</li>
</ul>
<h5 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a><strong>Data Model</strong></h5><ul>
<li>Store all data for a record in a single document.</li>
<li>Avoid large documents</li>
<li>Avoid unnecessarily long field names.</li>
<li>Eliminate unnecessary indexes.</li>
<li>Remove indexes that are prefixes of other indexes.</li>
</ul>
<h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h5><ul>
<li>Updates only modified fields.</li>
<li>Avoid negation in queries</li>
<li>Run explain() for every complex query.</li>
<li>Use covered queries when possible.</li>
<li>Use bulk inserts when needed.</li>
</ul>
<h5 id="Setup-and-Configuration"><a href="#Setup-and-Configuration" class="headerlink" title="Setup and Configuration"></a><strong>Setup and Configuration</strong></h5><ul>
<li>Have at least one secondary and one arbiter.</li>
<li>Set write concern to 2 when the data critical.</li>
<li>Have daily dump of data for backup.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/Java-关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/Java-关键字/" itemprop="url">
                  Java 关键字
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-15T22:44:27+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="同步-1-synchronized-2-volatile-3-lock-4-AtomicXX"><a href="#同步-1-synchronized-2-volatile-3-lock-4-AtomicXX" class="headerlink" title="同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX"></a><strong>同步: 1.synchronized     2.volatile     3.lock     4.AtomicXX</strong></h4><p>参考链接：<a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5405678.html</a></p>
<hr>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>含义：volatile修饰变量 保证对变量的读取是对该变量最后一次的写入 即不会读取该变量的缓存</p>
<p>首先了解一下线程安全的概念：</p>
<p>当多个线程访问同一个类的时候，不用考虑线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方法不必作其他的协调，类的行为仍然是正确的，则类是线程安全的</p>
<p>原子性:一个操作要么执行完成，要么没有执行</p>
<p>可见性: 对一个变量的读，总是能看到（任意线程）对这个变量最后的写入</p>
<p><strong>volatile修饰的变量具有可见性</strong></p>
<p>如何保证该特性的实现：</p>
<p>在操作该变量的指令前后插入四种类型的内存屏障来禁止指令的重排序  保证<strong>happens-before原则</strong></p>
<p><em><u>使用条件</u></em>保证线程安全：</p>
<p>1.对变量的写操作不依赖于当前值</p>
<p>2.变量不在具有其他变量的不变式当中</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景</strong>：</h4><p>1.作为简单的状态标志  </p>
<hr>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>可以修饰代码块或者方法</p>
<p>如何实现：</p>
<p>对象具有监视器锁(monitor) 只有获取该对象的锁之后才能访问对应的代码块或者方法</p>
<p>通过锁定和释放对象关联的监视器锁实现</p>
<p>synchronized修饰<u>代码块</u>的时候对应于虚拟机中的指令为：monitorenter 和 monitorexit</p>
<p>synchronized修饰<u>方法</u>的时候方法对应的ACC_SYNCHRONIZED标志被设定</p>
<h4 id="Deeper…"><a href="#Deeper…" class="headerlink" title="Deeper…"></a>Deeper…</h4><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的</p>
<p>操作系统实现线程之间的切换这就需要从用户态转换到核心态</p>
<p>锁包含偏向锁、轻量级锁和重量级锁，随着锁的竞争程度进行升级</p>
<h5 id="volatile和synchronized的区别："><a href="#volatile和synchronized的区别：" class="headerlink" title="volatile和synchronized的区别："></a><strong><em><u>volatile和synchronized的区别：</u></em></strong></h5><p>1.volatile修饰变量，synchronized修饰代码块或者方法</p>
<p>2.volatile保证变量的可见性，synchronized保证一组操作的原子性和变量的可见性</p>
<hr>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="锁的两种特性："><a href="#锁的两种特性：" class="headerlink" title="锁的两种特性："></a>锁的两种特性：</h4><p>1.<strong>互斥</strong>            一次只允许一个线程持有某个特定的锁，保证共享数据在同一时刻只有一个线程可以访问</p>
<p>2.<strong>可见性</strong>      确定锁释放之前对共享数据的修改对于随后获取该锁的另一个线程可见</p>
<h5 id="正确的使用方式："><a href="#正确的使用方式：" class="headerlink" title="正确的使用方式："></a>正确的使用方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock();</div><div class="line">...</div><div class="line">lock.lock();</div><div class="line">try&#123;</div><div class="line">  .....</div><div class="line">&#125;finally&#123;</div><div class="line">  lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="基本锁的获取过程"><a href="#基本锁的获取过程" class="headerlink" title="基本锁的获取过程"></a>基本锁的获取过程</h5><p>1.读取表示锁状态的变量</p>
<p>2.如果锁的状态为0，则通过CAS操作置为1 多个线程竞争时，只有一个线程成功</p>
<p>​    2.1获取锁成功</p>
<p>​        2.1.1如果线程位于等待锁的队列中 出列</p>
<p>​    2.2获取失败，进入队列，同时处于阻塞状态</p>
<p>3.如果锁状态为1，进入队列，处于阻塞状态</p>
<h5 id="释放锁过程"><a href="#释放锁过程" class="headerlink" title="释放锁过程"></a>释放锁过程</h5><p>1.锁的状态置为1，同时唤醒等待锁队列中的队首节点</p>
<p>2.被唤醒的线程(处于就绪状态)和未进入队列且准备获取锁的线程进行竞争，当处于队列中的线程竞争到锁之后才移出队列</p>
<p>可重入锁的类型： 公平锁和非公平锁</p>
<p>简单说一下区别：如果当前的锁为公平锁，则线程需要判断监视器锁的队列中是否有线程，如果有的话要先入队列</p>
<p>​            如果是非公平锁，则不需要判断队列是否为空，可以直接竞争锁</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><h5 id="ReentrantReadWriteLock-当主要操作为读访问时，可以使用提供性能"><a href="#ReentrantReadWriteLock-当主要操作为读访问时，可以使用提供性能" class="headerlink" title="ReentrantReadWriteLock  当主要操作为读访问时，可以使用提供性能"></a>ReentrantReadWriteLock  当主要操作为读访问时，可以使用提供性能</h5><p>读写锁：可以同时被多个读进程访问，或者被一个写进程访问</p>
<h4 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h4><p>1.提供和Object对象中类似的    <u>wait()</u>    和    <u>notify()</u>    和    <u>notifyAll()</u>    接口</p>
<p>​                            await()    和    signal()   和    signalAll()</p>
<p>condition内部维护一个队列，队列中包含由于自身调用await()方法阻塞的线程</p>
<h5 id="await-过程："><a href="#await-过程：" class="headerlink" title="await()过程："></a>await()过程：</h5><p>1.进入condition维护的队列</p>
<p>2.释放监视器锁</p>
<p>3.阻塞自身线程</p>
<p>(线程A调用 signalAll() 后)线程B被唤醒后：</p>
<p>1.此时线程已经从condition的队列中转移到监视器锁的队列中，尝试获取锁</p>
<p>​    1.1.成功则从await()方法中返回</p>
<p>​    1.2 否则继续阻塞在await()方法中</p>
<p><strong><u>Attention</u></strong>：wait/notify等方法依赖于monitor对象，所以只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因</p>
<h5 id="正确的使用方式：-1"><a href="#正确的使用方式：-1" class="headerlink" title="正确的使用方式："></a>正确的使用方式：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">  <span class="keyword">while</span>(!conditionPredicate())</div><div class="line">      lock.wait(); <span class="comment">//condition.await();</span></div><div class="line">  <span class="comment">//开始执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong><em>lock和synchronized的区别</em></strong>：</u></p>
<p>1.lock加锁和解锁通过java代码调用<strong>native的CAS</strong>方法实现(基于类库)，synchronized通过<strong>JVM实现加锁和解锁</strong></p>
<p>2.synchronzied的使用方法比较单一，多个线程竞争锁的时候，竞争失败的锁处于阻塞状态，不能中断正在等待获取锁的线程</p>
<p>   lock锁提供多个特性的方法，包括超时机制，可中断机制，可轮询机制等</p>
<p>​    2.1可轮询：需要获取多个锁的情况  在只能获取到部分锁的时候释放已获取到的锁</p>
<p>​    2.2可定时：具有时间限制的情况</p>
<p>​    2.3可中断：活动可取消的场景</p>
<p>​    2.4公平队列 竞争机制</p>
<p>3.不同于条件队列()和内部锁，lock内部可以包含多个Condition对象  <!--啥意思--></p>
<p>4.可重入读写锁可以提供锁的共享模式(读锁)</p>
<p>当内部锁收到局限时，lock提供可选择的高级特性</p>
<hr>
<h3 id="JAVA中线程的状态"><a href="#JAVA中线程的状态" class="headerlink" title="JAVA中线程的状态"></a>JAVA中线程的状态</h3><p>public enum State{    //线程在虚拟机的状态，跟操作系统的线程状态不同</p>
<p>​    new        未启动的线程 即为调用thread.start()方法</p>
<p>​    runnable    处于可运行状态的线程，处于就绪状态，可能正在等待操作系统分配CPU或者其他资源</p>
<p>​    blocked        正在等待获取监视器锁的线程 可能正要进入同步代码块或者方法，也可能从Object.wait()方法返回再次竞争进入同步区</p>
<p>​    waiting        当线程自身调用Object.wait(),Thread.join(),LockSupport.park()方法进入等待状态 同时不带有超时参数</p>
<p>​    time_waiting  当线程自身调用与上述类似的方法且带有超时参数时，处于时等状态</p>
<p>​    terminated    线程结束执行后，处于结束状态</p>
<p>​    <!--实际上应该还有running状态：线程获取到cpu之后开始执行--></p>
<p>}</p>
<p>三种非同步的方法改变线程的状态：</p>
<p>1.sleep(time) 使得线程进入睡眠状态 此时拥有锁的线程不释放锁</p>
<p>2.join()        使得线程等待子线程执行结束后再执行</p>
<p>3.yield()         当前线程让出cpu，同时状态变为runnable状态</p>
<hr>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><hr>
<h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><hr>
<h3 id="并发的数据结构"><a href="#并发的数据结构" class="headerlink" title="并发的数据结构"></a>并发的数据结构</h3><hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。</p>
<p>　　如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：</p>
<h2 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h2><p>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h2 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h2><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h2 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h2><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
<h2 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h2><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<p>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h2 id="1，脏读"><a href="#1，脏读" class="headerlink" title="1，脏读"></a>1，脏读</h2><p>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update account set money=money+100 where name=’B’;  (此时A通知B)</div><div class="line"></div><div class="line">update account set money=money - 100 where name=’A’;</div></pre></td></tr></table></figure>
<p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h2 id="2，不可重复读"><a href="#2，不可重复读" class="headerlink" title="2，不可重复读"></a>2，不可重复读</h2><p>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p>
<h2 id="3，虚读-幻读"><a href="#3，虚读-幻读" class="headerlink" title="3，虚读(幻读)"></a>3，虚读(幻读)</h2><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<p>　　现在来看看MySQL数据库为我们提供的四种隔离级别：</p>
<p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
<p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
<p>　　③ Read committed (读已提交)：可避免脏读的发生。</p>
<p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<p>　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>
<p>　　在MySQL数据库中查看当前事务的隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select @@tx_isolation;</div></pre></td></tr></table></figure>
<p>　　在MySQL数据库中设置事务的隔离 级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set  [glogal | session]  transaction isolation level 隔离级别名称;</div><div class="line"></div><div class="line">set tx_isolation=’隔离级别名称;’</div></pre></td></tr></table></figure>
<p>例1：查看当前事务的隔离级别：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202200007-1111796802.png" alt="img"></p>
<p>例2：将事务的隔离级别设置为Read uncommitted级别：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202224241-2101542210.png" alt="img"></p>
<p>或：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202245210-345198166.png" alt="img"></p>
<p>记住：设置数据库的隔离级别一定要是在开启事务之前！</p>
<p>　　如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202333460-377269897.png" alt="img"></p>
<p>在JDBC中设置隔离级别的部分代码：</p>
<p>　　<img src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202355694-2106931487.png" alt="img"></p>
<p>　　后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关</p>
<p>java.lang.OutOfMemoryError: PermGen space</p>
<p>发现很多人把问题归因于： spring,hibernate,tomcat，因为他们动态产生类,导致JVM中的permanent heap溢出 。然后解决方法众说纷纭，有人说升级 tomcat版本到最新甚至干脆不用tomcat。还有人怀疑spring的问题，在spring论坛上讨论很激烈，因为spring在AOP时使用CBLIB会动态产生很多类。<br>但问题是为什么这些王牌的开源会出现同一个问题呢，那么是不是更基础的原因呢？tomcat在Q&amp;A很隐晦的回答了这一点，我们知道这个问题，但这个问题是由一个更基础的问题产生。<br>于是有人对更基础的JVM做了检查，发现了问题的关键。原来SUN 的JVM把内存分了不同的区，其中一个就是permenter区用来存放用得非常多的类和类描述。本来SUN设计的时候认为这个区域在JVM启动的时候就 固定了，但他没有想到现在动态会用得这么广泛。而且这个区域有特殊的垃圾收回机制，现在的问题是动态加载类到这个区域后，gc根本没办法回收！</p>
<p>1、首先是：java.lang.OutOfMemoryError: Java heap space</p>
<p>解释：</p>
<p>Heap size 设置</p>
<p>JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。<br>提示：在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。<br>提示：Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。</p>
<p>解决方法：</p>
<p>手动设置Heap size<br>修改TOMCAT_HOME/bin/catalina.bat，在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行： </p>
<p>复制代码 代码如下:</p>
<p>set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m </p>
<p>或修改catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行： </p>
<p>复制代码 代码如下:</p>
<p>JAVA_OPTS=”$JAVA_OPTS -server -Xms800m -Xmx800m -XX:MaxNewSize=256m”<br>[html]2、其次是：java.lang.OutOfMemoryError: PermGen space原因：PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误，这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。解决方法：1. 手动设置MaxPermSize大小<br>修改TOMCAT_HOME/bin/catalina.bat（Linux下为catalina.sh），在<br>[code]<br>“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m </p>
<p>catalina.sh下为： </p>
<p>复制代码 代码如下:</p>
<p>JAVA_OPTS=”$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m”</p>
<p>以上是云栖社区小编为您精心准备的的内容，在云栖社区的博客、问答、公众号、人物、课程等栏目也有的相关内容，欢迎继续使用右上角搜索按钮进行搜索jvm内存溢出 jvm内存溢出解决方案、java内存溢出怎么解决、java内存溢出解决方法、如何解决java内存溢出、java 内存溢出 解决，以便于您获取更多的相关知识</p>
<p>Tomcat本身不能直接在计算机上运行，需要依赖于硬件基础之上的<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>和一个<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>虚拟机。Tomcat的内存溢出本质就是JVM内存溢出，所以在本文开始时，应该先对<a href="http://lib.csdn.net/base/java" target="_blank" rel="external">Java </a>JVM有关内存方面的知识进行详细介绍。</p>
<p><strong>一、Java JVM内存介绍</strong></p>
<p>JVM管理两种类型的内存，堆和非堆。按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中，它和堆不同，运行期内GC不会释放其空间。</p>
<p><strong>(1). 堆内存分配</strong><br>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指 定，默认是物理内存的1/4。默认空余堆内存小于 40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC 后调整堆的大小。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行堆内存设置，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值，建议堆的最大值设置为可用内存的最大值的80%。</p>
<p>初始化堆的大小是JVM在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果JVM启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，JVM就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时JVM就会提示内存溢出，并且导致应用服务崩溃。所以，如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。</p>
<p><strong>(2). 非堆内存分配</strong><br>也叫永久保存的区域，用于存放Class和Meta信息,Class在被Load的时候被放入该区域。它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理。JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 GC不会对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。</p>
<p><strong>(3). JVM内存限制(最大值) </strong>首先JVM内存限制于实际的最大物理内存（废话！，呵呵），假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，<a href="http://lib.csdn.net/base/linux" target="_blank" rel="external">Linux</a>系统 下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<p><strong>二、三种内存溢出异常介绍</strong></p>
<p><strong>1. OutOfMemoryError： Java heap space  堆溢出</strong></p>
<p>内存溢出主要存在问题就是出现在这个情况中。当在JVM中如果98％的时间是用于GC且可用的 Heap size 不足2％的时候将抛出此异常信息。</p>
<p> <strong>2. OutOfMemoryError： PermGen space   非堆溢出（永久保存区域溢出）</strong></p>
<p>这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。如果web app用了大量的第三方jar或者应用有太多的class文件而恰好MaxPermSize设置较小，超出了也会导致这块内存的占用过多造成溢出，或者tomcat热部署时侯不会清理前面加载的环境，只会将context更改为新部署的，非堆存的内容就会越来越多。</p>
<p><strong>3. OutOfMemoryError： unable to create new native thread.   无法创建新的线程</strong></p>
<p>这种现象比较少见，也比较奇怪，主要是和jvm与系统内存的比例有关。这种怪事是因为JVM已经被系统分配了大量的内存（比如1.5G），并且它至少要占用可用内存的一半。</p>
<hr>
<p><strong>三、Java JVM内存配置</strong></p>
<p><strong>1. JVM内存分配设置的参数有四个</strong></p>
<p>-Xmx    Java Heap最大值，默认值为物理内存的1/4；</p>
<p>-Xms    Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>机JVM可以保留默认值；</p>
<p>-Xmn    Java Heap Young区大小，不熟悉最好保留默认值；</p>
<p>-Xss      每个线程的Stack大小，不熟悉最好保留默认值；</p>
<p>-XX:MaxPermSize：设定最大内存的永久保存区域；</p>
<p>-XX:PermSize：设定内存的永久保存区域；</p>
<p>-XX:NewSize：设置JVM堆的‘新生代’的默认大小；</p>
<p>-XX:MaxNewSize：设置JVM堆的‘新生代’的最大大小； </p>
<hr>
<p><strong>2. 如何设置JVM的内存分配</strong></p>
<p>（1）当在命令提示符下启动并使用JVM时（只对当前运行的类Test生效）：</p>
<blockquote>
<p>java -Xmx128m -Xms64m -Xmn32m -Xss16m Test</p>
</blockquote>
<p>（2）当在集成开发环境下（如eclipse）启动并使用JVM时：</p>
<blockquote>
<p>a. 在eclipse根目录下打开eclipse.ini，默认内容为（这里设置的是运行当前开发工具的JVM内存分配）：  -vmargs -Xms40m -Xmx256m -vmargs表示以下为虚拟机设置参数，可修改其中的参数值，也可添加-Xmn，-Xss，另外，eclipse.ini内还可以设置非   堆内存，如：-XX:PermSize=56m，-XX:MaxPermSize=128m。</p>
<p>b. 打开eclipse－窗口－首选项－Java－已安装的JRE（对在当前开发环境中运行的java程序皆生效）  编辑当前使用的JRE，在缺省VM参数中输入：-Xmx128m -Xms64m -Xmn32m –Xss16m。</p>
<p>c. 打开eclipse－运行－运行－Java应用程序（只对所设置的java类生效）  选定需设置内存分配的类－自变量，在VM自变量中输入：-Xmx128m -Xms64m -Xmn32m -Xss16m  注：如果在同一开发环境中同时进行了b和c设置，则b设置生效，c设置无效，如：  开发环境的设置为：-Xmx256m，而类Test的设置为：-Xmx128m -Xms64m，则运行Test时生效的设置为：  -Xmx256m -Xms64m。</p>
</blockquote>
<p>（3）当在服务器环境下（如Tomcat）启动并使用JVM时（对当前服务器环境下所以Java程序生效）：</p>
<blockquote>
<p>a. 设置环境变量：  变量名：CATALINA_OPTS  变量值：-Xmx128m -Xms64m -Xmn32m -Xss16m。</p>
<p>b. 打开Tomcat根目录下的bin文件夹，编辑catalina.bat，将其中的%CATALINA_OPTS%（共有四处）替换为：-Xmx128m -Xms64m -Xmn32m -Xss16m。</p>
<p>c. 若没有catalina.bat，只有tomcat.exe,tomcat6w.exe;则可以在启动tomcat6w.exe 后 右键配置–Java–java option 下面输入：</p>
<p>-Xmx256m –Xms64m</p>
<p>也可以找到注册表HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\TomcatService Manager\Tomcat6\Parameters\JavaOptions原值为 -Dcatalina.home=”C:\ApacheGroup\Tomcat 6.0” -Djava.endorsed.dirs=”C:\ApacheGroup\Tomcat 6.0\common\endorsed” -Xrs 加入  -Xms300m  -Xmx350m  （我的是加入-Xmx350m，tomcat才能启动，加入-Xms300m  -Xmx350m反而tomcat都不能启动）重起tomcat服务,设置生效。</p>
</blockquote>
<p><strong>3. 查看JVM内存信息</strong></p>
<blockquote>
<p>Runtime.getRuntime().maxMemory(); //最大可用内存，对应-Xmx </p>
<p>Runtime.getRuntime().freeMemory(); //当前JVM空闲内存 </p>
<p>Runtime.getRuntime().totalMemory(); //当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和 </p>
</blockquote>
<p>关于maxMemory()，freeMemory()和totalMemory()：maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1/4，设置不能高于计算机物理内存；  totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；  freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。</p>
<p><strong>4. 实例，以下给出1G内存环境下java jvm 的参数设置参考</strong></p>
<blockquote>
<p>JAVA_OPTS=”-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true “</p>
</blockquote>
<p>大型的web工程，用tomcat默认分配的内存空间无法启动，如果不是在myeclipse中启动tomcat可以对tomcat这样设置：</p>
<blockquote>
<p>TOMCAT_HOME\bin\catalina.bat 中添加这样一句话：</p>
<p>set JAVA_OPTS= -Xmx1024M -Xms512M -XX:MaxPermSize=256m</p>
</blockquote>
<p>如果要在myeclipse中启动，上述的修改就不起作用了，可如下设置：</p>
<blockquote>
<p>Myeclipse-&gt;preferences-&gt;myeclipse-&gt;servers-&gt;tomcat-&gt;tomcat×.×-&gt;JDK面板中的</p>
<p>Optional Java VM arguments中添加：-Xmx1024M -Xms512M -XX:MaxPermSize=256m</p>
</blockquote>
<p>对于单独的.class，可以用下面的方法对Test运行时的jvm内存进行设置。 java -Xms64m -Xmx256m Test -Xms是设置内存初始化的大小 -Xmx是设置最大能够使用内存的大小。</p>
<p><strong>四、JVM内存配置与GC</strong></p>
<p>需要考虑的是Java提供的垃圾回收机制。JVM的堆大小决定了JVM花费在收集垃圾上的时间和频度。收集垃圾可以接受的速度与应用有关，应该通过分析实际的垃圾收集的时间和频率来调整。如果堆的大小很大，那么完全垃圾收集就会很慢，但是频度会降低。如果你把堆的大小和内存的需要一致，完全收集就很快，但是会更加频繁。调整堆大小的的目的是最小化垃圾收集的时间，以在特定的时间内最大化处理客户的请求。在基准测试的时候，为保证最好的性能，要把堆的大小设大，保证垃圾收集不在整个基准测试的过程中出现。如果系统花费很多的时间收集垃圾，请减小堆大小。一次完全的垃圾收集应该不超过 3-5 秒。如果垃圾收集成为瓶颈，那么需要指定堆的大小，检查垃圾收集的详细输出，研究垃圾收集参数对性能的影响。一般说来，你应该使用物理内存的 80% 作为堆大小。当增加处理器时，记得增加内存，因为分配可以并行进行，而垃圾收集不是并行的。</p>
<p><strong>Java Heap分为3个区：</strong></p>
<p>1.Young 2.Old 3.Permanent。Young保存刚实例化的对象。当该区被填满时，GC会将对象移到Old区。Permanent区则负责保存反射对象，本文不讨论该区。</p>
<p><strong>JVM有2个GC线程： </strong>第一个线程负责回收Heap的Young区；<br>第二个线程在Heap不足时，遍历Heap，将Young 区升级为Older区，Older区的大小等于-Xmx减去-Xmn，不能将-Xms的值设的过大，因为第二个线程被迫运行会降低JVM的性能。</p>
<p><strong>为什么一些程序频繁发生GC？有如下原因： </strong>1. 程序内调用了System.gc()或Runtime.gc()。<br>\2. 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。<br>\3. Java的Heap太小，一般默认的Heap值都很小。<br>\4. 频繁实例化对象，Release对象 此时尽量保存并重用对象，例如使用StringBuffer()和String()。</p>
<p>如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态许多Server端的Java程序每次GC后最好能有65%的剩余空间。</p>
<p><strong>经验之谈： </strong>1．Server端JVM最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn值约等于-Xmx的1/3。<br>2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成。</p>
<p><strong>注意： </strong>1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。<br>2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。</p>
<p>1，什么是栈溢出？</p>
<p>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。</p>
<p>2，解决方案：</p>
<p>方法一：用栈把递归转换成非递归</p>
<p>通常,一个函数在调用另一个函数之前,要作如下的事情:a)将实在参数,返回地址等信息传递给被调用函数保存; b)为被调用函数的局部变量分配存储区;c)将控制转移到被调函数的入口. 从被调用函数返回调用函数之前,也要做三件事情:a)保存被调函数的计算结果;b)释放被调函数的数据区;c)依照被调函数保存的返回地址将控制转移到调用函数.所有的这些,不论是变量还是地址,本质上来说都是”数据”,都是保存在系统所分配的栈中的. 那么自己就可以写一个栈来存储必要的数据，以减少系统负担。</p>
<p>方法二：使用static对象替代nonstatic局部对象</p>
<p>在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</p>
<p>方法三：增大堆栈大小值</p>
<p>当创建一个线程的堆栈时，系统将会保留一个链接程序的/STACK开关指明的地址空间区域。但是，当调用CreateThread或_beginthreadex函数时，可以重载原先提交的内存数量。这两个函数都有一个参数，可以用来重载原先提交给堆栈的地址空间的内存数量。如果设定这个参数为0，那么系统将使用/STACK开关指明的已提交的堆栈大小值。后面将假定我们使用默认的堆栈大小值，即1MB的保留区域，每次提交一个页面的内存。</p>
<p><a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>在创建线程时设置栈大小：thread(threadgroup group, runnable target, string name, long stacksize)<br>​         分配新的 thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，作为 group 所引用的线程组的一员，并具有指定的堆栈大小。</p>
<p>Java虚拟机的堆大小如何设置：命令行</p>
<p>　java –Xms128m   //JVM占用最小内存</p>
<p>​     –Xmx512m   //JVM占用最大内存</p>
<p>​     –XX:PermSize=64m   //最小堆大小</p>
<p>​     –XX:MaxPermSize=128m //最大堆大小</p>
<p>在搭建完集群环境后，不得不考虑的一个问题就是用户访问产生的session如何处理。如果不做任何处理的话，用户将出现频繁登录的现象，比如集群中存在A、B两台服务器，用户在第一次访问网站时，Nginx通过其负载均衡机制将用户请求转发到A服务器，这时A服务器就会给用户创建一个Session。当用户第二次发送请求时，Nginx将其负载均衡到B服务器，而这时候B服务器并不存在Session，所以就会将用户踢到登录页面。这将大大降低用户体验度，导致用户的流失，这种情况是项目绝不应该出现的。</p>
<p>我们应当对产生的Session进行处理，通过粘性Session，Session复制或Session共享等方式保证用户的体验度。</p>
<p>以下我将说明5种Session处理策略，并分析其优劣性。</p>
<p>第一种：粘性session</p>
<p>原理：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p>优点：简单，不需要对session做任何处理。</p>
<p>缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。</p>
<p>适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。</p>
<p>实现方式：以Nginx为例，在upstream模块配置ip_hash属性即可实现粘性Session。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream mycluster&#123;</div><div class="line">    #这里添加的是上面启动好的两台Tomcat服务器</div><div class="line">    ip_hash;#粘性Session</div><div class="line">     server 192.168.22.229:8080 weight=1;</div><div class="line">     server 192.168.22.230:8080 weight=1;</div><div class="line">&#125;123456123456</div></pre></td></tr></table></figure>
<p>第二种：服务器session复制</p>
<p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p>优点：可容错，各个服务器间session能够实时响应。</p>
<p>缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</p>
<p>实现方式：</p>
<p>① 设置tomcat ，server.xml 开启tomcat集群功能</p>
<p><img src="http://img.blog.csdn.net/20160316084831378" alt="这里写图片描述"></p>
<p>Address:填写本机ip即可，设置端口号，预防端口冲突。</p>
<p>② 在应用里增加信息：通知应用当前处于集群环境中，支持分布式<br>在web.xml中添加选项</p>
<p>第三种：session共享机制</p>
<p>使用分布式缓存方案比如memcached、<a href="http://lib.csdn.net/base/redis" target="_blank" rel="external">Redis</a>，但是要求Memcached或Redis必须是集群。</p>
<p>使用Session共享也分两种机制，两种情况如下：</p>
<p>① 粘性session处理方式</p>
<p>原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上。memcache只起备份作用，读写都在tomcat上。当某一个tomcat挂掉后，集群将用户的访问定位到备tomcat上，然后根据cookie中存储的SessionId找session，找不到时，再去相应的memcached上去session，找到之后将其复制到备tomcat上。</p>
<p><img src="http://img.blog.csdn.net/20160316085031092" alt="这里写图片描述"></p>
<p>② 非粘性session处理方式</p>
<p>原理：memcached做主从复制，写入session都往从memcached服务上写，读取都从主memcached读取，tomcat本身不存储session</p>
<p><img src="http://img.blog.csdn.net/20160316085142734" alt="这里写图片描述"></p>
<p>优点：可容错，session实时响应。</p>
<p>实现方式：用开源的msm插件解决tomcat之间的session共享：Memcached_Session_Manager（MSM）</p>
<p>a. 复制相关jar包到tomcat/lib 目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">JAVA memcached客户端：spymemcached.jar</div><div class="line"></div><div class="line">msm项目相关的jar包：</div><div class="line"></div><div class="line">1. 核心包，memcached-session-manager-&#123;version&#125;.jar</div><div class="line">2. Tomcat版本对应的jar包：memcached-session-manager-tc&#123;tomcat-version&#125;-&#123;version&#125;.jar</div><div class="line"></div><div class="line">序列化工具包：可选kryo，javolution,xstream等，不设置时使用jdk默认序列化。1234567812345678</div></pre></td></tr></table></figure>
<p>b. 配置Context.xml ，加入处理Session的Manager</p>
<p>粘性模式配置：</p>
<p><img src="http://img.blog.csdn.net/20160316085319130" alt="这里写图片描述"></p>
<p>非粘性配置：</p>
<p><img src="http://img.blog.csdn.net/20160316085415800" alt="这里写图片描述"></p>
<p>第四种：session持久化到<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a></p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。</p>
<p>优点：服务器出现问题，session不会丢失</p>
<p>缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<p>第五种terracotta实现session复制</p>
<p>原理：Terracotta的基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta只把变化的部分发送给Terracotta服务器，然后由服务器把它转发给真正需要这个数据的节点。可以看成是对第二种方案的优化。</p>
<p><img src="http://img.blog.csdn.net/20160316085627162" alt="这里写图片描述"><br>优点：这样对网络的压力就非常小，各个节点也不必浪费CPU时间和内存进行大量的序列化操作。把这种集群间数据共享的机制应用在session同步上，既避免了对数据库的依赖，又能达到负载均衡和灾难恢复的效果。</p>
<p>小结</p>
<p>以上讲述的就是集群或分布式环境下，session的5种处理策略。其中就应用广泛性而言，第三种方式，也就是基于第三方缓存框架共享session，应用的最为广泛，无论是效率还是扩展性都很好。而Terracotta作为一个JVM级的开源群集框架，不仅提供HTTP Session复制，它还能做分布式缓存，POJO群集，跨越群集的JVM来实现分布式应用程序协调等，也值得学习一下。</p>
<p>HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</p>
<p>​    通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p>通用头域（即通用头）</p>
<p>通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。</p>
<p>Cache-Control头域</p>
<p>Cache -Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：Public指示响应可被任何缓存区缓存；Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效；no-cache指示请求或响应消息不能缓存；no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存；max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应；min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应；max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>
<p>Date头域</p>
<p>date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<p>Pragma头域</p>
<p>Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。</p>
<p>Connection表示连接状态</p>
<p>请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>
<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>
<p>响应：close（连接已经关闭）。</p>
<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>
<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>
<p>请求消息（请求头）</p>
<p>请求消息的第一行为下面的格式：</p>
<p>Method Request-URI HTTP-Version</p>
<p>Method 表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、 TRACE。方法GET和HEAD应该被所有的通用WEB服务器支持，其他所有方法的实现是可选的，GET方法取回由Request-URI标识的信息， HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体；POST方法可以请求服务器接收包含在请求中的实体信息，可以用于提交表单，向新闻组、BBS、邮件群组和数据库发送消息。Request-URI表示请求的URL。Request-URI遵循URI格式，在此字段为星号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务器本身。HTTP- Version表示支持的HTTP版本，例如为HTTP/1.1。</p>
<p>请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If- Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域,一般将会作为实体头域处理。</p>
<p>典型的请求消息：</p>
<p>GET <a href="http://download.microtool.de:80/somedata.exe" target="_blank" rel="external">http://download.microtool.de:80/somedata.exe</a></p>
<p>Host: download.microtool.de</p>
<p>Accept:<em>/</em></p>
<p>Pragma: no-cache</p>
<p>Cache-Control: no-cache</p>
<p>Referer: <a href="http://download.microtool.de/" target="_blank" rel="external">http://download.microtool.de/</a></p>
<p>User-Agent:Mozilla/4.04<a href="Win95;I;Nav">en</a></p>
<p>Range:bytes=554554-</p>
<p>上例第一行表示HTTP客户端（可能是浏览器、下载程序）通过GET方法获得指定URL下的文件。棕色的部分表示请求头域的信息，绿色的部分表示通用头部分。</p>
<p>Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回；Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。Accept-Charset： 浏览器申明自己接收的字符集。Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。User-Agent头域的内容包含发出请求的用户信息。Referer 头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址； Range头域可以请求实体的一个或者多个子范围。例如</p>
<p>表示头500个字节：bytes=0-499</p>
<p>表示第二个500字节：bytes=500-999</p>
<p>表示最后500个字节：bytes=-500</p>
<p>表示500字节以后的范围：bytes=500-</p>
<p>第一个和最后一个字节：bytes=0-0,-1</p>
<p>同时指定几个范围：bytes=500-600,601-999</p>
<p>但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）</p>
<p>响应消息（响应头）</p>
<p>响应消息的第一行为下面的格式：</p>
<p>HTTP-Version Status-Code Reason-Phrase</p>
<p>HTTP -Version表示支持的HTTP版本，例如为HTTP/1.1。Status- Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自 动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：</p>
<p>1xx:信息响应类，表示接收到请求并且继续处理</p>
<p>2xx:处理成功响应类，表示动作被成功接收、理解和接受</p>
<p>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理</p>
<p>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行</p>
<p>5xx:服务端错误，服务器不能正确执行一个正确的请求</p>
<p>响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和 Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头 域，一般将会作为实体头域处理。</p>
<p>典型的响应消息：</p>
<p>HTTP/1.0 200 OK</p>
<p>Date:Mon,31Dec200104:25:57GMT</p>
<p>Server:Apache/1.3.14(Unix)</p>
<p>Content-type:text/html</p>
<p>Last-modified:Tue,17Apr200106:46:28GMT</p>
<p>Etag:”a030f020ac7c01:1e9f”</p>
<p>Content-length:39725426</p>
<p>Content-range:bytes554554-40279979/40279980</p>
<p>上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。</p>
<p>Location响应头用于重定向接收者到一个新URI地址。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序</p>
<p>实体消息（实体头和实体）</p>
<p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。</p>
<p>实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。</p>
<p>Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型，表示后面的文档属于什么MIME类型。Content-Length表示实际传送的字节数。Allow 实体头至服务器支持哪些请求方法（如GET、POST等）。Content-Range表示传送的范围，用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：</p>
<p>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth</p>
<p>例 如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求）。Content-Encoding 指文档的编码（Encode）方法。</p>
<p>实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。</p>
<p>附录：</p>
<p>HTTP头部详解</p>
<p>1、 Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>
<p>2、 Accept-Charset： 浏览器申明自己接收的字符集</p>
<p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</p>
<p>Accept-Language：：浏览器申明自己接收的语言</p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>
<p>3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</p>
<p>4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p>
<p>5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</p>
<p>6、 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）</p>
<p>max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）</p>
<p>max-stale：（可以接受过去的对象，但是过期时间必须小于 max-stale 值）</p>
<p>min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）</p>
<p>响应：public(可以用 Cached 内容回应任何用户)</p>
<p>private（只能用缓存内容回应先前请求该内容的那个用户）</p>
<p>no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）</p>
<p>max-age：（本响应包含的对象的过期时间）</p>
<p>ALL: no-store（不允许缓存）</p>
<p>7、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>
<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>
<p>响应：close（连接已经关闭）。</p>
<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>
<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>
<p>8、 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p>
<p>9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。</p>
<p>10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012</p>
<p>11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</p>
<p>12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</p>
<p>13、 ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。</p>
<p>14、 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</p>
<p>15、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p>
<p>16、 If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</p>
<p>17、If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</p>
<p>18、 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</p>
<p>19、If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</p>
<p>20、 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</p>
<p>21、 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p>
<p>22、 Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location：<a href="http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif" target="_blank" rel="external">http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</a></p>
<p>23、 Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache</p>
<p>24、 Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p>
<p>25、 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</p>
<p>26、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：<a href="http://www.sina.com/" target="_blank" rel="external">http://www.sina.com/</a></p>
<p>27、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)</p>
<p>28、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p>
<p>29、 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</p>
<p>30、 Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己 Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding</p>
<p>31、 Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<p>===============================================================================</p>
<p>HTTP 请求消息头部实例：</p>
<p>Host：rss.sina.com.cn</p>
<p>User-Agent：Mozilla/5、0 (Windows; U; Windows NT 5、1; zh-CN; rv:1、8、1、14) Gecko/20080404 Firefox/2、0、0、14</p>
<p>Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0、9,text/plain;q=0、8,image/png,<em>/</em>;q=0、5</p>
<p>Accept-Language：zh-cn,zh;q=0、5</p>
<p>Accept-Encoding：gzip,deflate</p>
<p>Accept-Charset：gb2312,utf-8;q=0、7,*;q=0、7</p>
<p>Keep-Alive：300</p>
<p>Connection：keep-alive</p>
<p>Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;– Cookie</p>
<p>If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT</p>
<p>Cache-Control：max-age=0</p>
<p>HTTP 响应消息头部实例：</p>
<p>Status：OK - 200 &lt;– 响应状态码，表示 web 服务器处理的结果。</p>
<p>Date：Sun, 01 Jun 2008 12:35:47 GMT</p>
<p>Server：Apache/2、0、61 (Unix)</p>
<p>Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT</p>
<p>Accept-Ranges：bytes</p>
<p>Content-Length：18616</p>
<p>Cache-Control：max-age=120</p>
<p>Expires：Sun, 01 Jun 2008 12:37:47 GMT</p>
<p>Content-Type：application/xml</p>
<p>Age：2</p>
<p>X-Cache：HIT from 236-41、D07071951、sina、com、cn &lt;– 反向代理服务器使用的 HTTP 头部</p>
<p>Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<p>Connection：close</p>
<p><strong>一、MAC帧头定义</strong></p>
<p>/<em>数据帧定义，头14个字节，尾4个字节</em>/<br>typedef struct _MAC_FRAME_HEADER<br>{<br> char m_cDstMacAddress[6];    //目的mac地址<br> char m_cSrcMacAddress[6];    //源mac地址<br> short m_cType;       　　　　　//上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp<br>}<strong>attribute</strong>((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER;</p>
<p>typedef struct _MAC_FRAME_TAIL<br>{<br> unsigned int m_sCheckSum;    //数据帧尾校验和<br>}<strong>attribute</strong>((packed))MAC_FRAME_TAIL, *PMAC_FRAME_TAIL;</p>
<p><strong>二、IP头结构的定义</strong></p>
<p>/<em>IP头定义，共20个字节</em>/<br>typedef struct _IP_HEADER<br>{<br> char m_cVersionAndHeaderLen;     　　//版本信息(前4位)，头长度(后4位)<br> char m_cTypeOfService;      　　　　　 // 服务类型8位<br> short m_sTotalLenOfPacket;    　　　　//数据包长度<br> short m_sPacketID;      　　　　　　　 //数据包标识<br> short m_sSliceinfo;      　　　　　　　  //分片使用<br> char m_cTTL;        　　　　　　　　　　//存活时间<br> char m_cTypeOfProtocol;    　　　　　 //协议类型<br> short m_sCheckSum;      　　　　　　 //校验和<br> unsigned int m_uiSourIp;     　　　　　//源ip<br> unsigned int m_uiDestIp;     　　　　　//目的ip<br>} <strong>attribute</strong>((packed))IP_HEADER, *PIP_HEADER ;</p>
<p><strong>三、tcp头结构定义</strong></p>
<p><img src="http://my.csdn.net/uploads/201205/25/1337910956_9817.jpg" alt="img"></p>
<p> <img src="/Users/wuxinyua/wuxinyua.github.io/source/_posts/image/1337910956_9817.jpg" alt="1337910956_9817"></p>
<p>/<em>TCP头定义，共20个字节</em>/<br>typedef struct _TCP_HEADER<br>{<br> short m_sSourPort;        　　　　　　// 源端口号16bit<br> short m_sDestPort;       　　　　　　 // 目的端口号16bit<br> unsigned int m_uiSequNum;       　　// 序列号32bit<br> unsigned int m_uiAcknowledgeNum;  // 确认号32bit<br> short m_sHeaderLenAndFlag;      　　// 前4位：TCP头长度；中6位：保留；后6位：标志位<br> short m_sWindowSize;       　　　　　// 窗口大小16bit<br> short m_sCheckSum;        　　　　　 // 检验和16bit<br> short m_surgentPointer;      　　　　 // 紧急数据偏移量16bit<br>}<strong>attribute</strong>((packed))TCP_HEADER, *PTCP_HEADER;</p>
<p>/*TCP头中的选项定义</p>
<p>kind(8bit)+Length(8bit，整个选项的长度，包含前两部分)+内容(如果有的话)</p>
<p>KIND = 1表示 无操作NOP，无后面的部分</p>
<p>  2表示 maximum segment   后面的LENGTH就是maximum segment选项的长度（以byte为单位，1+1+内容部分长度）</p>
<p>  3表示 windows scale     后面的LENGTH就是 windows scale选项的长度（以byte为单位，1+1+内容部分长度）</p>
<p>  4表示 SACK permitted    LENGTH为2，没有内容部分</p>
<p>  5表示这是一个SACK包     LENGTH为2，没有内容部分</p>
<p>  8表示时间戳，LENGTH为10，含8个字节的时间戳<br>*/</p>
<p>typedef struct _TCP_OPTIONS<br>{<br> char m_ckind;<br> char m_cLength;<br> char m_cContext[32];<br>}<strong>attribute</strong>((packed))TCP_OPTIONS, *PTCP_OPTIONS;</p>
<p><strong>四、UDP头结构的定义</strong></p>
<p><img src="http://my.csdn.net/uploads/201205/25/1337910963_6079.jpg" alt="img"></p>
<p>/<em>UDP头定义，共8个字节</em>/</p>
<p>typedef struct _UDP_HEADER<br>{<br> unsigned short m_usSourPort;    　　　// 源端口号16bit<br> unsigned short m_usDestPort;    　　　// 目的端口号16bit<br> unsigned short m_usLength;    　　　　// 数据包长度16bit<br> unsigned short m_usCheckSum;    　　// 校验和16bit<br>}<strong>attribute</strong>((packed))UDP_HEADER, *PUDP_HEADER;</p>
<p>====</p>
<p><a href="http://www.cnblogs.com/li-hao/archive/2011/12/07/2279912.html" target="_blank" rel="external">http://www.cnblogs.com/li-hao/archive/2011/12/07/2279912.html</a></p>
<p>-———————————————————————————————————————————— </p>
<h3 id="tcp、ip、udp头部格式"><a href="#tcp、ip、udp头部格式" class="headerlink" title="tcp、ip、udp头部格式"></a>tcp、ip、udp头部格式</h3><p>2.2　TCP/IP报文格式</p>
<p>　　</p>
<p>　　1、IP报文格式</p>
<p>　　</p>
<p>　　IP<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>是TCP/IP<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>族中最为核心的<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank" rel="external">协议</a>。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。在局域网环境，IP协议往往被封装在以太网帧（见本章1.3节）中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如图2-3所示：</p>
<p>　　 　</p>
<p>　　 图2-3　 TCP/IP报文封装</p>
<p>　　<img src="http://my.csdn.net/uploads/201205/25/1337910967_8133.jpg" alt="img"></p>
<p>　　图2-4是IP头部（报头）格式：（RFC 791）。</p>
<p>　　 <img src="http://my.csdn.net/uploads/201205/25/1337910978_9542.jpg" alt="img">　</p>
<p>　　 图2-4　 IP头部格式</p>
<p>　　</p>
<p>　　其中：</p>
<p>　　</p>
<p>　　●版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</p>
<p>　　</p>
<p>　　●报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。</p>
<p>　　</p>
<p>　　●服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态<a href="http://cisco.chinaitlab.com/List_6.html" target="_blank" rel="external">路由</a>协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p>
<p>　　</p>
<p>　　●总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</p>
<p>　　</p>
<p>　　●标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</p>
<p>　　</p>
<p>　　●标志位字段：占3比特。标志一份数据报是否要求分段。</p>
<p>　　</p>
<p>　　●段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</p>
<p>　　</p>
<p>　　●生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</p>
<p>　　</p>
<p>　　●协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</p>
<p>　　</p>
<p>　　●头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</p>
<p>　　</p>
<p>　　●源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</p>
<p>　　</p>
<p>　　可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p>
<p>　　</p>
<p>　　2、TCP数据段格式</p>
<p>　　</p>
<p>　　TCP是一种可靠的、面向连接的字节流服务。源主机在传送数据前需要先和目标主机建立连接。然后，在此连接上，被编号的数据段按序收发。同时，要求对每个数据段进行确认，保证了可靠性。如果在指定的时间内没有收到目标主机对所发数据段的确认，源主机将再次发送该数据段。</p>
<p>　　</p>
<p>　　如图2-5所示，是TCP头部结构（RFC 793、1323）。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337910993_8515.jpg" alt="img"></p>
<p>　　 图2-5　 TCP头部结构</p>
<p>　　</p>
<p>　　●源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>动态地为客户端的应用程序分配端口号。在<a href="http://server.chinaitlab.com/" target="_blank" rel="external">服务器</a>端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。</p>
<p>　　</p>
<p>　　●顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。</p>
<p>　　</p>
<p>　　●确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。</p>
<p>　　</p>
<p>　　●头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。</p>
<p>　　</p>
<p>　　●标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p>
<p>　　</p>
<p>　　◆URG：紧急指针（urgent pointer）有效。</p>
<p>　　</p>
<p>　　◆ACK：确认序号有效。</p>
<p>　　</p>
<p>　　◆PSH：接收方应该尽快将这个报文段交给应用层。</p>
<p>　　</p>
<p>　　◆RST：重建连接。</p>
<p>　　</p>
<p>　　◆SYN：发起一个连接。</p>
<p>　　</p>
<p>　　◆FIN：释放一个连接。</p>
<p>　　</p>
<p>　　●窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</p>
<p>　　</p>
<p>　　●TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p>
<p>　　</p>
<p>　　●紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p>
<p>　　</p>
<p>　　●选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p>
<p>　　</p>
<p>　　3、UDP数据段格式</p>
<p>　　</p>
<p>　　UDP是一种不可靠的、无连接的数据报服务。源主机在传送数据前不需要和目标主机建立连接。数据被冠以源、目标端口号等UDP报头字段后直接发往目的主机。这时，每个数据段的可靠性依靠上层协议来保证。在传送数据较少、较小的情况下，UDP比TCP更加高效。</p>
<p>　　</p>
<p>　　如图2-6所示，是UDP头部结构（RFC 793、1323）：</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911478_8471.jpg" alt="img"></p>
<p>　　 图2-6　 UDP数据段格式</p>
<p>　　</p>
<p>　　●源、目标端口号字段：占16比特。作用与TCP数据段中的端口号字段相同，用来标识源端和目标端的应用进程。</p>
<p>　　</p>
<p>　　●长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。</p>
<p>　　</p>
<p>　　●校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。</p>
<p>　　</p>
<p>　　2.3　套接字</p>
<p>　　</p>
<p>　　在每个TCP、UDP数据段中都包含源端口和目标端口字段。有时，我们把一个IP地址和一个端口号合称为一个套接字（Socket），而一个套接字对（Socket pair）可以唯一地确定互连网络中每个TCP连接的双方（客户IP地址、客户端口号、<a href="http://server.chinaitlab.com/" target="_blank" rel="external">服务器</a>IP地址、服务器端口号）。</p>
<p>　　</p>
<p>　　如图2-7所示，是常见的一些协议和它们对应的服务端口号。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911485_7934.jpg" alt="img"></p>
<p>　　 图2-7　 常见协议和对应的端口号</p>
<p>　　</p>
<p>　　需要注意的是，不同的应用层协议可能基于不同的传输层协议，如FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。</p>
<p>　　</p>
<p>　　同时，有些应用层协议占用了两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。</p>
<p>　　</p>
<p>　　还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供域名解析服务，在TCP的53端口提供DNS区域文件传输服务。</p>
<p>　　</p>
<p>　　2.4　TCP连接建立、释放时的握手过程</p>
<p>　　</p>
<p>　　1、TCP建立连接的三次握手过程</p>
<p>　　</p>
<p>　　TCP会话通过三次握手来初始化。三次握手的目标是使数据段的发送和接收同步。同时也向其他主机表明其一次可接收的数据量（窗口大小），并建立逻辑连接。这三次握手的过程可以简述如下：</p>
<p>　　</p>
<p>　　●源主机发送一个同步标志位（SYN）置1的TCP数据段。此段中同时标明初始序号（Initial Sequence Number，ISN）。ISN是一个随时间变化的随机值。</p>
<p>　　</p>
<p>　　●目标主机发回确认数据段，此段中的同步标志位（SYN）同样被置1，且确认标志位（ACK）也置1，同时在确认序号字段表明目标主机期待收到源主机下一个数据段的序号（即表明前一个数据段已收到并且没有错误）。此外，此段中还包含目标主机的段初始序号。</p>
<p>　　</p>
<p>　　●源主机再回送一个数据段，同样带有递增的发送序号和确认序号。</p>
<p>　　</p>
<p>　　至此为止，TCP会话的三次握手完成。接下来，源主机和目标主机可以互相收发数据。整个过程可用图2-8表示。</p>
<p>　　 　<img src="http://my.csdn.net/uploads/201205/25/1337911008_5159.jpg" alt="img"></p>
<p>　　 图2-8　 TCP建立连接的三次握手过程</p>
<p>　　</p>
<p>　　2、TCP释放连接的四次握手过程</p>
<p>　　</p>
<p>　　TCP连接的释放需要进行四次握手，步骤是：</p>
<p>　　</p>
<p>　　●源主机发送一个释放连接标志位（FIN）为1的数据段发出结束会话请求</p>
<p><strong>常见的批处理作业调度算法</strong></p>
<p>1.<strong>先来先服务调度算法（FCFS）</strong>:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p>
<p>2.<strong>短作业优先调度算法**</strong>(SPF):** 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。 </p>
<p>3.<strong>最高响应比优先算法(HRN)：</strong>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。</p>
<ol>
<li><strong>基于优先数调度算法(HPF)：</strong>每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。</li>
</ol>
<p>5.<strong>均衡调度算法，即**</strong>多级队列调度算法**</p>
<p>基本概念：</p>
<p>   作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)</p>
<p>   作业平均周转时间(T)＝周转时间/作业个数</p>
<p>   作业带权周转时间（Wi）＝周转时间/运行时间</p>
<p>   响应比＝（等待时间＋运行时间）/运行时间</p>
<p><strong>二、进程调度算法</strong></p>
<p>1.<strong>先进先出算法(FIFO)：</strong>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。</p>
<ol>
<li><strong>时间片轮转算法(RR)：</strong>分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。</li>
</ol>
<p>3.<strong> 最高优先级算法(HPF)：</strong>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。</p>
<ol>
<li><strong>多级队列反馈法：</strong>几种调度算法的结合形式多级队列方式。</li>
</ol>
<p><strong>三、空闲分区分配算法</strong></p>
<p><strong>1. 首先适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。</p>
<ol>
<li><p><strong>最佳适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。</p>
</li>
<li><p><strong>最坏适应算法：</strong>当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p>
</li>
</ol>
<p><strong>四、虚拟页式存储管理中的页面置换算法</strong></p>
<p>1.<strong>理想页面置换算法(OPT)：</strong>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</p>
<p>2.<strong>先进先出页面置换算法(FIFO)：</strong>选择最先进入内存的页面予以淘汰。</p>
<ol>
<li><strong>最近最久未使用算法（LRU）：</strong>选择在最近一段时间内最久没有使用过的页，把它淘汰。</li>
</ol>
<p><strong>4.最少使用算法（LFU）：</strong>选择到当前时间为止被访问次数最少的页转换。</p>
<p>五、<strong>磁盘调度</strong></p>
<p><strong>1.先来先服务（FCFS）：</strong>是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置</p>
<p><strong>2.最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，</strong>即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</p>
<p><strong>3.扫描算法（SCAN）或电梯调度算法：</strong>总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<p><strong>4.循环扫描算法（CSCAN）：</strong>循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求</p>
<p>首先，你需要明白的一点是：数据库的物理结构是由数据库的操作系统文件所决定，每一个Oracle数据库是由三种类型的文件组成：数据文件、日志文件和控制文件。数据库的文件为数据库信息提供真正的物理存储。<br>​    每一个Oracle数据库有一个或多个物理的数据文件（data file）。一个数据库的数据文件包含全部数据库数据。逻辑数据库结构（如表、索引等）的数据物理地存储在数据库的数据文件中。数据文件通常为*.dbf格式，例如：userCIMS.dbf。数据文件有下列特征：①、一个数据文件仅与一个数据库联系；②、一旦建立，数据文件只增不减；③、一个表空间（数据库存储的逻辑单位）由一个或多个数据文件组成。<br>​    其次，我们再来叙述一下Oracle的逻辑结构：Oracle的逻辑结构包括表空间（tablespace），段（segment），数据块（data block）以及模式对象（schema object）。<br>​    Oracle数据库在逻辑上是由多个表空间组成的，表空间在物理上包含一个或多个数据文件。而数据文件大小是块大小的整数倍；表空间中存储的对象叫段，比如数据段，索引段和回退段。段由区组成，区是磁盘分配的最小单位。段的增大是通过增加区的个数来实现的。每个区的大小是数据块大小的整数倍，区的大小可以不相同；数据块是数据库中的最小的I/O单位，同时也是内存数据缓冲区的单位，及数据文件存储空间单位。块的大小由参数DB_BLOCK_SIZE设置，其值应设置为操作系统块大小的整数倍。<br>   ⑴、表空间（tablespace）<br>   表空间是数据库中最大的逻辑单位，每一个表空间由一个或多个数据文件组成，一个数据文件只能与一个表空间相联系。每一个数据库都有一个SYSTEM表空间，该表空间是在数据库创建或数据库安装时自动创建的，用于存储系统的数据字典表，程序系统单元，过程函数，包和触发器等，也可用于存储用户数据表，索引对象。表空间具有在线（online）和离线（offline）属性，可以将除SYSTME以外的其他任何表空间置为离线。<br>   ⑵、段（segment）<br>   数据库的段可以分为四类：数据段、索引段、回退段和临时段。<br>   ⑶、区<br>   区是磁盘空间分配的最小单位。磁盘按区划分，每次至少分配一个区。区存储与段中，它由连续的数据块组成。<br>   ⑷、数据块<br>   数据块是数据库中最小的数据组织单位与管理单位，是数据文件磁盘存储空间单位，也是数据库I/O的最小单位，数据块大小由DB_BLOCK_SIZE参数决定，不同的Oracle版本DB_BLOCK_SIZE的默认值是不同的。<br>   ⑸、模式对象<br>   模式对象是一种应用，包括：表、聚簇、视图、索引序列生成器、同义词、哈希、程序单元、数据库链等。<br>   最后，在来说一下Oracle的用户、表空间和数据文件的关系：<br>   一个用户可以使用一个或多个表空间，一个表空间也可以供多个用户使用。用户和表空间没有隶属关系，表空间是一个用来管理数据存储的逻辑概念，表空间只是和数据文件发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。<br>   总结一下：解释数据库、表空间、数据文件、表、数据的最好办法就是想象一个装满东西的柜子。数据库其实就是柜子，柜中的抽屉是表空间，抽屉中的文件夹是数据文件，文件夹中的纸是表，写在纸上的信息就是数据。</p>
<p>TCP 三次握手<br>TCP 连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。以下步骤概述了通常情况下客户端计算机联系服务器计算机的过程：<br>\1. 客户端向服务器发送一个SYN置位的TCP报文，其中包含连接的初始序列号x和一个窗口大小（表示客户端上用来存储从服务器发送来的传入段的缓冲区的大小）。<br>\2. 服务器收到客户端发送过来的SYN报文后，向客户端发送一个SYN和ACK都置位的TCP报文，其中包含它选择的初始序列号y、对客户端的序列号的确认x+1和一个窗口大小（表示服务器上用来存储从客户端发送来的传入段的缓冲区的大小）。<br>\3. .客户端接收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号y+1和序号x+1的ACK报文，一个标准的TCP连接完成。<br>TCP 使用类似的握手过程来结束连接。这可确保两个主机均能完成传输并确保所有的数据均得以接收<br>TCP Client<br>Flags<br>TCP Server<br>1 Send SYN (seq=x)<br>—-SYN—&gt;<br>SYN Received<br>2 SYN/ACK Received<br>&lt;—SYN/ACK—-<br>Send SYN (seq=y)， ACK (x+1)<br>3 Send ACK (y+1)<br>—-ACK—&gt;<br>ACK Received， <a href="http://www.yesky.com/key/1551/261551.html" target="_blank" rel="external">Connection</a> Established<br>w: ISN (Initial Sequence Number) of <a href="http://www.yesky.com/key/3226/13226.html" target="_blank" rel="external">the</a> Client<br>x: ISN of the Server</p>
<p><strong>1. TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。</strong></p>
<p>如果采用两次的话，会出现下面这种情况。<br>比如是A机要连到B机，结果发送的连接信息由于某种原因没有到达B机；<br>于是，A机又发了一次，结果这次B收到了，于是就发信息回来，两机就连接。<br>传完东西后，断开。<br>结果这时候，原先没有到达的连接信息突然又传到了B机，于是B机发信息给A，然后B机就以为和A连上了，这个时候B机就在等待A传东西过去。</p>
<p><strong>2. 三次握手改成仅需要两次握手，死锁是可能发生</strong></p>
<p>考虑计算机A和B之间的通信，假定B给A发送一个连接请求分组，A收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A认为连接已经成功地建立了，可以开始发送数据分组。可是，B在A的应答分组在传输中被丢失的情况下，将不知道A是否已准备好，不知道A建议什么样的序列号，B甚至怀疑A是否收到自己的连接请求分组。在这种情况下，B认为连接还未建立成功，将忽略A发来的任何数据分组，只等待连接确认应答分组。而A在发出的分组超时后，重复发送同样的分组。这样就形成了死锁</p>
<p>在<a href="http://wenwen.soso.com/z/Search.e?sp=S%E5%8D%8F%E8%AE%AE%E6%A0%88&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">协议栈</a>中，传输层位于网络层之上，传输层协议为不同<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%B8%BB%E6%9C%BA&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">主机</a>上运行的进程提供<a href="http://wenwen.soso.com/z/Search.e?sp=S%E9%80%BB%E8%BE%91&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">逻辑</a>通信，而<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">网络层协议</a>为不同主机提供逻辑通信。这个区别很微妙，但是却非常重要。让我们用一家人作为<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%B1%BB%E6%AF%94&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">类比</a>来说明一下这个区别。</p>
<p>　　设想一下有两所房子，一个位于<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%B8%9C%E6%B5%B7%E5%B2%B8&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">东海岸</a>而另一个位于<a href="http://wenwen.soso.com/z/Search.e?sp=S%E8%A5%BF%E6%B5%B7%E5%B2%B8&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">西海岸</a>，每所房子里都住着12个小孩。东海岸的房子里的小孩和西海岸房子里的小孩是堂兄妹。两所房子里的孩子喜欢互相通信——每个孩子每周都给每一个堂兄妹写一封信，每一封信都由老式的<a href="http://wenwen.soso.com/z/Search.e?sp=S%E9%82%AE%E5%B1%80&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">邮局</a>分别用<a href="http://wenwen.soso.com/z/Search.e?sp=S%E4%BF%A1%E5%B0%81&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">信封</a>来寄。这样，每一家每周就都有144封信要送到另一家(这些孩子如果可以用<a href="http://wenwen.soso.com/z/Search.e?sp=S%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">电子邮件</a>的话就可以省掉很多钱了!)在每一家里面.都由一个孩子——西海岸的房子里的Ann和东海岸房子里的BilI——负责邮件的收集和分发。每周Ann都从她的<a href="http://wenwen.soso.com/z/Search.e?sp=S%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9&amp;ch=w.search.yjjlink&amp;cid=w.search.yjjlink" target="_blank" rel="external">兄弟姐妹</a>那里收集起来信件，并将这些信件送到每天都来的邮递服务员那里。当信件到达西海岸的房子，Ann又将这些信件分发给她的兄弟姐妹。BilI在东海岸有着同样的工作。</p>
<p>　　在这个例于中，邮递服务提供着两所房子之间的逻辑通信——邮递服务在两所房子之间传递邮件，而不是针对每个人的服务。另一方面，Ann和BilI提供堂兄妹之间的逻辑通信——Ann和BilI从他们的兄弟姐妹那里收集邮件并将邮件递送给他们。注意，从这些堂兄妹的角度看，Ann和BilI是邮件的服务人，尽管他们俩只是端到端寄送服务的一部分(终端系统部分)。这个例子是传输层和网络层之间的关系的一个形象比喻:</p>
<p>　　主机(也称为终端系统)=房子<br>　　进程=堂兄妹<br>　　应用程序消息=信封里的信<br>　　网络层协议=邮递服务(包括邮递员)<br>　　传输层协议=Ann和Bill</p>
<p>现在常用的开源数据连接池主要有c3p0、dbcp和proxool三种，其中：<br>hibernate开发组推荐使用c3p0;<br>spring开发组推荐使用dbcp(dbcp连接池有weblogic连接池同样的问题，就是强行关闭连接或数据库重启后，无法reconnect，告诉连接被重置，这个设置可以解决);<br>hibernate in action推荐使用c3p0和proxool;</p>
<p>dbcp所需jar：commons-dbcp.jar、commons-pool.jar<br>c3p0所需jar：c3p0-0.9.2.1.jar mchange-commons-java-0.2.3.4.jar</p>
<p>proxool暂时没有接触到</p>
<p>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。<br>dbcp简介：<br>DBCP(DataBase connection pool),数据库连接池。是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。<br>c3p0与dbcp区别：<br>dbcp没有自动的去回收空闲连接的功能  c3p0有自动回收空闲连接功能<br>两者主要是对数据连接的处理方式不同！C3P0提供最大空闲时间，DBCP提供最大连接数。<br>前者当连接超过最大空闲连接时间时，当前连接就会被断掉。DBCP当连接数超过最大连接数时，所有连接都会被断开。</p>
<p>今天早上发现网站访问时，突然访问不了了，提示数据库连接不上了，报出了：<br>Warning: mysql_connect() [function.mysql-connect]: Too many connections in ../common/common.database.class.php on line 541<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>的错误。用远程查看服务器，mysql进程已经占了CPU的99%了，mysql的也登陆不进去了。当时马上判断是数据库连接数过多了，最快的办法就是重启服务器，所以我立刻做了：<br>1、通知托管商重启服务器（马上联系了托管，说了又得抱怨了，起个服务器他们既然拖了半个多小时）；<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>2、马上修改代码，屏蔽掉错误提示，因为这个错误提示已经把我们网站的代码路径显示出来了。<br>重启服务器后网站恢复了正常，后来我查找原因，用mysqldumpslow -s c -t 20 mysql-slow.log查慢查询，找慢查询的语句，这时才发现我们网站的mysql慢查询日志没有开启，所以我没法通过日志知道到底是哪些sql查询比较耗资源和耗时间；如下：<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>[root@localhost bin]# ./mysqldumpslow -s c -t 20 mysql-slow.log<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>Reading mysql slow query log from mysql-slow.logCan’t open mysql-slow.log: No such file or directory at ./mysqldumpslow line 73.Died at ./mysqldumpslow line 143.<br>对于这次问题，我的分析是：<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>1、9点到11点之间是一天内我们网站受访的一个高峰，这个高峰本来数据库操作就比较多，再加上今天这个时刻我再后台添加和修改新闻，这么多数据操作中任何一个低效率的sql语句都有可能导致数据库操作的死锁；<a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a><br>2、当同事们都听说网站访问不了的时候，都在不断地刷新主页，这就更加加重了数据库的负载，这个时候CPU的mysql进程达到了99%，有个时间降到了80%，但大家还都在不断的刷新主页，负载又升到了99%；<br><a href="http://www.seacha.com/" target="_blank" rel="external">海姹网（网址:http://www.seacha.com），标签：mysql_connect() : Too many connections-数据库连接数过多，以及记录SQL执行慢的语句配置， 连接数,mysql_connect,mysqldumpslow</a>3、代码里的sql查询语句可能有一些是低效率的；<br>4、 服务器上目前放在几个网站，其中主站、sns的数据库操作比较频繁，当数据库操作频繁时，都有可能造成一些sql查询死锁，当死锁量一多起来后，服务器的 压力将非常大。 </p>
<p>解决办法：<br>1、如何优化数据库访问是任何一个拥有相对比较多的数据库操作的网站所要面临 的问题，这是我们网站第一次碰到这个问题，所以还有待观察和分忻；<br>2、检查代码里的sql语句，优化低效率的sql查询（目前我只 能检查主站的，sns网站上的由于时间和精力无法一一检查）<br>3、开启mysql慢查询日志，这个需要何老师来做，在mysql的配置文件my.cnf里添加<br>log-slow-queries=/var/lib/mysql/slowquery.loglong_query_time=2<br>第一行是慢查询日志的存放路径，第二行是查询超过2秒才记录<br>4、如果以后还继续发生这类事件，咱们可以减少apache的连接数和mysql的连接数，目前咱们的网站不算大，apache和mysql的连接数分别是150和100，连接数都不算多，如果以后还继续发生这类事件就需要调的更少。</p>
<p><strong>概念介绍</strong></p>
<p>​     通俗来讲，会话(Session) 是通信双方从开始通信到通信结束期间的一个上下文（Context）。这个上下文是一段位于服务器端的内存：记录了本次连接的客户端机器、通过哪个应用程序、哪个用户登录等信息.</p>
<p>​     连接（Connection）：连接是从客户端到<a href="http://lib.csdn.net/base/oracle" target="_blank" rel="external">Oracle</a>实例的一条物理路径。连接可以在网络上建立，或者在本机通过IPC机制建立。通常会在客户端进程与一个专用服务器或一个调度器之间建立连接。</p>
<p>​     会话(Session) 是和连接(Connection)是同时建立的，两者是对同一件事情不同层次的描述。简单讲，连接(Connection)是物理上的客户端同服务器的通信链路，会话(Session)是逻辑上的用户同服务器的通信交互。</p>
<p>​     ORACLE中一个用户登录ORACLE服务器的前提，就是该用户具有ORACLE的 “CREATE SESSION”权限。ORACE允许同一个用户在同一个客户机上建立多个同服务器的会话，每个SESSION都代表了用户与服务器的一个交互。就像你用IE浏览器打开博客园网站，然后你再打开一个IE窗口，又打开一个博客园网站。两个IE窗口就相当于两个SESSION， 而物理链路就相当于连接（Connection）。后台进程PMON会每隔一段时间，就会检测用户连接状况，如果连接已断开，PMON会清理现场，释放相关的资源。</p>
<p>​     在一条连接而无相应的会话。另外，一个会话可以有连接也可以没有连接。使用高级Oracle Net特性（如连接池）时，客户可以删除一条物理连接，而会话依然保留（但是会话会空闲）。客户在这个会话上执行某个操作时，它会重新建立物理连接。</p>
<p>​    在专用服务器中，一个会话对应一个服务器进程（Process),如果<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>运行在共享服务器方式，一个服务器进程可以为多个会话服务。</p>
<p>​       <strong>下面用通俗易懂的方式来解释连接和会话。</strong></p>
<p>   有A/B两个城市，需要从A运送白菜到B城<br>   我们先建设一条公路<br>   然后运送白菜过去，包括准备白菜和运送白菜以及返回等一系列的动作。<br>   一条公路，可以运送0-n次的白菜<br>   当然从A到B的公路也可能不只一条。<br>   某一次运送白菜，可以在真正上路时才开通某一条道路<br>   一次运送不会影响别的运送的状态<br>   对应数据库<br>   A代表客户端进程<br>   B代表服务器端进程<br>   公路代表连接，<br>   运送一次白菜代表一个会话<br>   一个连接可以进行多次的会话<br>   一个会话可以不依赖于某个连接，甚至没有连接(当我准备好了，真正开始运送时再建立连接)<br>   一个会话不会影响别的会话</p>
<p><strong>会话&amp;链接</strong></p>
<hr>
<p>在具体的应用场景中连接(connction) 和 会话(session) 有很多情况：</p>
<p>\1. SQL*PLUS 登录 ORACLE</p>
<p>这种场景比较容易理解，一个连接对应一个Session。</p>
<p>\2. PL/SQL Developer工具登录ORACLE</p>
<p>PL/SQL Developer工具——&gt;首选项——&gt;连接下，你可以设置会话方式，如下图所示：</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029403907308.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024418595945.png" alt="clip_image001"></a></p>
<p>如果设置选项选择多路会话，：PL/SQL Developer 登录ORACLE，每打开一个窗口，将创建一个新的会话，而设置选项选择单路会话，则新打开的窗口会共用一个会话。具体你可以参考PLSQL Developer8.0用户指南：</p>
<p>多路会话：每个<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>窗口、SQL窗口和命令窗口都将有它自己的会话，另外的一个会话将被用于编译。这是最灵活的设置，明显地会导致最大数量的数据库会话。另外可能的缺点是，在更新被提交之后，它们只在X窗口中可以看到，而在Y窗口看不到。</p>
<p>双路会话：测试窗口、SQL窗口和命令窗口将共享一个会话，另外一个会话将被用于编译。这个模式的缺点是每次只有一个窗口可以运行程序。</p>
<p>单路会话：所有的窗口和所有的编译都使用同一个会话，这使事务管理变得很困难。在这个模式中调试器被禁用使用。如果你被限制只能使用一个数据库会话，那么你只能使用这个设置了。</p>
<hr>
<p><strong>会话&amp;进程</strong></p>
<hr>
<hr>
<p>在Oracle中如何查看参数sessiones或processes的值呢？一般使用show parameter命令查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter processes;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE                             VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ -------------------------------- ---------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aq_tm_processes                      integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db_writer_processes                  integer                          1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcs_server_processes                 integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">job_queue_processes                  integer                          10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log_archive_max_processes            integer                          2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processes                            integer                          850</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; show parameter session;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE                             VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ -------------------------------- -----------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_max_sessionspace_size           integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_soft_sessionspace_limit         integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_max_sessions                 integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_sessions_warning             integer                          0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logmnr_max_persistent_sessions       integer                          1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_cached_cursors               integer                          20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_max_open_files               integer                          10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                             integer                          940</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_server_sessions               integer</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt;</div></pre></td></tr></table></figure>
<p>方法2：查询v$parameter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select name, type, value ,display_value, isses_modifiable, issys_modifiable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$parameter</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where name=&apos;sessions&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select name, type, value ,display_value, isses_modifiable, issys_modifiable</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$parameter</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where name=&apos;processes&apos;;</div></pre></td></tr></table></figure>
<p>方法3：查询v$resiyrce_limit;</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029412658407.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024432651715.png" alt="clip_image002"></a></p>
<hr>
<p>Oracle的sessions和processes的数量关系是：</p>
<p><strong>Oracle 11g R1以及之前版本</strong></p>
<p>​             sessions=(1.1 * processes) + 5</p>
<p><strong>Oracle 11g R2</strong></p>
<p>​             sessions=(1.5 * processes) + 22</p>
<p>如下例子所示，在Oracle 10g 版本中，processes与sessions的关系如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; select * from v$version;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BANNER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">----------------------------------------------------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Oracle Database 10g Release 10.2.0.4.0 - 64bit Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PL/SQL Release 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CORE    10.2.0.4.0      Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TNS for Linux: Version 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NLSRTL Version 10.2.0.4.0 - Production</div></pre></td></tr></table></figure>
<p>SELECT (1.1 *850)+ 5 FROM DUAL; 其值刚好为940</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029423439977.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024451258114.png" alt="clip_image003"></a></p>
<p>一般修改参数processes后，sessions参数也会随之变化，但是有一个奇怪的现象时，如下所示，我将processes从</p>
<p>850改为120后，重启数据库实例，发现sessions的值并没有随之变化。这个现象一般发生在改小processes参数。为什么这样呢？</p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029435628505.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024471405297.png" alt="clip_image004"></a></p>
<p><a href="http://images.cnitblog.com/blog/73542/201411/160029449535748.png" target="_blank" rel="external"><img src="http://images.cnitblog.com/blog/73542/201411/160024492181696.png" alt="clip_image005"></a></p>
<p>共享服务器模式，一个会话可能由多个服务进程轮流为之服务，一个进程可能为多个会话服务。简单地说，进程和会话之间有一种多对多的关系。</p>
<hr>
<p><strong>会话管理</strong></p>
<p>1：查看当前所有用户的会话(SESSION)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME IS NOT NULL</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME , SID;</div></pre></td></tr></table></figure>
<p>其中Oracle内部进程的USERNAME为空</p>
<p>2：查看当前用户的所有SESSION：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME = USER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME, SID;</div></pre></td></tr></table></figure>
<p>3：查看当前窗口/当前用户的会话信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT SID, SERIAL#, STATUS FROM V$SESSION WHERE AUDSID=USERENV(&apos;SESSIONID&apos;);</div></pre></td></tr></table></figure>
<p>4：查看所有ACTIVE会话(活动会话)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$SESSION</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE USERNAME IS NOT NULL AND STATUS=&apos;ACTIVE&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY LOGON_TIME, SID;</div></pre></td></tr></table></figure>
<p>5：查看当前会话的ID可以通过如下脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM V$MYSTAT WHERE ROWNUM =1</div></pre></td></tr></table></figure>
<p>查看当前用户的SPID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT P.SPID, S.SID, S.SERIAL#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$PROCESS P</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INNER JOIN V$SESSION S ON P.ADDR = S.PADDR</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE S.AUDSID=USERENV(&apos;SESSIONID&apos;);</div></pre></td></tr></table></figure>
<p>6：查看数据库允许最大会话数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SHOW PARAMETER SESSIONS;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                                 TYPE        VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------------------------------ ----------- ------------------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_max_sessionspace_size           integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java_soft_sessionspace_limit         integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_max_sessions                 integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">license_sessions_warning             integer     0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logmnr_max_persistent_sessions       integer     1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                             integer     225</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_server_sessions               integer</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SELECT NAME, TYPE, VALUE FROM V$PARAMETER WHERE NAME LIKE &apos;session%&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NAME                       TYPE                 VALUE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">---------                 ----------             -----------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessions                          3                225</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_cached_cursors            3                20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">session_max_open_files            3                10</div></pre></td></tr></table></figure>
<p>7：查看曾经的最大会话数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SQL&gt; SELECT SESSIONS_MAX,SESSIONS_WARNING,SESSIONS_CURRENT,SESSIONS_HIGHWATER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2  FROM v$license;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> </div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SESSIONS_MAX SESSIONS_WARNING SESSIONS_CURRENT SESSIONS_HIGHWATER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">------------ ---------------- ---------------- ------------------</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0                0              512                553</div></pre></td></tr></table></figure>
<p>SESSIONS_HIGHWATER表示曾经的最大会话数512</p>
<p>8：查询那些应用的连接数此时是多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT  B.PROGRAM , COUNT(1)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$PROCESS A, V$SESSION B</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE A.ADDR = B.PADDR</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND  B.USERNAME IS NOT NULL</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GROUP BY B.PROGRAM;</div></pre></td></tr></table></figure>
<hr>
<p><strong>会话状态：</strong></p>
<p>会话有ACTIVE、INACTIVE、KILLED、CACHED、SNIPED五个状态，一般比较常见的有ACTIVE、INACTIVE、KILLED三个状态。</p>
<p>ACTIVE   ：处于此状态的会话，表示正在执行，处于活动状态。</p>
<p>INACTIVE ：处于此状态的会话表示不是正在执行的</p>
<p>KILLED   ：处于此状态的会话，表示出现了错误或进程被杀掉，正在回滚，当然，这个状态的会话也占用系统资源的。还有一点就是，    KILLED的状态一般会持续较长时间，如果你想快速杀掉回话，可以参考我以前的一篇文章<a href="http://www.cnblogs.com/kerrycode/p/4034231.html" target="_blank" rel="external">ORACLE快速彻底Kill掉的会话</a></p>
<p>CACHED   ： Session temporarily cached for use by Oracle*XA</p>
<p>SNIPED   ： Session inactive, waiting on the client。 标记为SNIPED的进程被释放有两种条件：</p>
<p>​         1、相关的terminal再一次试图登录及执行sql</p>
<p>​         2、手动的在<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>后台kill掉相应的spid</p>
<p>关于会话信息</p>
<p>通过如下SQL你可以查询你的每个应用程序到底在等待什么，从而针对这些信息对数据库的性能进行调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL USERNAME FOR A12;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL PROGRAM  FOR A32;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COL EVENT    FOR A26;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT S.USERNAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,S.PROGRAM</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,S.STATUS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.EVENT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TOTAL_WAITS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TOTAL_TIMEOUTS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.TIME_WAITED</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,SE.AVERAGE_WAIT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM V$SESSION S, V$SESSION_EVENT SE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE S.SID=SE.SID AND SE.EVENT NOT LIKE &apos;SQL*Net%&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND S.STATUS =&apos;ACTIVE&apos; AND S.USERNAME IS NOT NULL;</div></pre></td></tr></table></figure>
<p>2.ORACLE中查询被锁的表并释放session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT A.OWNER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,A.OBJECT_NAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDUSN</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDSLOT</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.XIDSQN</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.SESSION_ID</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.ORACLE_USERNAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.OS_USER_NAME</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.PROCESS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,B.LOCKED_MODE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.MACHINE</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.STATUS</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SERVER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SID</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.SERIAL#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,C.PROGRAM</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM ALL_OBJECTS A,V$LOCKED_OBJECT B,SYS.GV_$SESSION C</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE  A.OBJECT_ID = B.OBJECT_ID  AND B.PROCESS = C.PROCESS  ORDER BY 1,2;</div></pre></td></tr></table></figure>
<p>3.查看占用系统IO较大的session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT se.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.serial#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,pr.spid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.username</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.status</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.terminal</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.program</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.module</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,se.sql_address</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,st.event</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,st.p1text</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,si.physical_reads</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,si.block_changes</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM v$session se,v$session_wait st,v$sess_io si,v$process pr</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WHERE st.sid=se.sid  AND st.sid=si.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND se.paddr=pr.ADDR AND se.sid&gt;6</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AND st.wait_time=0 AND st.event NOT LIKE &apos;%SQL%&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ORDER BY physical_reads DESC;</div></pre></td></tr></table></figure>
<p>4.找出耗cpu较多的session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select a.sid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,spid</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,status</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,substr(a.program,1,40) prog</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,a.terminal</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,osuser</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">,value/60/100 value</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from v$session a,v$process b,v$sesstat c</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where c.statistic#=12 and c.sid=a.sid and a.paddr=b.addr</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">order by value desc</div></pre></td></tr></table></figure>
<hr>
<h1 id="object类的结构"><a href="#object类的结构" class="headerlink" title="object类的结构"></a>object类的结构</h1><p><img src="http://img.blog.csdn.net/20161205181623207" alt="Object类的函数"><br>如图可知，Object类有12个成员方法，按照用途可以分为以下几种<br>1，构造函数<br>2，hashCode和equale函数用来判断对象是否相同,<br>3，wait(),wait(long),wait(long,int),notify(),notifyAll()<br>4，toString()和getClass,<br>5，clone()<br>6，finalize()用于在垃圾回收</p>
<h1 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h1><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>clone()函数的用途是用来另存一个当前存在的对象。</p>
<h3 id="hashCode-和equale"><a href="#hashCode-和equale" class="headerlink" title="hashCode()和equale()"></a>hashCode()和equale()</h3><ul>
<li>equale()用于确认两个对象是否相同。</li>
<li>hashCode()用于获取对象的哈希值，这个值的作用是检索，具体的作用可以参考<a href="http://www.cnblogs.com/return/archive/2009/11/06/1597611.html" target="_blank" rel="external">这里</a></li>
<li>哈希值相同的对象不一定equale()</li>
<li>equale()返回true的两个对象一定相同。</li>
</ul>
<h3 id="toString-和getClass"><a href="#toString-和getClass" class="headerlink" title="toString()和getClass()"></a>toString()和getClass()</h3><p>toString()返回一个String对象，用来标识自己<br>getClass()返回一个Class对象，如果打印出来会发现结果是如下格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class package.name.xxx 11</div></pre></td></tr></table></figure>
<p>因为返回的是一个class对象,后面可以跟class类的方法。用的是谁的构造函数，那么getClass返回的就是谁的类型。<br>getClass()经常用于java反射机制</p>
<h3 id="wait-wait-long-wait-long-int-notify-notifyAll"><a href="#wait-wait-long-wait-long-int-notify-notifyAll" class="headerlink" title="wait(),wait(long),wait(long,int),notify(),notifyAll()"></a>wait(),wait(long),wait(long,int),notify(),notifyAll()</h3><ul>
<li>这几个函数体现的是Java的多线程机制</li>
<li>在使用的时候要求在synchronize语句中使用</li>
<li>wait()用于让当前线程失去操作权限，当前线程进入等待序列</li>
<li>notify()用于随机通知一个持有对象的锁的线程获取操作权限</li>
<li>notifyAll()用于通知所有持有对象的锁的线程获取操作权限</li>
<li>wait(long) 和wait(long,int)用于设定下一次获取锁的距离当前释放锁的时间间隔</li>
</ul>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>这个函数在进行垃圾回收的时候会用到，匿名对象回收之前会调用到，具体的例子如图所示</p>
<p><img src="http://img.blog.csdn.net/20161206085522582" alt="finalize函数说明"></p>
<p>Cookie和Session都是为了保持用户的访问状态，一方面为了方便业务实现，另一方面为了简化服务端的程序设计，提高访问性能。Cookie是客户端（也就是浏览器端）的技术，设置了Cookie之后，每次访问服务端，请求中都会带上Cookie；Session是服务端技术，在服务端存储用户的访问信息。</p>
<p>　　使用Cookie传递信息，随着Cookie个数增多和访问量增大，它占用的带宽会越来越大；使用Session保存信息，最大的弱点就是不容易在多台服务器之间共享。</p>
<p><strong>1 Cookie</strong></p>
<p>　　通俗地讲，当用户使用HTTP访问服务器时，服务器会将一些键值对信息返回给客户端浏览器，并且给这些数据加一些限制条件，在符合限制条件情况下用户下次访问服务器时，会带上之前设置的Cookie键值对信息。当该用户输入 URL 时，浏览器便会在本地硬盘上查找与该 URL 关联的 Cookie。如果该 Cookie 存在，浏览器便将该 Cookie 与页请求一起发送到您的站点。</p>
<p>　　Cookie 与网站关联，而不是与特定的页面关联。因此，无论用户请求站点中的哪一个页面，浏览器和服务器都将交换 Cookie 信息。用户访问不同站点时，各个站点都可能会向用户的浏览器发送一个 Cookie；浏览器会分别存储所有 Cookie。</p>
<p><strong>Cookie属性项</strong></p>
<p>　　当前Cookie有2个版本，Version 0 和 Version 1，它们有2种设置响应头标识，分别是”Set-Cookie”和”Set-Cookie2”。</p>
<p>Cookie 0属性值</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910374.png" alt="img"></p>
<p><strong>Cookie 1属性值</strong></p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910375.png" alt="img"></p>
<p>Java中使用Cookie示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</div><div class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</div><div class="line">PrintWriter out = response.getWriter();</div><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">String name = getCoodie(cookies, &quot;name&quot;);</div><div class="line">if (name == null) &#123;</div><div class="line">response.addCookie(new Cookie(&quot;name&quot;, &quot;luoxn28&quot;));</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">System.out.println(name);</div><div class="line">&#125;</div><div class="line">out.println(&quot;hello world&quot;);</div><div class="line">&#125;</div><div class="line">public static String getCoodie(Cookie[] cookies, String key) &#123;</div><div class="line">if (cookies != null) &#123;</div><div class="line">for (Cookie cookie : cookies) &#123;</div><div class="line">if (cookie.getName().equals(key)) &#123;</div><div class="line">return cookie.getValue();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910376.png" alt="img"></p>
<p>使用Cookie的一些注意事项（以Java使用为例）</p>
<p>•所创建的Cookie的name和value不能为非ASSIC字符，如果是中文，可以通过RRLEncoder将其编码，否则会抛出java.lang.IllegalArgumentException异常。</p>
<p>•多出现多个name和value值时，它们实在同一个”Cookie”头中的。</p>
<p>•Cookies的值中可以保存除了“;”以外的标点符号。但是不能保存汉字。保存汉字会出现乱码。</p>
<p><strong>Cookie的一些限制</strong></p>
<p>　　Cookie是HTTP头中的一个字段，HTTP本身对该字段没有限制，但是Cookie最终存储在浏览器中，不同的浏览器对Cookie的存储有一些限制，如下表所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910377.png" alt="img"></p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910378.png" alt="img"></p>
<p>　　如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。</p>
<p><strong>2 Session</strong></p>
<p>　　Session解决了Cookie增多时会增加客户端与服务器的数据传输量问题，同一个客户端与服务器交互时，不需要每次都传回所有的Cookie值，而是只要传回一个ID值，这个ID是客户端第一次访问服务器时生成的，而且每个客户端是唯一的，这个ID通常是name为JSESSIONID的一个Cookie。</p>
<p>　　Session是如何基于Cookie工作的呢，可以是基于URL Path Parameter方式；也可以是基于Cookie，如果没有修改Context容器中的Cookies标识，则默认也是支持的。当浏览器不支持Cookie功能时，浏览器会将用户的SessionCookieName重写到用户请求的URL参数中，它的传递方式如/path/Servlet;name=xxx;name2=xxx2?name3=xxx3。SessionCookieName如果在web.xml中配置session-config配置项，其cookie-config下的name属性就是这个SessionCookieName的值。如果没有配置session-config配置项，默认的SessionCookieNamejiushi “JSESSIONID”。注意，与Session关联的Cookie与其他Cookie并没有什么不同。如果客户端也支持Cookie，则Tomcat仍会解析Cookie中的Session ID，并会覆盖URL中的Session ID。</p>
<p><strong>Session如何工作</strong></p>
<p>　　有了Session ID，服务器就可以创建HttpSession对象了，第一次调用request.getSession()方法，如果没有对应的HttpSession对象，则会创建一个新的，并将这个对象加入到org.apache.catalina.Manager的sessions容器中保存。Manage保存所有的session生命周期，Session过期被回收，服务器关闭，Session被序列化到磁盘。注意，一个客户端对应一个Session对象，这个对象正是保存我们创建的Session值的。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/201609240910379.png" alt="img"></p>
<p>　　request.getSession()方法调用的StandardSession永远都会存在，即使与这个客户端关联的Session已经过期。如果过期，则会创建一个新的，但是以前设置的Session值将会丢失。</p>
<p><strong>3 Cookie与Session安全性比较</strong></p>
<p>　　Cookie将保存的数据通过HTTP头部从客户端传到服务端，从服务端再传回到客户端，所有的数据都保存在客户端浏览器中，这些数据都是可以访问到的，甚至可以通过插件添加、修改Cookie，所有Cookie的安全性是比较差的。相比较而言，Session将数据保存在服务器端，安全性高很多，只需要Cookie传回一个Cookie ID就可以，所以Session更适合保存用户隐私和重要的数据。</p>
<p><strong>分布式Session框架</strong></p>
<p>　　在大型互联网应用中，单用Cookie和Session都是不可行的，因为如果使用Cookie可以很好地解决应用的分布式部署问题，大型互联网应用系统一个应用有上百台机器，而且有很多不同的应用系统协同工作，由于Cookie是将数据存储在用户浏览器中，用户每次访问都会讲数据带回到服务器，也就解决了同一个用户的请求在不同服务器上处理而导致的Cookie不一致问题。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/2016092409103710.png" alt="img"></p>
<p>　　由于应用是一个集群，所以不能将Session都保存在每台服务器的内存中，如果每台服务器有几十万访问用户，服务器内存也容不下，即使容得下，也无法保证该Session同步到其他服务器中，所以共享这些Session需要将它们保存在专门的分布式缓存中，可以随时读取和写入，性能要够好满足要求，如memcache/redis或者淘宝的开源分布式框架Tair都是很好的选择。</p>
<p><strong>表单重复提交问题</strong></p>
<p>　　网站中有很多地方有重复提交表单问题，为了防止表单重复提交，就要标识用户的每一次访问请求，使得每一次访问请求对服务端来说都是唯一的，为了标识用户的每次请求，可以在用户请求的表单域增加一个隐藏表单项，其值为唯一的token，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form id=&quot;form&quot; method=&quot;post&quot;&gt;</div><div class="line">...</div><div class="line">&lt;input type=hidden name=&quot;token&quot; value=&quot;xxx&quot;/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>　　用户请求表单时生成唯一的token，并且设置到该用户的Session中，等用户提交时检测这个token是否和Session中保存的token一致，如果一致，说明没有重复提交，同时把Session中的token更新成一个新的token值；否则用户提交上来的token已经不是当前请求的合法token，提交失败。</p>
<p><img src="http://files.jb51.net/file_images/article/201609/2016092409103711.png" alt="img"></p>
<p>以上所述是小编给大家介绍的Java中Cookie和Session的那些事儿，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！</p>
<p>当某个用户发出页面请求时，WEB服务器只是简单的进行响应，然后就关闭与该用户的连接，请求的相关数据将不再存在，这样明显有不好的地方。cookie和session解决了这一问题，客户端(一般是浏览器)与服务器之间的交互，将操作所涉及的数据记录下来，保存在cookie（保存在浏览器客户端）或者session（保存在服务器）中。</p>
<h2 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h2><p>1、什么是cookie</p>
<p>浏览器在访问服务器时，服务器将一些数据以 set-cookie 消息头的形式发送给浏览器。浏览器会将这些数据保存起来。当浏览器再次访问服务器时，会将这些数据以 cookie 消息头的形式发送给服务器。</p>
<p>2、创建 cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Cookie cookie = new Cookie(String name,String value);</div><div class="line">response.addCookie(cookie);1212</div></pre></td></tr></table></figure>
<p>cookie的name不可以重复，和Map集合类似，当有重复的name的时候，会替代。</p>
<p>3、查询cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//如果没有 cookie，则返回 null。</div><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">String name = cookie.getName();</div><div class="line">String value = cookie.getValue();12341234</div></pre></td></tr></table></figure>
<p>4、cookie 保存时的编码问题</p>
<p>cookie 的值叧能是ascii 字符，如果是中文，需要将中文转换成 ascii 字符形式。可以使用 URLEncoder.encode()方法和 URLDecoder.decode()方法来进行这种转换。</p>
<p>5、cookie 的保存时间</p>
<p>cookie.setMaxAge(int seconds);//单位为秒<br> seconds &gt; 0<br>浏览器会将 cookie 以文件的方式保存在硬盘上。在超过指定的时间以后，会删除该文件。<br> seconds &lt; 0<br>默认值，浏览器会将 cookie 保存在内存里面。叧有当浏览器关闭以后，才会删除。<br> seconds = 0<br>立即删除该 Cookie</p>
<p>6、删除 cookie</p>
<p>比如要删除一个 name 为”username”的 cookie。<br>Cookie c = new Cookie(“username”,”“);<br>c.setMaxAge(0);<br>cookie.setPath(request.getContextPath());//路径<br>response.addCookie(c);</p>
<p>7、cookie 的限制</p>
<p> cookie 可以禁止<br> cookie 的大小有限制(4k 左右)<br> cookie 的数量也有限制(浏览器大约能保存 300 个)<br> cookie 的值叧能是字符串，要考虑编码问题。<br> cookie 不安全</p>
<p>8、cookie 的路径问题</p>
<p>浏览器在向服务器上的某个地址发送请求时，会先比较 cookie 的路径不向访问的路径(地址)是否匹配， 叧有匹配的 cookie， 才会发送。<br>cookie 的路径可以通过 cookie.setPath(String path)方法来设置。如果没有设置, 则有一个缺省的路径，缺省的路径是生成该 cookie 的组件的路径。<br>比如: /appname/addCookie 保存了一个 cookie,则该 cookie 的路径就是/appname/addCookie。<br>规则:<br>cookie 的路径必须是要访问的路径的上层目录戒者是不要访问的路径相等， 浏览器才会将 cookie 发送给服务器。一般可以设置 setPath(“/appname”),表示访问该应用下的所有地址，均会发送</p>
<h2 id="二、session"><a href="#二、session" class="headerlink" title="二、session"></a>二、session</h2><p>1、什么是session</p>
<p>浏览器访问服务器时，服务器会创建一个 session 对象(该对象有一个唯一的 id, 一般称为 sessionId)。服务器在缺省情况下，会将 sessionId 以 cookie 机制发送给浏览器。当浏览器再次访问服务器时， 会将sessionId 发送给服务器。 服务器依据 sessionId 就可以找到对应的 session 对象。</p>
<p>2、如何获得 session 对象</p>
<p>HttpSession session = request.getSession();</p>
<p>3、HttpSession 接口提供的一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获得 sessionId。</div><div class="line">String session.getId();</div><div class="line">//绑订数据</div><div class="line">session.setAttribute(String name,Object obj);</div><div class="line">//获取数据</div><div class="line">Object session.getAttribute(String name);</div><div class="line">//删除绑定</div><div class="line">session.removeAttribute(String name);1234567812345678</div></pre></td></tr></table></figure>
<p>4、session保存时间设置</p>
<p>服务器会将超过指定时间的 session 对象删除(在指定的时间内，该 session 对象没有<br>使用)。<br>两种设置方式：<br>方式一：<br>session.setMaxInactiveInterval(int seconds);<br>方式二：<br>服务器有一个缺省的超时限制，可以通过相应的配置文件来重新设置。比如可以修改 tomcat 的 web.xml(tomcat_home/conf 下面)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-config&gt;</div><div class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</div><div class="line">&lt;/session-config&gt;123123</div></pre></td></tr></table></figure>
<p>另外，也可以叧修改某个应用的 web.xml。</p>
<p>5、session删除</p>
<p>session.invalidate();</p>
<h2 id="三、用cookie记录最近10条记录"><a href="#三、用cookie记录最近10条记录" class="headerlink" title="三、用cookie记录最近10条记录"></a>三、用cookie记录最近10条记录</h2><p>用cookie查询最近一个月请求的前10条历史记录。cookie的中文要求转码和解码。如下图<br><img src="http://img.blog.csdn.net/20160805132326366" alt="这里写图片描述"></p>
<p>1、加入cookie到客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cookie[] cookies = request.getCookies();//浏览器在第一请求时调用该方法会返回null</div><div class="line">//浏览器第一次请求返回到浏览器之前会创建一个名为JSESSIONID 的cookie</div><div class="line">//param（请求参数）中文转码</div><div class="line">String paramEnd = URLEncoder.encode(param);</div><div class="line">Cookie cookie = new Cookie(&quot;param&quot;+cookies.length,paramEnd);//name不可以重复</div><div class="line">cookie.setMaxAge(60*60*24*30);//保留一个月的时间</div><div class="line">response.addCookie(cookie);//cookie在第一次加入时会创建一个JSESSIONID cookie12345671234567</div></pre></td></tr></table></figure>
<p>2、获取所有满足条件的cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Cookie[] cookies = request.getCookies();</div><div class="line">if(cookies!=null &amp;&amp; cookies.length&gt;0)&#123;</div><div class="line">    Map&lt;String,Object&gt; historyPar =  (Map&lt;String, Object&gt;)new ListOrderedMap();//按存入顺序取出,HashMap并不是按存入顺序取出</div><div class="line">    for(int i=cookies.length-1;i&gt;=0;i--)&#123;</div><div class="line">        Cookie cookie = cookies[i];</div><div class="line">        String cookVal = URLDecoder.decode(cookie.getValue());</div><div class="line">        if(cookie.getName().startsWith(&quot;param&quot;))&#123;</div><div class="line">            if(historyPar.size()==10) break;//查询最近10条记录</div><div class="line">            historyPar.put(cookVal, cookVal);//map的key值用cookie的value，以免历史记录重复</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    model.addAttribute(&quot;historyPar&quot;,historyPar);</div><div class="line">&#125;1234567891011121312345678910111213</div></pre></td></tr></table></figure>
<p>3、js实现历史清除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//删除该路径下所有cookie</div><div class="line">    function cleanCookie()&#123;</div><div class="line">         var keys=document.cookie.match(/[^ =;]+(?=\=)/g);</div><div class="line">         if (keys) &#123;</div><div class="line">            for (var i =  keys.length; i--;)&#123;</div><div class="line">               document.cookie=keys[i]+&apos;=0;expires=&apos; + new Date( 0).toUTCString()</div><div class="line">            &#125;</div><div class="line">         &#125;  </div><div class="line">         window.location.href=&quot;$&#123;ctx&#125;/searchController/globalSearch&quot;;</div><div class="line">    &#125;1234567891012345678910</div></pre></td></tr></table></figure>
<p>至此即可查询出最近一个月的前10条历史记录。</p>
<p>死锁是两个甚至多个线程被永久阻塞时的一种运行局面，这种局面的生成伴随着至少两个线程和两个或者多个资源。在这里我已写好一个简单的程序，它将会引起死锁方案然后我们就会明白如何分析它。</p>
<h1 id="Java死锁范例"><a href="#Java死锁范例" class="headerlink" title="Java死锁范例"></a>Java死锁范例</h1><p>ThreadDeadlock.java</p>
<p>在上面的程序中同步线程正完成Runnable的接口，它工作的是两个对象，这两个对象向对方寻求死锁而且都在使用同步阻塞。</p>
<p>在主函数中，我使用了三个为同步线程运行的线程，而且在其中每个线程中都有一个可共享的资源。</p>
<p>这些线程以向第一个对象获取封锁这种方式运行。但是当它试着像第二个对象获取封锁时，它就会进入等待状态，因为它已经被另一个线程封锁住了。这样，在线程引起死锁的过程中，就形成了一个依赖于资源的循环。</p>
<p>当我执行上面的程序时，就产生了输出，但是程序却因为死锁无法停止。</p>
<p>在此我们可以清楚地在输出结果中辨认出死锁局面，但是在我们实际生活所用的应用中，发现死锁并将它排除是非常难的。</p>
<h1 id="分析死锁"><a href="#分析死锁" class="headerlink" title="分析死锁"></a>分析死锁</h1><p>为了分析一个死锁，我们需要关注下应用中的<a href="http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java" target="_blank" rel="external">Java线程转存</a>，在上一节中我已经解释了如何使用VisualVM收集资料或者jstack应用程序<a href="http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java" target="_blank" rel="external">产生线程转存</a>。</p>
<p>以下就是上述程序的线程转存。</p>
<p>这三个线程转存的输出清楚地说明了死锁环境和线程，以及包含死锁环境的资源。</p>
<p>为了分析死锁，我们需要关注死锁状态的线程，然后资源再等待去封锁，每一个资源都有一个独特的ID，有了这个ID我们就能发现是哪一个进程已经封锁住对象。举个例子，线程“t3”正在等待封锁0x000000013df2f658,但是它已经被线程“t1”封锁住了。</p>
<p>当我们分析死锁环境的时候，如果发现线程正在引起死锁，这是我们就要改变代码来避免死锁的产生。</p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>有很多方针可供我们使用来避免死锁的局面。</p>
<ul>
<li><strong>避免嵌套封锁：</strong>这是死锁最主要的原因的，如果你已经有一个资源了就要避免封锁另一个资源。如果你运行时只有一个对象封锁，那是几乎不可能出现一个死锁局面的。例如，这里是另一个运行中没有嵌套封锁的run()方法，而且程序运行没有死锁局面，运行得很成功。</li>
</ul>
<ul>
<li><strong>只对有请求的进行封锁：</strong>你应当只想你要运行的资源获取封锁，比如在上述程序中我在封锁的完全的对象资源。但是如果我们只对它所属领域中的一个感兴趣，那我们应当封锁住那个特殊的领域而并非完全的对象。</li>
<li><strong>避免无限期的等待：</strong>如果两个线程正在等待对象结束，无限期的使用线程加入，如果你的线程必须要等待另一个线程的结束，若是等待进程的结束加入最好准备最长时间。</li>
</ul>
<h1 id="Mysql并发时经典常见的死锁原因及解决方法"><a href="#Mysql并发时经典常见的死锁原因及解决方法" class="headerlink" title="Mysql并发时经典常见的死锁原因及解决方法"></a><a href="http://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="external">Mysql并发时经典常见的死锁原因及解决方法</a></h1><p> <strong>1.    **</strong>mysql<strong>**都有什么锁</strong></p>
<p>MySQL有三种锁的级别：页级、表级、行级。</p>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>算法：</p>
<p>next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap    </p>
<p>Gap锁，不锁记录，仅仅记录前面的Gap</p>
<p>Recordlock锁（锁数据，不锁Gap）</p>
<p>所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</p>
<p><strong>2.    **</strong>什么情况下会造成死锁**</p>
<p>所谓死锁<deadlock>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</deadlock></p>
<p>死锁的关键在于<strong>：两个(**</strong>或以上)<strong><strong>的Session</strong></strong>加锁的顺序<strong>**不一致。</strong></p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<p><strong>3.    **</strong>一些常见的死锁案例**</p>
<p><strong>案例一：</strong></p>
<p>需求：将投资的钱拆成几份随机分配给借款人。</p>
<p>起初业务程序思路是这样的：</p>
<p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p>
<p>抽象出来就是一个session通过for循环会有几条如下的语句：</p>
<p>Select * from xxx where id=’随机id’ for update</p>
<p>基本来说，程序开启后不一会就死锁。</p>
<p>这可以是说最经典的死锁情形了。</p>
<p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p>
<p>B用户金额随机分为2份，分给借款人2，1</p>
<p>由于加锁的顺序不一样，死锁当然很快就出现了。</p>
<p><strong>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</strong></p>
<p><strong>Select * from xxx where id in (xx,xx,xx) for update</strong></p>
<p><strong>在in**</strong>里面的列表值mysql<strong>**是会自动从小到大排序，加锁也是一条条从小到大加的锁</strong></p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">例如（以下会话id为主键）：</div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id in (8,9) for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">|  8 | WA     | f    | 2016-03-02 11:36:30 |</div><div class="line"></div><div class="line">|  9 | JX     | f    | 2016-03-01 11:36:30 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">2 rows in set (0.04 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">select * from t3 where id in (10,8,5) for update;</div><div class="line"></div><div class="line">锁等待中……</div><div class="line"></div><div class="line">其实这个时候id=10这条记录没有被锁住的，但id=5的记录已经被锁住了，锁的等待在id=8的这里。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">不信请看</div><div class="line"></div><div class="line">Session3:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id=5 for update;</div><div class="line"></div><div class="line">锁等待中</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session4:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id=10 for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| 10 | JB     | g    | 2016-03-10 11:45:05 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">在其它session中id=5是加不了锁的，但是id=10是可以加上锁的。</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>案例2**</strong>：**</p>
<p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">以id为主键为例，目前还没有id=22的行</div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">select * from t3 where id=22 for update;</div><div class="line"></div><div class="line">Empty set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">session2:</div><div class="line"></div><div class="line">select * from t3 where id=23  for update;</div><div class="line"></div><div class="line">Empty set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">insert into t3 values(22,&apos;ac&apos;,&apos;a&apos;,now());</div><div class="line"></div><div class="line">锁等待中……</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">insert into t3 values(23,&apos;bc&apos;,&apos;b&apos;,now());</div><div class="line"></div><div class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>当对存在的行进行锁的时候(主键)，mysql就只有行锁。</p>
<p>当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</p>
<p>锁住的范围为：</p>
<p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p>
<p>如：如果表中目前有已有的id为（11 ， 12）</p>
<p>那么就锁住（12，无穷大）</p>
<p>如果表中目前已有的id为（11 ， 30）</p>
<p>那么就锁住（11，30）</p>
<p><strong>对于这种死锁的解决办法是：</strong></p>
<p><strong>insert into t3(xx,xx) on duplicate key update <code>xx</code>=’XX’;</strong></p>
<p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p>
<p><strong>案例3**</strong>：**</p>
<p>直接上情景：</p>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t3 where id=9 for update;</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">| id | course | name | ctime               |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">|  9 | JX     | f    | 2016-03-01 11:36:30 |</div><div class="line"></div><div class="line">+----+--------+------+---------------------+</div><div class="line"></div><div class="line">1 row in set (0.00 sec)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session2:</div><div class="line"></div><div class="line">mysql&gt; select * from t3 where id&lt;20 for update;</div><div class="line"></div><div class="line">锁等待中</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Session1:</div><div class="line"></div><div class="line">mysql&gt; insert into t3 values(7,&apos;ae&apos;,&apos;a&apos;,now());</div><div class="line"></div><div class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</div></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="external"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p>
<p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p>
<p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p>
<p>需要用以下模式来设定锁定模式</p>
<p>1、SELECT …… LOCK IN SHARE MODE（共享锁）<br>查询到的数据，就是数据库在这一时刻的数据（其他已commit事务的结果，已经反应到这里了）<br>SELECT 必须等待，某个事务结束后才能执行</p>
<p>2、SELECT …… FOR UPDATE（排它锁）<br>例如 SELECT * FROM tablename WHERE id&lt;200<br>那么id&lt;200的数据，被查询到的数据，都将不能再进行修改、删除、SELECT …… LOCK IN SHARE MODE操作<br>一直到此事务结束</p>
<p>共享锁 和 排它锁 的区别：在于是否阻断其他客户发出的 SELECT …… LOCK IN SHARE MODE命令</p>
<p>3、INSERT / UPDATE / DELETE<br>所有关联数据都会被锁定，加上排它锁</p>
<p>4、防插入锁<br>例如 SELECT * FROM tablename WHERE id&gt;200<br>那么id&gt;200的记录无法被插入</p>
<p>5、死锁<br>自动识别死锁<br>先进来的进程被执行，后来的进程收到出错消息，并按ROLLBACK方式回滚<br>innodb_lock_wait_timeout = n 来设置最长等待时间，默认是50秒</p>
<p>附记，推荐两篇好文章</p>
<p>案例4：</p>
<p><a href="http://hedengcheng.com/?p=844" target="_blank" rel="external">http://hedengcheng.com/?p=844</a></p>
<p>MySQL 加锁处理分析：</p>
<p><a href="http://hedengcheng.com/?p=771" target="_blank" rel="external">http://hedengcheng.com/?p=771</a></p>
<p>Skip lists are a data structure that can <strong>be used in place of balanced trees</strong>. Skip lists use <strong>probabilistic balancing</strong> rather than strictly enforced balancing and as a result the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/JVM-的GC机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/JVM-的GC机制/" itemprop="url">
                  JVM 的GC机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-15T20:36:40+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h1><p>参考链接：Where Has the Java PermGen Gone?    <a href="https://www.infoq.com/articles/Java-PERMGEN-Removed" target="_blank" rel="external">https://www.infoq.com/articles/Java-PERMGEN-Removed</a></p>
<h3 id="永久代和元空间"><a href="#永久代和元空间" class="headerlink" title="永久代和元空间"></a>永久代和元空间</h3><h4 id="1-7以及1-7之前"><a href="#1-7以及1-7之前" class="headerlink" title="1.7以及1.7之前"></a><strong>1.7以及1.7</strong>之前</h4><p>Java<u>类对象的元数据</u>存放在<strong>方法区</strong>，也就是所谓的<strong><em>老年代</em></strong></p>
<p>类对象的元数据<!--：待查询--></p>
<h5 id="永久代的性质："><a href="#永久代的性质：" class="headerlink" title="永久代的性质："></a>永久代的性质：</h5><p>1.使用<strong><u>-XX:MaxPermSize</u></strong>来设置内存的大小  默认情况下32位为64M 64位为85M</p>
<p>2.当类的元数据超过设置的阈值，发生OOM的错误</p>
<p>3.永久代和老年代的垃圾回收是绑定的，一旦一个区域被占满，两个区都要进行回收</p>
<h4 id="1-8以及之后"><a href="#1-8以及之后" class="headerlink" title="1.8以及之后"></a>1.8以及之后</h4><p>Java的<u>类对象的元数据</u>存放在<strong>元空间</strong>—<u>本地的内存区域</u></p>
<p><em>为什么发生这个改变？</em></p>
<p>1.永久代的调优很困难<!--：待查询--> 垃圾回收器需要特殊处理永久代的元数据</p>
<p>2.每一次Full GC永久代的数据都可能发生移动</p>
<p><em>好处呢？</em></p>
<p>1.实现对元空间的无缝管理 简化Full GC</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>perm gen 含class metadata、class static variables 和 interned string<!--：待查询--> </p>
<p>metaspace只含class metadata了，class static variables 和 interned string被移到java heap上</p>
<h4 id="如何管理"><a href="#如何管理" class="headerlink" title="如何管理"></a>如何管理</h4><p>负责管理对象：元空间虚拟机(C++)</p>
<h5 id="内存分配方式及其特点："><a href="#内存分配方式及其特点：" class="headerlink" title="内存分配方式及其特点："></a>内存分配方式及其特点：</h5><p>1.虚拟机中存在一个全局的空闲组块链表，每个类加载器可以从中获取并自己维护，当类加载不再存活时，释放相应的组块，同时由该类加载器加载的类对象元数据也会被清空<!--：类加载器什么时候不存活？--></p>
<p>2.组块的大小因类加载的类型而异<!--：什么意思？ 就是每个组块的大小不同而且与分配的区块大小不一致，导致内存碎片！！！--></p>
<p>3.每个组块实际上是虚拟内存映射区域的内存，虚拟内存映射区域以链表的形式链接<!--：VM是啥？--></p>
<p>4.组块由更小的单元块组成，每个块存储一个单元的元信息</p>
<h4 id="如何调优"><a href="#如何调优" class="headerlink" title="如何调优"></a>如何调优</h4><p>可以使用-XX:MaxMetaspaceSize限制其大小 64位的服务器JVM来说默认值为21M 建议设置为一个较高值</p>
<h5 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h5><p>1.一旦触及这个值，便会触发<strong>Full GC</strong>，并重新设置该值(根据释放的元空间大小进行调整)</p>
<p>2.使用-XX:MinMetaspaceFreeRatio和-XX:MaxMetaspaceFreeRatio设置元空间空闲比例的最大值和最小值</p>
<h5 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h5><p><strong>jmap -clstats PID</strong> (JDK8)   打印类加载数据</p>
<p><strong>jstat -gc LVMID</strong>                打印元空间的信息</p>
<p><strong>jcmd PID GC.class_stats</strong>   打印类对象元数据的统计信息</p>
<hr>
<p>参考链接：<a href="https://www.javacodegeeks.com/2015/03/minor-gc-vs-major-gc-vs-full-gc.html" target="_blank" rel="external">https://www.javacodegeeks.com/2015/03/minor-gc-vs-major-gc-vs-full-gc.html</a></p>
<p>​            <a href="http://blog.csdn.net/chenleixing/article/details/46706039" target="_blank" rel="external">http://blog.csdn.net/chenleixing/article/details/46706039</a></p>
<p>​            <a href="http://blog.csdn.net/yhyr_ycy/article/details/52566105" target="_blank" rel="external">http://blog.csdn.net/yhyr_ycy/article/details/52566105</a></p>
<h3 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h3><h4 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h4><p>什么时候：外部调用System.gc()  或者 JVM根据内存的使用情况决定进行GC</p>
<p>回收什么：回收通过可达性分析搜索不到的对象</p>
<p>回收过程：具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮询扫描To Space区一定次数后，把依然存活的对象复制到老年代(对象的年龄超过设置的阈值)，然后释放To Space区的对象</p>
<p>回收一个对象，至少需要经过<strong>两次标记</strong>的过程</p>
<p>第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。</p>
<p>第二次标记：如果被筛选判定为有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列</p>
<h4 id="minor-GC"><a href="#minor-GC" class="headerlink" title="minor GC"></a>minor GC</h4><p>从年轻代(Eden和survivor区)回收的内存</p>
<p>1.执行Minor GC时不会影响永久代(！！！1.8之后不存在永久代的概念)</p>
<p>触发条件：eden的内存满了</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p><em>major GC</em>    清理老年代</p>
<p><em>Full GC</em>         清理整个堆空间</p>
<h5 id="触发Full-GC的条件："><a href="#触发Full-GC的条件：" class="headerlink" title="触发Full GC的条件："></a>触发Full GC的条件：</h5><p>1.System.gc()方法调用会建议JVM进行Full GC</p>
<p>2.老年代空间不足  </p>
<p>原因：进行Minor GC新生代转入大量大对象或者大数组</p>
<p>优化:   让对象在Minor GC阶段被回收  不要创建过大的对象那个或者数组</p>
<p>3.CMS GC出现<strong>promotion failed</strong> 和<strong>concurrent mode failure</strong></p>
<p>promotion failed  进行Minor GC时 survivor space空间放不下 同时老年代也放不下的时候抛出的异常</p>
<p>cocurrent mode failure  同时有对象需要放入老年代，同时老年代空间不足导致</p>
<p>优化：增大survivor和老年代的空间 降低触发并发gc的比率</p>
<p>4.统计得到的Minor GC晋升到老年代的平均大小超过老年代剩余的空间</p>
<p>5.堆中分配需要很大连续内存的对象需要直接分配到老年代，并且老年代没有足够连续的内存存放对象</p>
<p>优化：使用-XX:+UseCMSCompactAtFullCollection 进行碎片整理</p>
<p>​       也可以使用-XX:CMSFullGCsBeforeCompaction设置在进行k次full GC之后进行压缩式的Full GC</p>
<h5 id="另一种分类方法：-针对HotSpot的实现"><a href="#另一种分类方法：-针对HotSpot的实现" class="headerlink" title="另一种分类方法： 针对HotSpot的实现"></a>另一种分类方法： 针对HotSpot的实现</h5><p>Partial GC：并不收集整个GC堆的模式</p>
<ul>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：     只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
<p>Full GC：收集整个堆</p>
<h5 id="serial-GC"><a href="#serial-GC" class="headerlink" title="serial GC"></a>serial GC<!--：其他gc收集器待补充--></h5><ol>
<li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li>
<li>full GC：当准备要触发一次young GC时，如果发现<strong>统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有<strong>perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC</strong>；或者<strong>System.gc()、heap dump带GC</strong>，默认也是触发full GC</li>
</ol>
<p>并发GC的触发条件就不太一样。以CMS GC为例，它主要是<strong>定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC</strong>，对old gen做并发收集</p>
<hr>
<h3 id="垃圾回收的算法"><a href="#垃圾回收的算法" class="headerlink" title="垃圾回收的算法"></a>垃圾回收的算法</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/09/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/shell/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T23:24:08+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>远程执行hadoop job和shell命令</p>
<p>1.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/09/DynamicProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/DynamicProgramming/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T22:00:16+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Dynamic Programming</p>
<p>1.字符串匹配<br>   String s     匹配串<br>   String p     模式串 包含.和<em><br>   ‘.’ Matches any single character.<br>   ‘</em>‘ Matches zero or more of the preceding element.</p>
<p>   字符串匹配的动态规划数组通常以字符串的长度和位置作为数组的下标</p>
<p>   boolean[][] state = new boolean[s.length + 1][p.length + 1]</p>
<p>   边界条件<br>   state[0][j]  : 匹配串为空 查看模式串能否匹配空字符串<br>   state[0][j] =  state[0][j - 1]                         j = 1 &amp; p.charAt(j - 1) = <em><br>                   =  state[0][j - 2] || state[0][j - 1] j &gt; 1 &amp; p.charAt(j - 1) = </em><br>                   =  false                                    p.charAt(j - 1) != *</p>
<pre><code>状态转移方程：
state[i][j] =  state[i - 1][j - 1]  s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == &apos;.&apos;
              =  state[i][j - 2]        p.charAt(j - 1) == &apos;*&apos; &amp;&amp; s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != &apos;.&apos;
              =  state[i - 1][j] || state[i][j - 1] || state[i][j - 2]
</code></pre><p>2.LongestValidParentheses</p>
<p>3.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/29/virtual_machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/29/virtual_machine/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-29T16:22:36+08:00">
                2016-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>###title: 虚拟机</p>
<p>###tags:虚拟机</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/29/shell_command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/29/shell_command/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-29T14:57:04+08:00">
                2016-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>###title: shell command</p>
<p>###date: 2016-11-06 13:27:24</p>
<p>###tags: shell command</p>
<hr>
<p>xargs</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/28/html&jquery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/28/html&jquery/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-28T16:12:05+08:00">
                2016-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h2>jquery功能整理</h2><br><br><p></p>
<h4>· 页面的初始加载函数 <br><br>&nbsp; &nbsp; 1.  jquery —-  $(document).ready(function () {} ) <br><br>&nbsp; &nbsp; 2. javascript – window.onload=function(){ }   或  $(function(){ }<br><br> 区别：<br><br>&nbsp; &nbsp; 1.会在DOM完全就绪并可以使用时调用。虽然这也意味着所有元素对脚本而言都是可以访问的，但是，并不意味着所有关联的文件都已经下载完毕。换句话说，当HMTL下载完成并解析为DOM树之后，代码就会执行。 <br><br>&nbsp; &nbsp; 2. 当一个文档完全下载到浏览器中时，才会触发window.onload事件。这意味着页面上的全部元素对js而言都是可以操作的，也就是说页面上的所有元素加载完毕才会执行。这种情况对编写功能性代码非常有利，因为无需考虑加载的次序<br></h4><br><br><br><br>——————————————-<br><br><br><br><h4><br>· ajaxRequest异步调用<br><br>&nbsp; &nbsp; 代码：<br><br><br><pre><code><br>var tseg = {<br>    _ajax_timeout: 60 <em> 1000,// 全局默认ajax请求超时时间<br>    _data_refresh: 60 </em> 1000,// 数据默认刷新频率 3分钟<br><br>    /<em> 请求Url </em>/<br>    getUrl: function (code) {<br>        if (!code)<br>            return;<br>        switch (code) {<br>            default:<br>                console.log(code);<br>                break;<br>        }<br>        return code;<br>    }<br>};<br><br>/<em> ajax调用 </em>/<br>var ajaxRequest = function (success, error, code, params, type) {<br><br>    $.ajax({<br>        url: tseg.getUrl(code),// 此处url需要在调用处赋值<br>        type: “get”,<br>        dataType: type,<br>        traditional: true,<br>        async: true,<br>        data: params || {},<br>        timeout: tseg._ajax_timeout,<br>        success: function (JsonStr) {<br>            success(JsonStr);<br>        },<br>        error: function (XMLHttpRequest, textStatus, errorThrown) {<br>            error(textStatus);<br>        }<br>    });<br>}<br><br>var error = function (msg) {<br>    console.log(“happend exception:”);<br>    console.log(msg);<br>};<br><br>window.tseg = tseg;<br>window.ajaxRequest = ajaxRequest;<br>window.error = error;<br></code></pre><br></h4><br><br><br><br><br>——————<br><br><h4><br>·  下拉框的插件<br><br><a href="https://github.com/ehynds/jquery-ui-multiselect-widget" target="_blank" rel="external">https://github.com/ehynds/jquery-ui-multiselect-widget</a><br><br>引入文件 –一共5个文件<br><br><pre><br>js/jquery.min.js<br>js/jquery-ui.min.js<br>js/jquery.multiselect.js<br>css/jquery-ui.css<br>css/jquery.multiselect.css<br></pre><br>html代码：<br><br>申明:<br><pre>select id=”s_office” multiple=”multiple” name=”example-basic”<br></pre><br>初始化：<br><pre><br>$(“选择器”).multiselect({<br>   noneSelectedText: “”,<br>   multiple: false,<br>   header: false,<br>   selectedList: 1…<br>});<br></pre><br>插入option：<br><pre><br>1.var temp = $(“<option value="" + units[j] + "">“ + units[j] + “</option>“);<br>   temp.appendTo(父级选择器);<br>}<br>2.调用refresh接口<br>$(“#department”).multiselect(‘refresh’);<br></pre><br>重加载：<br><pre><br> 1.$(“选择器”).empty();<br> 2.再次调用初始化的代码<br></pre><br>事件：<br><pre><br>1.一般会使用change事件<br>$(“选择器”).change(function () {})<br></pre><br>获取选中的值：<br><pre><br>var val = $(“选择器”).multiselect(“getChecked”).map(function () {<br>    return this.value;<br>}).get()[0]; //可能有多选的情况<br></pre><br></h4>

<hr>
<p></p><h4>·  表格的插件<br></h4><br><a href="https://www.datatables.net/" target="_blank" rel="external">文档说明</a><p></p>
<p></p><h5>引用文件 </h5><p></p>
<pre>
js/jquery-2.1.1.js
js/jquery.dataTables.js
js/dataTables.bootstrap.js

css/bootstrap.css
css/dataTables.bootstrap.css
</pre>
<h5>声明</h5>
<pre>
table class="table table-hover table-striped table-bordered" id="att_table"
</pre>

<p></p><h5>表格重加载</h5><p></p>
<pre>
var table = $(选择器).DataTable();
table.destroy();
$(选择器).empty();
</pre>

<p></p><h5>异步插入数据</h5><p></p>
<pre>
var option = {
            paging : true,
            pageLength : 10,
            order : [],
            ordering : true,
            searching : true,
            bRetrieve : true,
            language : {
                lengthMenu : '<select class="form-control input-xsmall items-select">'
                + '<option value="6">6</option>'
                + '<option value="10">10</option>'
                + '</select>条记录',// 左上角的分页大小显示。
                search : '<span class="label label-success">搜索：</span>',
                paginate : {
                    previous : "上一页",
                    next : "下一页",
                    first : "第一页",
                    last : "最后"
                },
                zeroRecords : "没有内容",
                info : "总共_PAGES_ 页，显示第_START_ 到第 _END_ ，筛选之后得到 _TOTAL_ 条，初始_MAX_ 条 ",
                infoEmpty : "0条记录",
                infoFiltered : ""
            },
            paging : true,
            pagingType : "full_numbers"
};
$(table_id).dataTable(option);
</pre>

<hr>
<p></p><h4>· 关系网络(图)的插件<br></h4><br><a href="http://visjs.org/" target="_blank" rel="external"> 文档说明</a><p></p>
<p></p><h5>声明</h5><p></p>
<pre>
div id="graph" style="height:500px;" //需要指定高度
</pre>

<p></p><h5>异步加载数据</h5><p></p>
<pre>
jQuery(function() {
     var network = new vis.Network(container, g, options);
}
// container 容器
// g              数据
// options    选项
</pre>

<hr>
<p></p><h4>杂项</h4><br><p></p>
<p></p><p>1.获取文本框的值</p><br><strong>var val = document.getElementById(“h_name”).value;<br></strong><p></p>
<p></p><p>    2.在前端实现页面的跳转</p><br>在函数中添加   <strong>window.location.href = encodeURI( url );</strong><p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/06/Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/06/Dynamic-Programming/" itemprop="url">
                  Dynamic Programming
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-06T13:27:24+08:00">
                2016-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><pre><code>一般的dp数组需要记录以下几种信息:
1.当探索的元素为数组或者字符串的时候，通常会利用当前元素的下标作为数组的下标
    以当前元素作为子问题的最后一个元素时满足条件的值 
        -&gt; 该问题一般只需要一个边界 即子问题的形式类似sub_problem(i)
    以子问题第一个元素的下标和最后一个元素的下标作为子问题的范围边界
        -&gt; 该问题的形式类似于sub_problem(i，j)
</code></pre><h4 id="longestValidParentheses-最长的有效的括号序列-Leetcode32"><a href="#longestValidParentheses-最长的有效的括号序列-Leetcode32" class="headerlink" title="longestValidParentheses   最长的有效的括号序列(Leetcode32)"></a>longestValidParentheses   最长的有效的括号序列(Leetcode32)</h4><pre><code>需要一个dp数组记录以当前元素作为最后一个元素的有效的括号序列的长度
dp[i - 1] 记录的长度为l  
当前的元素为&apos;(&apos;，直接跳过，所以&apos;(&apos;的dp值都为0
当前的元素为&apos;)&apos;，前一个元素为&apos;(&apos;时即l=0的情况
                            前一个元素为&apos;)&apos;即获取前一个元素的最长序列
    则说明   0  1  2  3  4  5  6  7  8  9    注意边界条件 即t &gt; 0
    l = 3           t-1 t    i-1 i
    l = 0                    t-1 i          此时为相邻的两个元素                       
       此时比较s.charAt(t - 1)和s.charAt(i)的形式是否符合&quot;()&quot;. 如果符合，则有效的长度为dp[i - 1] + 2 + dp[t - 2] if i &gt; 1. 

初始化：所有元素的dp数组值全部初始化为0.
dp公式：dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 if valid &amp;&amp; i - dp[i - 1] &gt;= 2
               dp[i - 1] + 2             if valid &amp;&amp; t &lt; 2
               0                         if not valid.
复杂度：

本道题的dp数组就是当前符合条件的组合必须以当前元素结尾
同时需要一个变量记录以不同元素结尾的所有情况的最长序列
</code></pre><h4 id="largest-sum-of-subarray-最大子数组和-Leetcode53"><a href="#largest-sum-of-subarray-最大子数组和-Leetcode53" class="headerlink" title="largest sum of subarray  最大子数组和(Leetcode53)"></a>largest sum of subarray  最大子数组和(Leetcode53)</h4><pre><code>针对数组对象，需要注意子数组和子序列的区别，一个包含的元素必须**连续**，另一个包含的元素不需要连续，但需要保持之间的先后关系
一开始可能觉得应该使用子数组的范围来定义dp数组
但是实际上只需要记录子数组的最后一个元素的下标
dp[j] 实际上可以等效为dp[0][j] 而dp[0][j]实际上是dp[i][j]，其中0&lt;= i&lt;= j -1的最大值

初始化：所有元素的dp数组初始化为0
dp公式：dp[i] = num[i] + Math.max(0,dp[i - 1]) 
复杂度：
       需要注意的就是如果数组中存在负数，则需要添加0作为比较元素
</code></pre><h4 id="longest-increase-subsequence-最长递增子序列-Leetcode300"><a href="#longest-increase-subsequence-最长递增子序列-Leetcode300" class="headerlink" title="longest increase subsequence  最长递增子序列(Leetcode300)"></a>longest increase subsequence  最长递增子序列(Leetcode300)</h4><pre><code>最长递增子序列 因为可选取的元素不一定是连续的，所以与上面两个题目不同，不能只通过遍历一次即可获取到最大的值  

初始化：全部元素的dp数组全部初始化为1
dp公式：dp[i] =  Math.max(dp[i - k] + num[i] &gt; num[i - k]) 其中1 &lt;= k &lt;= i
复杂度：普通的方法时间复杂度为O(n^2) 
               想要把时间复杂度降低至O(nlgn) 则需要减少k的个数
               ~~ ##很明显 num[i] &gt; 或者 &lt; num[i - k]都只会增加1##~~
               ~~##所以可以记录最大的dp值的下标 并比较这些元素即可##~~
</code></pre><h4 id="largest-sum-of-elements-inside-rectangle-矩阵中任意长方形中的元素和-Leetcode304"><a href="#largest-sum-of-elements-inside-rectangle-矩阵中任意长方形中的元素和-Leetcode304" class="headerlink" title="largest sum of elements inside rectangle 矩阵中任意长方形中的元素和(Leetcode304)"></a>largest sum of elements inside rectangle 矩阵中任意长方形中的元素和(Leetcode304)</h4><pre><code>矩阵一般使用二维数组来表示 所以很明显可以使用二维数组来存放指定row和column的元素和
e.g            1  2  3  4                   
            1  0  2  1  3
            2  2  1  1  3 
            3  0  0  1  1             
            4  2  2  2  2    
则dp[row][col] = sum(matrix[1...row][1...col])
如何获取row1，row2，col1，col2范围内的数组和呢？(明显 row1 &lt;= row2 col1 &lt;= col2)
通过公式 sum = dp[row2][col2] - dp[row1][col2] - dp[row2][col1] + dp[row1][col1]
而dp数组的需要事先通过计算获取

初始化：dp数组全部初始化为0. 注意边界条件 [0][0],[0][j],[i][0]
dp公式: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i][j]
复杂度: 时间复杂度为O(n^2)        
</code></pre><h4 id="largest-sum-of-elements-inside-square-矩阵中所有元素全部为1的最大的正方形的面积-Leetcode221"><a href="#largest-sum-of-elements-inside-square-矩阵中所有元素全部为1的最大的正方形的面积-Leetcode221" class="headerlink" title="largest sum of elements inside square 矩阵中所有元素全部为1的最大的正方形的面积(Leetcode221)"></a>largest sum of elements inside square 矩阵中所有元素全部为1的最大的正方形的面积(Leetcode221)</h4><pre><code>因为要求正方形内的元素必须全部为1，所以其实与连续子数组类似，不过从一维的形式转变为二维，所以需要二维的数组作为dp数组
定义dp[i][j]表示包含matrix[i][j]作为右下角元素的最大正方形的面积
则当matrix[i][j] == &apos;0&apos;时dp[i][j] = 0
e.g            1  2  3  4                   
            1  0  1  1  1
            2  1  1  0  1 
            3  0  0  1  1             
            4  0  1  1  0    

初始化：注意边界条件 matrix[0][j]  matrix[i][0]的元素 为0则为0 为1则为1
dp数组：dp[i][j] = Math.min(dp[i - 1][j - 1],dp[i][j - 1],dp[i - 1][j]) + 1
复杂度：O(N ^2)的时间复杂度
</code></pre><h4 id="sum-of-elements-between-i-and-j-in-array-指定下标范围中的数组和-Leetcode303"><a href="#sum-of-elements-between-i-and-j-in-array-指定下标范围中的数组和-Leetcode303" class="headerlink" title="sum of elements between i and j in array 指定下标范围中的数组和(Leetcode303)"></a>sum of elements between i and j in array 指定下标范围中的数组和(Leetcode303)</h4><pre><code>给定范围下的数组和，因为数组的元素是连续的，所以只需要O(n)的时间复杂度遍历一次数组
可以定义dp数组保存array[0...j]的所有元素和
查询sum[i...j]时利用公式dp[j] - dp[i - 1] if i &gt; 0
                      dp[j]             if i == 0     

初始化：全部元素的dp数组初始化为0
dp数组：dp[j] = dp[j - 1] + num[j]
复杂度：O(n)的时间复杂度和空间复杂度
</code></pre><h4 id="least-num-of-perfect-square-numbers-which-sum-to-n-使用最少的完全平方数相加得到n-Leetcode279"><a href="#least-num-of-perfect-square-numbers-which-sum-to-n-使用最少的完全平方数相加得到n-Leetcode279" class="headerlink" title="least num of perfect square numbers which sum to n 使用最少的完全平方数相加得到n(Leetcode279)"></a>least num of perfect square numbers which sum to n 使用最少的完全平方数相加得到n(Leetcode279)</h4><pre><code>想要获取sum为n的情况，通常会利用dp数组得到sum为0...n-1的情况，逐步迭代直至获取n
此种情况和非连续的子序列相类似，当前的dp数组需要通过遍历前面的dp数组从而获取到最优的值，但是本题中完全平方数的个数有限，所以可以进一步缩小内部循环的次数 利用Math.sqrt(i)来获取内部循环的最大值

初始化：全部元素初始化为最大值
dp数组：dp[i] = Math.min(dp[i - k] + 1) 其中k = 1，4，9，16，25....
复杂度：时间复杂度为O()  ??
</code></pre><h4 id="NTH-ugly-number-第n个丑数-Leetcode264"><a href="#NTH-ugly-number-第n个丑数-Leetcode264" class="headerlink" title="NTH ugly number 第n个丑数(Leetcode264)"></a>NTH ugly number 第n个丑数(Leetcode264)</h4><pre><code>丑数的定义：质因数只包含2，3，5，同时默认1为第一个丑数
如何获取第n个丑数，我们可以发现，所有的丑数都是通过不断的乘以2，3，5得到的
所以为了保证获取到的元素的有序性，我们通过比较2，3，5当前对应的元素分别乘以2，3，5得到的最小值作为下一个元素，所以需要三个下标存放2，3，5对应的元素下标 
dp[i] = Math.min(2 * dp[m],3 * dp[n],5 * dp[k]) 
本题的特点在于当前dp数组的元素值的确定需要三个不同下标的元素来确定

初始化：m=n=k = 0;
dp数组：dp[i] = Math.min(2 * dp[m],3 * dp[n],5 * dp[k]) 
复杂度： O(N) 每获取一个元素需要O(1)的时间
</code></pre><h4 id="Partition-equal-subset-sum-将集合内的元素切分成sum相等的两个子集-Leetcode416"><a href="#Partition-equal-subset-sum-将集合内的元素切分成sum相等的两个子集-Leetcode416" class="headerlink" title="Partition equal subset sum 将集合内的元素切分成sum相等的两个子集(Leetcode416)"></a>Partition equal subset sum 将集合内的元素切分成sum相等的两个子集(Leetcode416)</h4><pre><code>要切分成sum相等的两个部分，首先可以计算获取所有元素的总和
因为同样是涉及到sum值所以dp数组通常设计为dp[0...sum]通过迭代获取
所以题目就转化为选取集合中的部分元素使之和为sum/2
这种类型的题目通常需要O(N^2)的时间，通过两层循环，外层为数组的下标，通过不断获取数组中新的元素更新dp数组内层循环则为sum值得迭代, 内层循环需要从大到小保证元素不会重复使用
需要注意集合内的每个元素只能使用一次

初始化：dp数组的全部元素初始化为0
dp数组： dp[i] = || (dp[i - num[j]]) 其中0 &lt;= j &lt;= num.length-1
复杂度：O(NK)
</code></pre><h4 id="num-of-arithmetric-in-array-数组中arithmetric的个数-Leetcode413"><a href="#num-of-arithmetric-in-array-数组中arithmetric的个数-Leetcode413" class="headerlink" title="num of arithmetric in array 数组中arithmetric的个数(Leetcode413)"></a>num of arithmetric in array 数组中arithmetric的个数(Leetcode413)</h4><pre><code>随着数组下标的增加，序列的长度和个数也随之增加，所以dp数组以数组元素的下标作为元素
则我们可以得到dp[j] = dp[j - 1] + 1 if num[j] - num[j - 1] = num[j - 1] - num[j - 2]
                    0             otherwise.
然后求sum = sum(dp[k]) 其中0 &lt;= k &lt;= num.length - 1          
面对这种情况的时候，可以省略到O(N)的空间复杂度 因为我们最终的结果只需要一个sum

初始化：cur = 0 sum = 0
dp数组：
复杂度：O(N)的时间复杂度  
</code></pre><h4 id="max-number-of-evenlopes-信封嵌套的最大数量-Leetcode354"><a href="#max-number-of-evenlopes-信封嵌套的最大数量-Leetcode354" class="headerlink" title="max number of evenlopes 信封嵌套的最大数量(Leetcode354)"></a>max number of evenlopes 信封嵌套的最大数量(Leetcode354)</h4><pre><code>信封为二维变量 包含x和y
这类题目需要对数组事先进行排序，排序的定义需要根据题目决定，例如本题的信封就需要先对x进行升序排序，当x相等的时候，需要对y进行降序排序，接着题目就转变成求最长的递增子序列
</code></pre><h4 id="sum-of-paths-from-top-left-to-right-bottom-从左上角到右下角的路径总数-Leetcode62"><a href="#sum-of-paths-from-top-left-to-right-bottom-从左上角到右下角的路径总数-Leetcode62" class="headerlink" title="sum of paths from top-left to right-bottom 从左上角到右下角的路径总数(Leetcode62)"></a>sum of paths from top-left to right-bottom 从左上角到右下角的路径总数(Leetcode62)</h4><pre><code>初始化：
dp数组：
复杂度: O(NM)的时间复杂度 O(MIN(m，n))的空间复杂度
</code></pre><h4 id="minimum-number-of-steps-convert-s-to-t-使用最少的操作将字符串s转换成t"><a href="#minimum-number-of-steps-convert-s-to-t-使用最少的操作将字符串s转换成t" class="headerlink" title="minimum number of steps convert s to t 使用最少的操作将字符串s转换成t"></a>minimum number of steps convert s to t 使用最少的操作将字符串s转换成t</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/06/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-06T12:46:22+08:00">
                2016-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
