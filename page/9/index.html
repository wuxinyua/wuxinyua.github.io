<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="to be to better">
<meta property="og:type" content="website">
<meta property="og:title" content="Heaven">
<meta property="og:url" content="http://wuxinyua.github.io/page/9/index.html">
<meta property="og:site_name" content="Heaven">
<meta property="og:description" content="to be to better">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heaven">
<meta name="twitter:description" content="to be to better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wuxinyua.github.io/page/9/"/>





  <title> Heaven </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heaven</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://wuxinyua.github.io/2017/03/16/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wuxinyua">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heaven">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/Mysql/" itemprop="url">
                  Mysql
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T09:20:22+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql知识点总结"><a href="#Mysql知识点总结" class="headerlink" title="Mysql知识点总结"></a>Mysql知识点总结</h1><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>涉及两个层面的控制：服务器层和存储引擎层</p>
<p>锁策略：在锁的开销和数据的安全性之间寻求平衡  同时需要根据特定的场景进行选取</p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a><strong>锁粒度</strong></h4><p>在mysql中涉及到的对象 数据库 表 属性 行记录</p>
<p><strong>表锁</strong> 即锁定整张表 此时不会发生死锁</p>
<p>用户在对表进行写操作的时候，需要获取写锁，此时会阻塞其他用户对表的所有读写操作 读锁不会相互阻塞</p>
<p><strong>行级锁</strong> 只在存储引擎层实现</p>
<p><strong>页面锁 </strong>与行级锁都会出现死锁</p>
<h4 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a><strong>死锁</strong>：</h4><p>含义：死锁指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环 </p>
<p>如何产生:</p>
<p>1.多个事务试图以不同的顺序锁定资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">start TRANSACTION;  #1</div><div class="line">update stockPrice set close = 20 where stockid = 2</div><div class="line">update stockPrice set close = 30 where stockid = 3</div><div class="line">commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">update stockPrice set close = 30 where stockid = 3</div><div class="line">update stockPrice set close = 20 where stockid = 2</div><div class="line">commit;</div></pre></td></tr></table></figure>
<p>解决方式：加锁顺序保持一致</p>
<p>2.使用事务插入新行  两个事务同时插入新的行  <!--好像没有死锁啊--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#第一种情况：假设当前该表的主键值的范围为1-1000</div><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 1020 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1020);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id = 1022 for update;</div><div class="line">④ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1022);</div><div class="line">#commit;</div><div class="line">#这种情况下，如果事务1未执行commit，则事务2无法执行insert操作，因为事务1使用gap锁将(1000,正无穷)进行锁定</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#第二种情况：假设当前该表的主键值的范围为1-1050</div><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 1020 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1020);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id = 1060 for update;</div><div class="line">④ insert into `police` values (&apos;a&apos;,&apos;b&apos;,1060);</div><div class="line">#commit;</div><div class="line">#这种情况下，如果事务1未执行commit，则事务2也可以执行insert操作，因为事务1使用gap锁将(1,1000)进行锁定,不会影响到事务2的key值</div></pre></td></tr></table></figure>
<p>3.多个事务同时锁定一个资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">start TRANSACTION;  #1</div><div class="line">① select * from `police` where id = 20 for update;</div><div class="line">③ insert into `police` values (&apos;a&apos;,&apos;b&apos;,18);</div><div class="line">#commit;</div><div class="line"></div><div class="line">start TRANSACTION;  #2</div><div class="line">② select * from `police` where id &lt; 30 for update;</div><div class="line">#commit;</div><div class="line"></div><div class="line">#按执行顺序来看，首先事务1锁定键为20的行，然后事务2锁定键为1-19的行，此时事务1需要锁定键为18的行，发生死锁</div></pre></td></tr></table></figure>
<p>死锁检测和死锁超时机制：</p>
<p>InnoDB：将持有最少行级排它锁的事务进行回滚</p>
<hr>
<p>schema和数据类型优化</p>
<p>添加计数表和汇总表<!--：待查询--></p>
<p>1.尽量使用可以正确存储数据的最小数据类型</p>
<p>2.尽量避免Null 对MyISAM来说，可为Null的列需要更多的存储空间，索引的构建也更加复杂</p>
<p>3.</p>
<hr>
<h3 id="mysql加锁机制"><a href="#mysql加锁机制" class="headerlink" title="mysql加锁机制"></a>mysql加锁机制</h3><hr>
<h3 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h3><p><strong>事务</strong>：一组原子性的sql查询 用户可以根据业务是否需要事务处理来选择合适的存储引擎</p>
<p>为什么要使用事务：</p>
<p>1.提供一种从失败中恢复的可靠机制，同时在系统故障的时候摆正数据的一致性</p>
<p>2.为并发访问数据库提供隔离机制</p>
<h5 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a><strong><u><em>ACID</em></u></strong>特性</h5><p>原子性：事务可以视为不可分割的最小工作单元，要么全部成功，要么执行回滚(全部失败)</p>
<p>一致性：从一个一致的状态转移到另一个一致的状态 (可以举在A,B之间转账的例子)</p>
<p>隔离性：一个事务所做的修改在提交之前，对其他事务不可见，即对个并发的事务不会相互影响</p>
<p>持久性：一旦事务提交，相应的修改永久保存在数据库之中</p>
<h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><strong>隔离级别</strong></h5><p><u>read uncommitted</u></p>
<p>事务A未提交，但是其中的修改可以对其他事务可见</p>
<p><u>read committed</u></p>
<p>事务从开始到提交之前，包含的修改对其他事务不可见</p>
<p><u>repeatable read</u> –Mysql默认级别</p>
<p>保证在同一个事务之中多次执行同样的读取记录的结果是一致的</p>
<p><u>serializable</u></p>
<p>强制事务串行执行，对读取的每一行数据都进行加锁</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read committed</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Read uncommited</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>serializable</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<h5 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a><strong>事务日志</strong></h5><p>1.事务型存储引擎 InnoDB NDB Cluster</p>
<p>2.自动提交 在不使用事务的时候，mysql默认视每个sql语句为一个事务</p>
<p>​    部分语句会强制触发commit语句的执行</p>
<p>3.查看事务隔离级别：  select @@tx_isolation</p>
<p>4.设置事务隔离级别     set session(global) transaction isolation level XXXX</p>
<p><strong>SavePoint</strong></p>
<p>Mysql逻辑架构    </p>
<p><img src="/Users/wuxinyua/Desktop/0_1314877463Mm91.gif" alt="0_1314877463Mm91"><img src="/Users/wuxinyua/Desktop/Jietu20170317-150337.png" alt="Jietu20170317-150337"></p>
<p>架构主要分为三层</p>
<p>第一层负责连接处理(线程池获取线程，一个连接对应一个线程)，授权认证，安全等</p>
<p>第二层包括查询解析，分析优化，缓存 所有跨存储引擎的功能在这一层实现(触发器，存储过程，视图)</p>
<p>在内部创建解析树，包括语法解析和词法解析，进行各种优化</p>
<p>第三层为存储引擎，负责数据的存储和提取</p>
<p><strong>Session 和Connection 事务</strong></p>
<p>session是通信双方从开始通信到通信结束的一个上下文环境，记录连接的相关信息</p>
<p>connection是从客户端到数据库的一条物理连接路径</p>
<p>session和connection是同时建立的，两者是对同一事件不同层次的描述，有点类似OSI分层中的传输层和会话层</p>
<p>一个连接可以进行多次会话，一个会话可以不依赖于某个连接</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>读锁(共享锁)</p>
<p>写锁(排它锁)</p>
<p>如何设置锁定模式：</p>
<p>1.select …… lock in share mode</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>索引的实现通常使用B树及其变种B+树</strong></p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>第二，可以大大加快数据的检索速度</p>
<p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p><strong>需要创建索引的列：</strong></p>
<p>1.在经常需要搜索的列上，可以加快搜索的速度；</p>
<p>2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p>
<p>3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p>
<p>4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p>
<p>5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<h5 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h5><p><strong>唯一索引</strong> 唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>
<p><strong>主键索引</strong>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>
<p><strong>聚集索引</strong>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h4 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B+Tree索引的性能分析"></a>B+Tree索引的性能分析</h4><p>到这里终于可以分析B+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。</strong>一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>1）B树</p>
<p>B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。</p>
<p>成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。</p>
<p>在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。</p>
<p>2）B+树</p>
<p>B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非叶节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引是稀疏索引。</p>
<p>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>所以 B+树有两种搜索方法：</p>
<p>一种是按叶节点自己拉起的链表顺序搜索。</p>
<p>一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。</p>
<p>B+ 树中，<strong>数据对象的插入和删除仅在叶节点上进行</strong>。</p>
<p>这两种处理索引的数据结构的不同之处：<br>a，B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。<br>b，因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。<br>c，B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a><strong>分区表</strong></h4><p>将数据按照较粗的粒度分布在不同的物理子表当中</p>
<p>1.在创建表的时候使用partition by子句定义每个分区存放的数据</p>
<p>2.在执行查询的时候，优化器根据分区定义过滤没有需要数据的分区</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a><strong>使用场景:</strong></h5><p>1.表的数据量大于可用的内存，或者表中的部分数据为热点数据</p>
<p>优势：可以以分区为单位进行维护，备份和恢复。不同分区的数据可以分布在不同的物理设备上</p>
<p>局限性：无法使用外键约束 最多只能有1024个分区</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图只是一种逻辑对象，是一种虚拟表，它并不是物理对象，因为视图不占物理存储空间，在视图中被查询的表称为视图的基表，大多数的select语句都可以用在创建视图中</p>
<p>优点：集中用户使用的数据，掩盖数据的复杂性，简化权限管理以及为向其他应用程序输出而重新组织数据等等</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>当有操作影响到触发器保护的数据时，触发器就自动发生，因此，触发器是在特定表上进行定义的，该表也称为触发器表，也是一种特殊类型的存储过程，与存储过程的区别：<u><strong>存储过程可以由用户直接调用执行，但是触发器不能被直接调用执行</strong></u></p>
<p>触发器的类型：insert类型，update类型，delete类型</p>
<p>语法：   create trigger trigger_name</p>
<p>　　　　on {table |view}</p>
<p>　　　　with encryprion</p>
<p>　　　　{for|after|instead of}{[delete][,][insert][,][update]}</p>
<p>　　　　as sql _statement</p>
<p>工作原理：</p>
<p>（insert）当向表中插入数据时，insert触发器触发执行，当insert触发器触发时，新的记录增加到触发器表中和inserted表中。触发器可以检查inserted表，来确定该触发器的操作是否应该执行和如何执行，在inserted表中的那些记录，总是触发器表中一行或多行记录的冗余；</p>
<p>（delete）当触发一个delete触发器时，被删除的记录放置在一个特殊的deleted表中。deleted表是一个逻辑表，用来保存已经从表中删除的记录；</p>
<p>（update）修改一条记录就等于插入一条新记录和删除一条旧记录，当在某一个update触发器表的上面修改一条记录时，表中原来的记录移动到deleted表中，修改过的记录插入到了inserted表中，触发器可以检查deleted表和inserted表以及被修改的表。</p>
<h4 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h4><p>存储过程是存储在服务器上的一组预编译的Transact-SQL语句，存储过程是一种封装重复任务操作的一种方法，支持用户提供的变量，具有强大的编程功能</p>
<p>优点：与其他应用程序共享应用程序的逻辑，因此确保一致的数据访问和操纵</p>
<p>   　　提供一种安全机制</p>
<p>　　　加速存储过程的执行，提高系统的性能</p>
<p>　　　减少网络交通</p>
<p>存储过程的类型：系统存储过程、本地存储过程、临时存储过程、远程存储过程和扩展存储过程。不同类型的存储过程具有不同的作用</p>
<p>语法：    create procedure procedure_name</p>
<p>　　　　 @parameter data_type</p>
<p> 　　　   with{recompile|encryption|recompile,encryption}</p>
<p>　　　    as sql_statement<br>执行存储过程有两种方法：</p>
<p>方法一：直接执行存储过程，就是调用execute语句来执行存储过程</p>
<p>方法二：在insert语句中执行存储过程</p>
<h4 id="应用层优化"><a href="#应用层优化" class="headerlink" title="应用层优化"></a>应用层优化</h4><p>问题：1.应用创建的数据库连接是否过多？是否使用了连接池？</p>
<p>​        2.应用是否在处理应该有数据库处理的事情？</p>
<p>​        3.应用是否在不使用的时候还保持连接打开？</p>
<p>思路：</p>
<p>1.缓存代理服务器</p>
<p>​    被动缓存  缓存未命中时返回空 memcached</p>
<p>​    主动缓存  访问未命中时将请求转发给应用来生成请求结果，然后存储该结果  squid</p>
<p>2.硬件负载均衡器</p>
<h4 id="mysql查询优化"><a href="#mysql查询优化" class="headerlink" title="mysql查询优化"></a>mysql查询优化</h4><p>数据库连接池</p>
<p>数据库索引</p>
<p>单点失效</p>
<p>负载均衡</p>
<h4 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h4><p><strong>原因：</strong></p>
<p>1.灾难恢复 硬件故障，操作失误，黑客攻击</p>
<p>2.测试  将备份文件还原到测试服务器上方便测试最新的额生产环境数据</p>
<p>3.需求发生变化，需要还原</p>
<p><strong>规划备份和恢复策略需要考虑的问题</strong></p>
<p>—-复制不是备份，使用RAID阵列也不是备份</p>
<p>1.可以容忍丢失多少数据量</p>
<p>2.恢复时间需要多长，备份数据需要多久</p>
<p>3.恢复的时候是否需要持续提供服务</p>
<p>4.恢复的对象是整个库，还是当个表</p>
<p>5.备份操作对服务器性能的影响</p>
<p><strong>备份类型</strong></p>
<table>
<thead>
<tr>
<th>数据库是否离线</th>
<th>冷备份</th>
<th>需要关闭mysql服务，不允许读写请求</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.根据业务需求选择  2. MyISAM不支持热备份，InnoDB支持</td>
<td>热备份</td>
<td>备份的同时，持续提供服务   <strong>文件系统快照</strong></td>
</tr>
<tr>
<td></td>
<td>温备份</td>
<td>备份的时候只允许读请求，不支持写请求</td>
</tr>
<tr>
<td>备份的数据范围</td>
<td>完全备份</td>
<td>备份完全的数据</td>
</tr>
<tr>
<td></td>
<td>增量备份</td>
<td>基于任意备份的基础，对更新的数据进行备份</td>
</tr>
<tr>
<td></td>
<td>差异备份</td>
<td>基于完全备份的基础，对更新的数据进行备份</td>
</tr>
<tr>
<td>备份的类型</td>
<td>物理备份</td>
<td>优点：1.可以直接复制存放在磁盘上的文件  2.恢复速度快                  缺点：物理备份不一定可以跨平台</td>
</tr>
<tr>
<td></td>
<td>逻辑备份</td>
<td>备份结果为 mysql可以解析的格式                                                                                                    优点：1.可以使用编辑器查看数据       2.可以通过网络来备份和恢复          3.与存储引擎无关                                    缺点：1.恢复速度慢，需要mysql加载解析语句，转化存储格式 2.浮点数的精度出现偏差  3.必须由数据库服务器完成备份</td>
</tr>
</tbody>
</table>
<p>建议混合使用物理备份和逻辑备份，先使用物理复制，以此数据启动mysql服务器实例并运行mysqlcheck，然后周期性的使用mysqldump之下就那个逻辑备份</p>
<p>增量备份和差异备份的区别：</p>
<p>1.差异备份是对上次全备份之后所有改变的部分进行备份，增量备份从任意类型的上次备份后所有的修改进行备份</p>
<p><strong>备份对象</strong></p>
<p>1.数据，配置文件，代码(存储过程，触发器，存储函数)，OS的相关配置，复制的相关配置，二进制日志，事务日志等</p>
<p><strong>备份和恢复的实现</strong><!--模拟一次实现--></p>
<h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><h4 id="语句类型"><a href="#语句类型" class="headerlink" title="语句类型"></a>语句类型</h4><table>
<thead>
<tr>
<th>DDL</th>
<th>数据定义语言</th>
<th>create,drop,alter</th>
</tr>
</thead>
<tbody>
<tr>
<td>DML</td>
<td>数据操纵语言</td>
<td>insert,delete,update,select</td>
</tr>
<tr>
<td>DCL</td>
<td>数据控制语言</td>
<td>grant，revoke</td>
</tr>
</tbody>
</table>
<h5 id="DDL、DML、DCL"><a href="#DDL、DML、DCL" class="headerlink" title="DDL、DML、DCL"></a>DDL、DML、DCL</h5><table>
<thead>
<tr>
<th>create DATABASE dbname;</th>
<th>创建数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>drop DATABASE</strong> dbname;</td>
<td>删除数据库</td>
</tr>
<tr>
<td><strong>create TABLE tablename</strong>(col_name,col_type,contraints,…. key `alias`(col_name)) ENGINE=”” CHARSET=””</td>
<td>创建表</td>
</tr>
<tr>
<td><strong>desc</strong> tablename;</td>
<td>描述表</td>
</tr>
<tr>
<td><strong>drop TABLE</strong> tablename;</td>
<td>删除表</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>MODIFY/CHANGE</strong> col_name column_def [<strong>FIRST/AFTER</strong> col_name];</td>
<td>更改表中的列定义</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>ADD</strong> [<strong>COLUMN</strong>] col_name [<strong>FIRST/AFTER</strong> col_name];</td>
<td>添加列到指定表</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>DROP [COLUMN]</strong> col_name;</td>
<td>在指定表中删除列</td>
</tr>
<tr>
<td><strong>ALTER TABLE</strong> tablename <strong>RENAME[TO]</strong> new_tablename;</td>
<td>更改表名</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>insert into tablename(field,..) into values(val,…)</th>
<th>插入数据</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>update</strong> tablename <strong>set</strong> field=val,… <strong>[where condition]</strong></td>
<td>更新数据</td>
</tr>
<tr>
<td><strong>delete from</strong> tablename <strong>[where condition]</strong></td>
<td>删除数据</td>
</tr>
<tr>
<td><strong>select * from</strong> tablename <strong>[where condition]</strong>[group by field…][order by field..][desc\</td>
<td>asc][limit offset,count][with ROLLUP][HAVING condition]</td>
<td>选择数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>grant priviledges on dbname.*/tname to ‘user’@’ip’ identified by ‘passwd’;</th>
<th>授权</th>
</tr>
</thead>
<tbody>
<tr>
<td>revoke priviledges on dbname.*/tname from ‘user’@’ip’</td>
<td>撤回权限</td>
</tr>
</tbody>
</table>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型用来指定存储格式，约束和有效范围</p>
<h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h5><table>
<thead>
<tr>
<th style="text-align:left">整数类型</th>
<th>tinyint,smallint,mediumint,int,bigint  [1,2,3,4,8]</th>
<th>小括号内的数字表示指定的显示宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">浮点类型</td>
<td>float,double</td>
<td>浮点数不写精度和标度的时候，根据实际值显示，如果指定后，自动进行四舍五入知之后的结果插入</td>
</tr>
<tr>
<td style="text-align:left">定点数类型</td>
<td>dec(m,d),decimal(m,d) [M+2]</td>
<td><strong>m表示有效数字的位数，d表示小数点之后的位数</strong>。decimal在不指定精度时，默认为(10,0)</td>
</tr>
<tr>
<td style="text-align:left">位类型</td>
<td>bit(m)</td>
<td>存放位字段值，必须使用<strong>bin()或者hex()函数查看结果</strong></td>
</tr>
</tbody>
</table>
<h5 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h5><table>
<thead>
<tr>
<th>date</th>
<th>显示年月日</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>datetime</td>
<td>显示年月日，时分秒</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>显示时分秒</td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td>显示时间戳，可以返回字符串或者数值</td>
<td>1、需要经常插入或者更新日期为当前系统时间，2、和时区相关，插入日期时，先转换为本地的时区后存放。3、支持的时间范围比较小</td>
</tr>
<tr>
<td>year</td>
<td>显示年份</td>
</tr>
</tbody>
</table>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><table>
<thead>
<tr>
<th>char(M)</th>
<th>长度固定</th>
<th>M为0-255，字节为单位，检索时char类型删除末尾的空格，varchar保留空格</th>
</tr>
</thead>
<tbody>
<tr>
<td>varchar(M)</td>
<td>变长字符串</td>
<td>M为0-65535</td>
</tr>
<tr>
<td>tinyblob/blob/mediumblob/longblob</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tinytext/text/mediumtext/longtext</td>
<td></td>
<td></td>
</tr>
<tr>
<td>varbinary/binary</td>
<td></td>
<td>0-M的变长/定长二进制字符串</td>
</tr>
<tr>
<td>enum</td>
<td></td>
<td>枚举类型，最多保存65535个成员，每次只允许从值集合中选取单个值</td>
</tr>
<tr>
<td>set</td>
<td></td>
<td>可以包含0-64个成员，每次可以一次选取多个成员</td>
</tr>
</tbody>
</table>
<p>char和varchar：</p>
<p>1、保存方式不同 char使用固定长度的字符类型，varchar使用可变长度的字符类型</p>
<p>​    固定长度的优势在于处理速度更快，但是浪费存储空间</p>
<p>2、检索方式不同，char会自动删除尾部的空格</p>
<p>3.不同的数据引擎选择不同，<strong>MyISAM建议使用固定长度的数据列，InnoDB建议使用varchar</strong></p>
<p>text和blob：</p>
<p>1、blob可以保存二进制文件，text只能保存字符数据</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h3 id="如何生成分布式系统中唯一的ID"><a href="#如何生成分布式系统中唯一的ID" class="headerlink" title="如何生成分布式系统中唯一的ID"></a>如何生成分布式系统中唯一的ID</h3><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在分布式系统中存在多个Shard的场景中，同时在各个Shard插入数据，如何给数据生成全局的唯一ID？</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1.全局唯一性</p>
<p>2.数据在多个shard之间进行迁移的时候不收到ID生成方法的限制</p>
<p>3.生成的ID包含时间信息</p>
<p>4.ID的长度最好不要超过64位</p>
<p>5.生成ID的速度应该达到一定的要求，比如10万+/秒</p>
<p>6.服务不存在<strong><u>单点</u></strong>   性能和可靠性</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>1.Twitter的Snowflake</strong></p>
<p>UniqueID ：0    +    41bits         +                    10bits                             + 12bits</p>
<p>​                     时间戳                节点ID(data center ID + worker ID)               序列号</p>
<ol>
<li>10bits的节点ID，可以在ID分配worker启动的时候，从Zookeeper集群获取</li>
<li>12bits的序列号根据时间戳进行一下操作<ol>
<li>如果当前的时间戳和上一个已生成ID的时间戳相同，使用前一个序列号+1，如果本毫秒内的序列号使用完毕，等待下一毫秒继续</li>
<li>如果当前的时间戳大于前一个ID的时间戳，随机生成一个序列号作为本毫秒中的第一个序列号</li>
</ol>
</li>
</ol>
<p><strong><u>异常情况</u></strong></p>
<p>如果当前获取的时间戳小于前一个ID的时间戳？</p>
<p>继续获取系统的时间戳直到大于前一个ID的时间戳</p>
<p><strong>2.Boundary flake</strong></p>
<p>ID：    64bits         +         48bits         +        16bits</p>
<p>​        时间戳                worker ID            序列号</p>
<p>优势：1.序列号的bits位增多可以减小冲突的概率</p>
<p>​        2.workID使用48bits可以直接利用机器的Mac地址 从而起到去中心化的目的</p>
<p><strong>3.instagram</strong></p>
<p>UniqueID :     41bits         +         13bits            +             10bits</p>
<p>​            时间戳                logic shard的编号                序列号</p>
<p>分布式存储方案：</p>
<p>1.将table横向拓展，划分为多个逻辑分片(logic shard)</p>
<p>2.规定每个逻辑分片存储到对已经的数据库实例上</p>
<p>3.每个table指定一个字段作为分片字段</p>
<p>4.插入数据时根据分片字段的值决定数据分配到相应的逻辑分片</p>
<p>5.根据逻辑分片和数据库实例的映射关系确定插入的数据库实例</p>
<p>–序列号利用postgreSQL的auto increment sequence 生成然后对2^10取模</p>
<p>优势：1.利用逻辑分片可以去中心化</p>
<p>​        2.通过ID可以直接知道记录被存放在哪个逻辑分片上</p>
<p>​        3.方便进行数据迁移</p>
<h3 id="数据库拓展"><a href="#数据库拓展" class="headerlink" title="数据库拓展"></a>数据库拓展</h3><h4 id="垂直拓展"><a href="#垂直拓展" class="headerlink" title="垂直拓展"></a>垂直拓展</h4><h4 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h4><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><p>高可用性是在宕机造成的损失和降低宕机时间花费的成本之间取平衡点</p>
<h5 id="造成数据库宕机可能的原因"><a href="#造成数据库宕机可能的原因" class="headerlink" title="造成数据库宕机可能的原因"></a>造成数据库宕机可能的原因</h5><p>1.磁盘的空间耗尽</p>
<p>2.性能问题，运行糟糕的sql操作，服务器bug</p>
<p>3.糟糕的schema和索引设计</p>
<p>4.复制问题，主备数据不一致</p>
<p>5.数据丢失问题，误删操作</p>
<p>提高高可用性</p>
<p>1.提升平均的失效时间</p>
<p>​    正确的监控Mysql的信息   为常见的失败情况制定对应的计划  测试所有的schema和sql语句</p>
<p>2.降低平均恢复时间</p>
<p>​    建立冗余，进行故障转移，避免单点失效</p>
<h3 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h3><p>1.为海量的前台数据提供高性能，大容量，高可用性的访问</p>
<p>2.为数据变更的消费者提供准实时的保障</p>
<p>3.高效的异地数据同步</p>
<h3 id="单点登录-分布式Session"><a href="#单点登录-分布式Session" class="headerlink" title="单点登录 + 分布式Session"></a>单点登录 + 分布式Session</h3><p>实现多系统应用群的登录，在多系统中登录一个系统，便可以在其他所有的系统中得到授权而无需再次登录</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡用来在多个计算机，网络连接，CPU，磁盘驱动器等其他资源中分配负载，达到资源的最佳化使用，最大化吞吐率，最小化响应时间，避免过载，同时通过冗余提高可靠性</p>
<p> <strong>会话(Session) 是和连接(Connection)是同时建立的，两者是对同一件事情不同层次的描述。简单讲，连接(Connection)是物理上的客户端同服务器的通信链路，会话(Session)是逻辑上的用户同服务器的通信交互</strong></p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>NoSQL的文档数据库</p>
<p>文档由键值对的集合组成，也是数据库数据的基本单元</p>
<p>优点：</p>
<p>1.灵活的数据模型，没有预定义的数据模式(schema)</p>
<p>2.性能</p>
<p>3.可拓展性和可靠性</p>
<p>4.非阻塞式的异步IO drivers</p>
<p>5.服务端的脚本XX.js</p>
<p>缺点：</p>
<p>1.不支持事务</p>
<p>2.没有触发器</p>
<p>3.不自动进行磁盘清理</p>
<h5 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a><strong>Hardware</strong></h5><ul>
<li>Ensure your working set fits in RAM</li>
<li>Use compression</li>
<li>Run single MongoDB per server.</li>
<li>Use SSDs for write-heavy applications</li>
</ul>
<h5 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a><strong>Data Model</strong></h5><ul>
<li>Store all data for a record in a single document.</li>
<li>Avoid large documents</li>
<li>Avoid unnecessarily long field names.</li>
<li>Eliminate unnecessary indexes.</li>
<li>Remove indexes that are prefixes of other indexes.</li>
</ul>
<h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h5><ul>
<li>Updates only modified fields.</li>
<li>Avoid negation in queries</li>
<li>Run explain() for every complex query.</li>
<li>Use covered queries when possible.</li>
<li>Use bulk inserts when needed.</li>
</ul>
<h5 id="Setup-and-Configuration"><a href="#Setup-and-Configuration" class="headerlink" title="Setup and Configuration"></a><strong>Setup and Configuration</strong></h5><ul>
<li>Have at least one secondary and one arbiter.</li>
<li>Set write concern to 2 when the data critical.</li>
<li>Have daily dump of data for backup.</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Wuxinyua" />
          <p class="site-author-name" itemprop="name">Wuxinyua</p>
           
              <p class="site-description motion-element" itemprop="description">to be to better</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wuxinyua</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
